---
title: 数据结构复习
top: false
cover: false
author: DULULU oO
date: 2022-05-31 08:53:53
password:
summary:
tags: 数据结构
categories: 数据结构
---

## 存储结构

- 线式存储结构： 结构地址空间连接，可随机访问，但顺序存储插入操作需要移动之后的元素，要耗费许多时间。

- 链式存储：不要求逻辑上相邻的元素在物理上相连，元素之间的逻辑关系通过指针表示。

- 顺序存储： 逻辑上相邻物理也相邻

## 数据结构

### 栈

栈： 先入后出，在表的末端（栈顶）进行插入删除，栈的存储结构分为**基于数组的存储表示和顺序存储结构**和**基于链表的链式存储结构**
    - 顺序栈的内存结构：存放栈中元素的数组、栈顶指针、最大容纳元素个数
    - 链式栈的内存结构：栈顶指针  

### 队列

- 队列：先入先出，队尾插入队首删除。
    - 队列的顺序存储结构利用一个*一维数组*作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。
    - 队列的链式队列由队首指针和队尾指针构成。

    - 循环队列元素个数 = （尾 - 头 + 表长） % 表长
        1. 当尾 > 头， 元素个数 = 尾 - 头
        2. 因为是循环队列，可能出现头>尾的情况， 此时元素个数 = 尾 - 头 + 表长
        为了得到一个统一的公式--循环队列元素个数 = （尾 - 头 + 表长） % 表长

    - 判断循环队列队空、队满的方法：
        front表示队头指针（指向队列内首元素）,rear表示队尾指针（指向队列内尾元素的下一个位置）,m表示队列的容量（包括那个留空的位置）

        **队列内元素个数：(rear - front + m) % m**

        ![](/img/posts/DataStructure/cycle_queue3.jpg)

        当队列为空时条件：**rear == front**，当队列满时条件为：**（rear+1）% maxsize == front**

### 哈希表

hash表的实现主要包括构造哈希和处理哈希冲突两个方面：

对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。

对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。

### 树

#### 最小生成树 

- 保持原图的n个系节点，并且有保持图联通的最少边。简单来说是有钱仅有n个点n-1条边的连通图。

- 最小生成树就是最小权重生成树的简称，即所有边的权值之和最小的生成树。

求解最小生成树的方法有一下两种

##### Kruskal算法（克鲁斯卡）

Kruskal是一种贪心算法

- 核心思想：每次选择一条最小的边，使这两条边两头连通 

- 将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树。

- 如果两个顶点在同一个集合内，说明已经通过其他边相连，如果将这条边加入生成树，就会形成环，因此不可取

Kruskal算法时间复杂的：O(mlogm),Kruskal算法的简单实现

```Java
//Kruskal算法简单实现
void Kruskal(V,T)
{
    T = V; //初始化树T，仅含顶点
    numS = n; //连通分量数
    while(numS > 1) //若连通分量数大于1
    {
        从E中取出权值最小的边(v,u);
        if(v和u属于T中不同的连通分量)
        {
            T=T∪{(v,u)}; //将此边加入生成树中
            numS--; //连通分量数减1
        }
    }
}

```
![](/img/posts/DataStructure/kruskal0.jpg)

