---
title: 排序算法汇总
top: false
cover: true
author: DULULU oO
date: 2022-04-31 19:01:27
password:
summary: 冒泡排序，插入排序，希尔排序，堆排序，快排，归并
tags: 
    - 数据结构
    - Java
categories: 数据结构
---

- 为了方便表示,提前定义swap(num[],i,j)
    ```java
    
    protected void swap(int[] num, int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    ```

### 冒泡排序

- 从左到右不断交换相邻的逆序的元素，复杂度为O(N^2)

```java
    public void sort(int[] nums) {
        int N = nums.length;
        boolean isSorted = false;
        for (int i = N - 1; i > 0 && !isSorted; i--) {
            isSorted = true;
            for (int j = 0; j < i; j++) {
                if (nums[j + 1] < nums[j]) {
                    isSorted = false;
                    swap(nums, j, j + 1);
                }
            }
        }
    }
    
```

### 插入排序

- 左侧是以及排好序的涉猎，每次排序都将当前元素插入左侧已经排序的数组中，是的插入之后左侧数组依然有序。

- 以数组[3,4,1,5,2]为例，逆序的对有(3,1),(3,2)(4,1)(4,2)(5,2)，插入排序每次交换逆序元素，因此插入排序交换的次数为逆序的数量插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要交换的次数也少，时间复杂度较低

- Worst case:数组倒序
- Best case:数组有序

```java
public void sort(int[] nums) {
        int N = nums.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0 && nums[j] < nums[j - 1]; j--) { /* 这一步会把左边的都排好序 */
                swap(nums, j, j - 1);
            }
        }
    }
```

时间复杂度：**最坏情况下为O(N*N)**，此时待排序列为逆序，或者说接近逆序最好情况下为O(N)，此时待排序列为升序，或者说接近升序。
空间复杂度：O(1)

### 希尔排序

插入排序不适用于，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的难以处理大规模数组的问题，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。

- 先将待排序数组进行与排序，是的待排序数组接近于有序，再对该序列进行一次插入排序

- eg: 
        3 2 5 4 1 6(gap = 6)
        3 2 5 4 1 6(gap = 6/2 = 3) (3,4)是正序，不需要改变
        3 1 5 4 2 6(gap = 3) (2,1)变成（1,2）
        3 1 5 4 2 6(gap = 3) (5,6)是正序不需要改变
        3/2 = 1,此时用插入排序（若gap = 10，10/2 = 5， 5/2 =2>1,则在以gap = 2进行排序
        
```java
public void sort(T[] nums) {

        int N = nums.length;
        int h = 1;

        while (h < N / 3) {
            h = 3 * h + 1; // 1, 4, 13, 40, ...
        }

        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(nums[j], nums[j - h]); j -= h) {
                    swap(nums, j, j - h);
                }
            }
            h = h / 3;
        }
    }
```
**时间复杂度平均：O(N^1.3)**
**空间复杂度：O(1)**

### 选择排序

每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。

```java
public void sort(int[] nums) {
        int N = nums.length;
        for (int i = 0; i < N - 1; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (nums[j]< nums[min]) {
                    min = j;
                }
            }
            swap(nums, i, min);
        }
    }

```

时间复杂度：最坏情况：**O(N^2)**
            最好情况：O(N^2)
空间复杂度：O(1)

- 改进：我们可以一次性选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。


### 堆排序

堆排序是一种树形选择排序，它利用堆这种数据结构，将待排序列构造成一个大根堆或小根堆，然后将堆顶元素（最大或最小元素）与最后一个元素交换，再重新调整堆，直到排序完成。时间复杂度为 O(nlogn)。

**堆是一颗完全二叉树**，可以用数组来表示，因为完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。
- 大根堆：所有父节点大于子节点
    小根堆：所有父节点小于子节点

#### 堆的定义

```java
public class Heap<T extends Comparable<T>> {

    private T[] heap;
    private int N = 0;

    public Heap(int maxN) {
        this.heap = (T[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    private boolean less(int i, int j) {
        return heap[i].compareTo(heap[j]) < 0;
    }

    private void swap(int i, int j) {
        T t = heap[i];
        heap[i] = heap[j];
        heap[j] = t;
    }
}

```

#### 堆的上浮与下沉

- 一般采用大根堆--当一个节点比父节点大时，需要交换这两个节点。交换后可能还比它的新的父节点大，因此需要不断地进行比较和交换，这就是上浮操作。

k/2是父节点

```java
private void swim(int k) {
    while (k > 1 && k / 2 < k) {
        swap(k / 2, k);
        k = k / 2;
    }
}

```
类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。

```java
private void sink(int k) {
    while (2 * k <= N) {
        int j = 2 * k;
        if (j < N && j < j + 1)
            j++;
        if (k > j)
            break;
        swap(k, j);
        k = j;
    }
}

```
#### 插入与删除

- 插入：将新元素放到数组末尾，然后上浮到合适的位置
    ```java
        public void insert(Comparable v) {
            heap[++N] = v;
            swim(N);
        }

    ```

- 删除：从堆顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。

    ```java
        public T delMax() {
            T max = heap[1];
            swap(1, N--);
            heap[N + 1] = null;
            sink(1);
            return max;
        }
    ```

#### 堆排序


### 快排

它的主要思想是**选取一个基准元素，通过一趟排序将待排序列分成两部分**，其中一部分比基准元素小，另一部分比基准元素大。然后再分别对这两部分递归地进行快速排序，最终完成排序。时间复杂度为 O(nlogn)

参考[Leetcode图解算法结构--快速排序](https://leetcode.cn/leetbook/read/illustration-of-algorithm/p57uhr/)
快速排序算法有两个核心点，分别为 哨兵划分 和 递归 .

#### 哨兵划分：

以数组某个元素（一般选取首元素）为 基准数 ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。

如数组 [3,2,5,1,0,4]
选取最左元素arr[0] = 3作为 l， 最右元素arr[5] = 4 作为r，假设以arr[0] = 3作为哨兵，那么令 i 从 l 开始向左移动，令 j 从 r 开始向右移动
[3,2,5,1,0,4] 
 i         j
 此时arr[j]=4>3,所以j左移
[3,2,5,1,0,4] 
 i       j
 此时arr[j] = 0 < 3, j不动， i开始移动
[3,2,5,1,0,4] 
     i   j
此时arr[i] = 5 < 3，所以**此时arr[i]与arr[j]元素交换位置**，原数组变为[3,2,0,1,5,4]， j继续左移
[3,2,0,1,5,4]
     i j
 此时arr[j] = 1 < 3, j不动， i开始移动

[3,2,0,1,5,4]
       ij
此时i,j相遇，将该元素与最左元素，也就是**哨兵元素**换位，原数组变为
[1,2,0,3,5,4]

#### 递归

以哨兵元素作为划分标准，哨兵元素左侧的数组为左子数组，哨兵元素右侧的数组为右子数组。
快排后数组[1,2,0,3,5,4],左子数组为[1,2,0] 哨兵：3 右子数组为[5,4]
然后对左右子数组重复快排
左子数组[1,2,0] -> [1,0,2] -> [0,1,2]
右子数组[5,4] -> [4,5]

[0,1,2] 3 [4,5]

排序完成

#### 代码实现

```java

    /**
     * 分类，其中每次返回的i其实正是哨兵的数字
     * @param arr
     * @param l
     * @param r
     * @return
     */
    public int Sort(int arr[], int l, int r){
        
        int sentry = arr[l+r/2]; // 定义哨兵
        int j = r,i = l;
        
       for(; i < j;){
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr, i, j);
        }
        swap(arr, i, l);
        return i;
    }

    void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    /**
     * 递归，多次快排
     * @param arr
     * @param l
     * @param r
     */
    public void SortInRecurse(int[] arr, int l, int r){
        if(l >= r) return;
        int index = Sort(arr, l ,r);
        System.out.println("num:"+index);

        SortInRecurse(arr, l, index-1);
        SortInRecurse(arr, index+1, r);

    }

```

### 归并排序

它的主要思想是将**待排序列分成若干个子序列**，然后将每个子序列进行排序，最后将排好序的子序列合并成一个有序序列。时间复杂度为 O(nlogn)。

> **归并和快排的区别**：快速排序是一种交换排序，它在排序过程中直接交换元素位置，**通过一次排序将待排序序列分成两个子序列，递归地对两个子序列进行排序**。而归并排序是一种合并排序，它将**待排序序列分成两个子序列，递归地对两个子序列进行排序，**然后将排好序的两个子序列合并成一个有序序列。

> 归并、快排和堆排序：快速排序和归并排序都是递归算法，适用于大规模数据的排序；而堆排序则是一种非递归算法，适用于内存有限的排序场景

[算法解析](https://leetcode.cn/leetbook/read/illustration-of-algorithm/p5l0js/)
归并排序体现了 “分而治之” 的算法思想，具体为：

「分」： 不断将数组从 中点位置 划分开，将原数组的排序问题转化为子数组的排序问题；
「治」： 划分到子数组长度为 1 时，开始向上合并，不断将 左右两个较短排序数组 合并为 一个较长排序数组，直至合并至原数组时完成排序；

![Merge](/img/posts/DataStructure/merge_sort.jpg)

该算法可以分为划分子数组和合并子数组两步

如数组[4,2,3,1]
先分为[4,2],[3,1]
再分为[4][2][3][1]

合并：对于原数组[4，2，3，1]，构建一个tmp数组，存放每次递归中的**arr子数组**。如第一次**递归tmp[] = [4,2]**,m为原数组中间数 = (r+l)/2 = 0，l为最左侧 = 0，r为最右侧 = 1。
 令i = 0, j = m-l+1 = 1, tmp[i] = 4, tmp[j] = 2 , 因为2<4， 令arr[0]2，然后j++, 发现右数组遍历完成，由此原数组 **arr = [2,2,3,1]**
在arr[1] = tmp[j], 原数组 **arr[] = [2，4，3，1]**, j++, tmp[j] = 3 > tmp[i] = 2

[1，3]同理（此时是新一轮为递归）, 此时原数组为[2，4，3，1],tmp[] = [3,1], l = 2, r = 3, m = 2, 重新令i = 0, j = m-l+1 = 1。 tmp[i] = 1 > tmp[j] = 3, 因此arr[2] = tmp[j] = 1，原数组 **arr[] = [2,4,1,1]**,j++,发现j>=r-l, 开始直接将tmp[i]加入数组，此时原数组 **arr[] = [2,4,1,3]**,归并结束 


#### 代码示例

```java

    public void merge(int arr[], int l, int r){
        if(l>=r) return;

        // partition
        int m = (r+l)/2;
        merge(arr, l, m);
        merge(arr, m+1, r);

        // merge
        int[] tmp = new int[r-l+1];
        int i = 0, j = m-l+1;
        for(int k = 0; k<r-l+1;k++){
            tmp[k] = arr[k+l];
        }

        /*
        注意因为每次递归都会更新一部分的arr
        比如原arr[3,1,4,2]
        第一次递归对3,1排序， 排完后arr变成[1,3,4,2]
        第二次递归需要对4,2排序,所以要求arr的下标从arr[2]也就是4开始,因此int k = l 而不是 0
         */
        for(int k = l; k <= r; k++){

            if(i > m-l)  {
                arr[k] = tmp[i];// if left approch the end
                i++;
            }
            else if(j > r-l) {
                arr[k] = tmp[i++];
            }
            else if(tmp[i] <= tmp[j]){
                arr[k] = tmp[i++];
            }
            else if(tmp[i] > tmp[j]){
                arr[k] = tmp[j++];
            }
        }
    }
```

##### 对链表归并

[Leetcode148](https://leetcode.cn/problems/sort-list/)
148. 排序链表
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

如4->1->3 返回 1->3->4


注意链表和数组的不同，链表由于没有下标，在划分的时候，用快慢指针，fast每次移动两步，而slow每次移动一步

```java

    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            fast =fast.next.next;
            slow = slow.next;
        }
        ListNode mid = slow.next;
        slow.next = null;
        ListNode left = sortList(head);
        ListNode right =  sortList(mid);

        ListNode cur = new ListNode(0);
        ListNode res = cur;
        while(left != null && right != null){

            if(left.val > right.val){
                cur.next = right;
                right = right.next;
            }
            else{
                cur.next = left;
                left = left.next;
            }
            cur = cur.next;
        }
        cur.next = left == null? right: left;
          return res.next;
    }
```



