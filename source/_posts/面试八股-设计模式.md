---
title: 面试八股--设计模式
top: false
cover: false
author: DULULU oO
date: 2023-04-17 19:12:45
password:
summary:
tags: 设计模式
categories: 面试
---

常见的设计模式：单例模式，工厂方法模式，抽象工厂模式，代理模式，装饰器模式，观察者模式，责任链模式


## 单例模式

特点：**一个类只有一个实例**，且该类能自行创立这个实例，单例类对外提供一个访问该单例的全局访问点

优点：
1. 可以保证内存里只有一个实例，减少内存的开销
2. 避免对资源的多重占用

缺点：
1. 单例模式一般没有接口，拓展困难

### 饿汉式单例
类一旦加载就创建一个单例，保证在getInstance（）方法前单例就已经存在，这种饿汉式会造成空间浪费
```java
public class Hungry {
    private Hungry(){}
    private final static Hungry HUNGRY = new Hungry();
    public static Hungry getInstance(){
        return HUNGRY;
    }
}
```

### 懒汉式单例
为了避免内存空间的浪费，采用懒汉式，即用到该单例对象的时候再创建
```java
public class LazyMan {
    private LazyMan(){
        System.out.println(Thread.currentThread().getName()+"");
    }
 
    public static LazyMan lazyMan;
 
    public static LazyMan getInstance(){
        if (lazyMan==null){
            lazyMan = new LazyMan();
        }
        return lazyMan;
    }
 
    public static void main(String[] args) {
        for(int i=0;i<10;i++){
            new Thread(()->{
                lazyMan.getInstance();
            }).start();
        }
    }
}
```
但这段代码在多线程下会存在问题，会发现结果都不一样，因此，并发情况下，这段代码是有问题的。我们需要进行两端检测，进行“加锁”：synchronized (Singleton.class)。
```java
public class LazyMan {
    private LazyMan(){
        System.out.println(Thread.currentThread().getName()+"");
    }
 
    public static LazyMan lazyMan;
 
    public static LazyMan getInstance(){
        if (lazyMan==null){        //第一层检查，检查是否有引用指向对象，高并发情况下会有多个线程同时进入
            synchronized (LazyMan.class){    //第一层锁，保证只有一个线程进入
                //双重检查，防止多个线程同时进入第一层检查(因单例模式只允许存在一个对象，故在创建对象之前无引用指向对象，所有线程均可进入第一层检查)
                //当某一线程获得锁创建一个LazyMan对象时,即已有引用指向对象，lazyMan不为空，从而保证只会创建一个对象
                //假设没有第二层检查，那么第一个线程创建完对象释放锁后，后面进入对象也会创建对象，会产生多个对象
                if(lazyMan==null){    //第二层检查
                    //synchronized关键字作用为禁止指令重排，保证返回Singleton对象一定在创建对象后
                    lazyMan = new LazyMan();        //这行代码存在的问题，不能保证原子性实际上会执行以下内容：
                    //(1)在堆上开辟空间；(2)属性初始化;(3)引用指向对象
                    //假设以上三个内容为三条单独指令，因指令重排可能会导致执行顺序为1->3->2(正常为1->2->3),当单例模式中存在普通变量需要在构造方法中进行初始化操作时，单线程情况下，顺序重排没有影响；但在多线程情况下，假如线程1执行lazyMan = new LazyMan()语句时先1再3，由于系统调度线程2的原因没来得及执行步骤2，但此时已有引用指向对象也就是lazyMan!=null，故线程2在第一次检查时不满足条件直接返回lazyMan，此时lazyMan为null
                    //synchronized关键字可保证lazyMan = new LazyMan()语句执行顺序为123，因其为非原子性依旧可能存在系统调度问题(即执行步骤时被打断)，但能确保的是只要lazyMan!=0，就表明一定执行了属性初始化操作；而若在步骤3之前被打断，此时lazyMan依旧为null，其他线程可进入第一层检查向下执行创建对象
                }
            }
        }
        return lazyMan;
    }
 
    public static void main(String[] args) {
        for(int i=0;i<10;i++){
            new Thread(()->{
                lazyMan.getInstance();
            }).start();
        }
    }
}
```

## 工厂方法模式
实例化对象不是用new，用工厂方法替代。将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。
### 简单工厂模式

用来生产同一等级架构中的任意产品(对于增加新的产品，需要修改已有代码)
在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。

以一个接口，两个实现类，一个工厂，一个测试类为例

```java
//创建enemy接口
public interface Enemy {
    void name();
}
//创建boss实现类
public class Boss implements Enemy{
    @Override
    public void name() {
        System.out.println("Boss");
    }
}
//创建guard实现类
public class Guard implements Enemy{
    @Override
    public void name() {
        System.out.println("Guard");
    }
}
//创建工厂
public class EnemyFactory {
    public static Enemy getEnemy(String enemy){
        if(enemy.equals("Boss")){
            return new Boss();
        }else if(enemy.equals("Guard")){
            return  new Guard();
        }else {
            return null;
        }
    }
}
//测试类
public class Consumer {
    public static void main(String[] args) {
        Enemy p1= EnemyFactory.getEnemy("Boss");
        Enemy p2= EnemyFactory.getEnemy("Guard");
        p1.name();
        p2.name();
    }
}
```

我们通过创建一个PhoneFactory类，成功的完成工厂的创建。我们在创建对象时，也就不需要直接创建对象，而是可以通过创建工厂，这样大大的降低了代码的耦合性。
**但是，静态工厂模式是不能添加数据的**。比如说，我们想添加一个“Slim”敌人类，你不直接修改工厂代码，是不能实现的。所以，就有了第二种的工厂方法模式。

### 工厂方法模式

```java
//创建敌人接口
public interface Enemy {
    void name();
}
//创建Boss实现类
public class Boss implements Enemy{
    @Override
    public void name() {
        System.out.println("Boss");
    }
}
//创建敌人工厂接口
public interface EnemyFactory {
    Enemy getEnemy();
}
//创建Boss工厂
public class BossFactory implements EnemyFactory{
    @Override
    public Phone getEnemy() {
        return new Boss();
    }
}
//测试类
public class Consumer {
    public static void main(String[] args) {
        Enemy enemy = new BossFactory().getEnemy();
        enemy.name();
    }
}
```

我们创建了敌人工厂接口EnemyFactory，再创建Boss工厂，这样就可以通过BossFactory创建对象。增加新的具体工厂和产品族很方便，比如说，我们想要增加guard，只需要创建一个GuardFactory实现enemy工厂接口，合理的解决的简单工厂模式不能修改代码的缺点。但是，在现实使用中，简单工厂模式占绝大多数。
