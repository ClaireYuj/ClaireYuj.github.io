---
title: 协同过滤推荐算法
top: true
cover: false
author: DULULU oO
date: 2021-12-01 13:18:43
mathjax: true
password:
summary:
tags:
    - 推荐系统
    - 协同过滤
categories: 机器学习
---

协同过滤(collaborative filtering)算法
## 基于内容的推荐系统

![4人对于5门电影的打分表，x1,x2表示电影的特征](/img/posts/MachineLearning/recommend_system0.jpg)

把每个用户的评分看作一个线性回归问题，对用户评分进行预测，不同的用户与不同的参数$\theta$相关

## 协同过滤算法

- 特征学习：可以自动学习所要使用的特征

用户有一定的特征变量，并且已知用户对部分商品的兴趣

仍然是这个例子

![现在不知道x1，x2的倾向](/img/posts/MachineLearning/recommend_system1.jpg)

但是已知用户对于romance和action电影的喜爱度，$\theta^{(1)}$是Alice的特征，由此可知她对于romance电影的喜爱度为5，action的喜爱程度为0，$\theta^{(3)}$是Carol的特征，由此可知她对于romance电影的喜爱度为0，action的喜爱程度为5。

![用户特征](/img/posts/MachineLearning/recommend_system2.jpg)

由此我们得出，需要满足以下条件：
$$(\theta^{(1)})x^{(1)} = 5$$
$$(\theta^{(2)})x^{(1)} = 5$$
$$(\theta^{(3)})x^{(1)} = 0$$
$$(\theta^{(4)})x^{(1)} = 0$$

所以
$$ x^{(1)}  =  \begin{bmatrix}1 & 1.0 & 0.0 \end{bmatrix}$$
第一项是截距项

### 算法推导过程

如果用户已经给了我们偏好--特征$\theta^{(1)}$,$\theta^{(2)}$...$\theta^{(n)}$对$x^{(i)}$进行学习，我们要做的是求出：

$$\min \frac{1}{2} \displaystyle \sum_{j:r(i,j)=1}({(\theta^{(j)})}^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)})^2$$

这一步要做的是选择一个特征$x^{(i)}$，算法根据所有评价过电影的用户计算出一个值来预测某个用户会如何评价这部电影
$\frac {\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)}$是一个正则项，防止特征值过大

为了学习所有电影的所有特征，也就是学习$x^{(1)},x^{(2)}...x^{(n_m)}$\，需要求出
![](/img/posts/MachineLearning/recommend_system_equation.jpg)

$\displaystyle \sum_{i=1}^{n_m}$是对所有电影求和

### 算法作用

- 可以通过用户喜爱程度$\theta^{(1)},\theta^{(2)}...\theta^{(n_u)}$来预测电影的特征$x^{(1)}...x^{(n_m)}$

- 也可以通过电影特征$x^{(1)}...x^{(n_m)}$来预测用户喜爱程度$\theta^{(1)},\theta^{(2)}...\theta^{(n_u)}$

可以通过先随机地选取一些$\theta$地值来学习出不同电影地特征，在得到电影特征之后，再通过这些特征来预测另外的$\theta$值（用户喜爱程度，再根据这些$\theta$来预测电影特征...如此反复，最终将会收敛到一组合理的电影特征以及合理的对用户地预测

### 算法步骤

1. 将$x^{(1)},x^{(2)}...x^{(n_m)}$,$\theta^{(1)},\theta^{(2)}...\theta{(n_u)}$初始化为一些小地随机出

2. 使用梯度下降将代价函数最小化，

![括号内的内容是对代价函数地偏导](img/posts/MachineLearning/recommend_system3.jpg)

3. 用一些有参数$\theta$的用户和有特征$x$的电影，来预测用户评分$\theta^Tx$

## 矩阵分解

用户对电影评分可以写成如图所示评分矩阵
![](img/posts/MachineLearning/recommend_system4.jpg)

该评分矩阵的实质是$\theta^{(j)}*x^{(i)}$

![](img/posts/MachineLearning/recommend_system5.jpg)

如果要给用户推荐相似的电影，可以通过两个电影之间的距离来判断，如果电影$x^{(i)}$与$x^{(j)}$非常相近，那么可以把$x^{(j)}$推荐给喜欢$x^{(i)}$的人

## 协同过滤算法中的均值归一化

对于没有看过电影的人，或者那些给所有电影都打分为零分的人，很难推荐电影给他们。可以通过已知用户对于电影的打分，计算出该电影的均分，最后生成均分矩阵
$$\mu = \begin {bmatrix} \mu_1 & \mu_2 & ...& \mu_n \end {bmatrix} $$

![5个电影的评分矩阵如图，但不知道最后一个人对于每个电影的打分](img/posts/MachineLearning/recommend_system6.jpg)

![通过计算均值，得到了每个电影的均分矩阵](img/posts/MachineLearning/recommend_system7.jpg)

![原评分矩阵中的元素减去对应的均值后，德奥新的评分矩阵](img/posts/MachineLearning/recommend_system8.jpg)

将均一化后的矩阵作为额数据集进行$\theta^{(j)}$参数的学习，预测函数为：
$${(\theta^{(j)})}^T{(X^{(i)})}+\mu_i$$

对于没有打分的用户5
$$\theta^{(5)} = \begin {bmatrix}0 & 0 \end {bmatrix}$$

最终用户5的打分为 $\mu_i$

**可用于解决用户冷启动问题**