---
title: 计算机网络复习笔记1--概述
top: false
cover: false
author: DULULU oO
date: 2022-10-05 10:15:00
password:
summary:
tags: 计算机网络
categories: 
    - 计算机网络
    - 面试
---

复习计算机网络相关知识

## 性能指标

1. 速率
网络技术中的速率指的是**数据的传送速率**，也称为**数据率**或**比特率**。单位是bit/s。
一般提到网络的速率指的是额定速率（标定速率），而非实际运行的速率。
2. 带宽
贷款用来表示网络中某**通道**传送数据的能力，因此网络带宽表示再单位时间内网络中**某信道**所能通过的**最高数据率**。单位是bit/s
3. 吞吐量
在单位时间内通过某个网络（或信道、接口）的**实际数据量**。吞吐量收网络带宽与网络额定速率的限制。接入网络主机的实际吞吐量取决于**互联网的具体情况**。
4. 时延
数据（一个报文、分组甚至比特）从网络的一端到另一端所需的时间。
总时延 = 发送时延+传播时延+处理时延+排队时延
主要影响是**发送时延**和**传播时延**
传播时延是比特在链路上传播的时延。
5. 时延带宽积
时延带宽积 = 传播时延 x 带宽
等同在任何特定时间该网络线路上的**最大数据量**——已发送但尚未确认的数据。
链路像一个空心管道，时延是管道长，带宽是管道切面面积
6. 往返时间RTT
大部分情况下，互联网上的信息不是单方传输而是双向交互的。

## 计算机网络体系结构

**协议**: 网络协议是为进行网络中的数据交换而建立的规则。这些规则明确规定了数据的格式以及预期有关的同步问题。
协议主要由一下三个要素组成：语法（数据和控制信息的结构或者格式）、语义（需要发出何种控制信息）、同步（时间实现顺序的详细说明）。

## OSI七层模型

![OSI](/img/posts/ComputerNetwork/OSI.jpg)
![TCP/IP](/img/posts/ComputerNetwork/TCP_IP.jpg)
![OSI与TCP/IP的对比](/img/posts/ComputerNetwork/OSI_TCPIP.jpg)
OSI有七层**物理层，数据链路层，网络层，传输层，会话层，表示层，应用层**
TCP/IP：**网络接口层，网络层，传输层，应用层**，TCP/IP的网络接口处覆盖率 OSI中的物理层和数据链路层

**网络层**

提供**主机和主机**之间的逻辑通信

协议有ARP协议、OSPF/RIP路由寻址协议、DHCP协议、ICMP协议、IGMP组播协议、IP协议、CIDR协议

设备有路由器（作用：转发分组）

**传输层**

提供端到端的可靠报文传递，负责将数据传送至对应端口，提供**进程和进程**之间的逻辑通信

协议有TCP UDP协议

**会话层**

负责建立、管理、终止进程之间的会话

**表示层**

对上层数据或者信息进行变换，以保证一个主机应用层信息可以被另一个主机应用层所理解，包括数据加密、格式转换、压缩等

**应用层**

为操作系统或者网络应用程序提供访问网络的接口 协议有HTTP FTP SMTP DNS协议

### 网络层协议

#### IP

实现数据包的路由和转发，IP协议为每个数据包分配一个唯一的IP地址，以便数据包在网络中进行传输

#### ICMP
用于网络设备之间传递错误信息和控制信息，例如ping命令就是通过ICMP协议实现的。

#### ARP
地址解析协议，将IP地址转为MAC地址

### OSPF
是开放式最短路径优先协议，用于实现路由协议，控制数据包在网络中的传输路径，以提高网络的可靠性和稳定性。

### 传输层协议

#### TCP
用于实现可靠的数据传输和流量控制，确保数据包能够按照正确的顺序到达目的地。

#### UDP
用于实现不可靠的数据传输，适合实时数据传输，如视频和语音等。

### 路由层

#### BGP
边界网关协议，用于控制Internet中的路由信息，管理自治系统之间的连接和数据流向

#### MPLS
多标签交换，用于在数据包传输过程中标记和识别数据包，提高网络的传输效率和可靠性。

#### ISIS
中间系统到中间系统，用于实现网络中的路由协议，控制数据包在网络中的传输路径，以提高网络的可靠性和稳定性。

#### RIP
路由信息协议，用于实现路由协议，控制数据包在网络中的传输路径，是一种基于距离向量算法的路由协议。

## TCP和UDP的区别

TCP是面对**连接的**传输层协议，提供可靠的数据传世。TCP用**检验和、标号、流量控制、拥塞控制、超时重传**等机制保证TCP连接是可靠的，UDP则不保证可靠交付，只保证尽力交付。TCP的数据传输以**字节流**的形式，UDP的数据传输是以**报文段**的形式

UDP是**无连接的**的传输协议，提供不可靠的数据传输，通过UDP数据报进行数据传世不能保证数据可靠性。但UDP穿的较快，适用于对实时性要求较高的场景

### TCP如何保证可靠性
**分段** 将报文段分成适合转发的长度

**标号** 按照序号判断中间的转发是否有缺失

**流量控制** 根据双方的接收发送能力，动态地调整发送方发送窗口的大小，取发送窗口=min(拥塞窗口，接收窗口) （与数据链路层收不下的话返回一个信号告诉发送方自己收不下的流量控制机制不同）

**检验和** TCP首部有检验和字段，目的是检验首部+数据部分的数据是否正确，是不是被人篡改或半路出现差错。

**超时重传** 发出报文段之后启动定时器，如果重传时间RTT内没有收到确认的话，就重传该数据报，也可以采用冗余确认机制（三次接收到同一个ack=k的确认序号，就重传第k个报文段）（快重传中采用的也是冗余重传）

主要涉及的协议有两种（跟数据链路层的超时重传机制相同）：

**停止等待协议** 每发送一个报文段就停止，直到收到确认才继续发送，否则超时重传
**滑动窗口协议**
后退N帧协议 GBN： 发送窗口>1，接收窗口=1，即接收方必须按照顺序去接收数据，如果启用了超时重传机制的话，就会重传所有当前已经发送但是没有被确认的报文段
选择重传协议 SR： 发送窗口>1，接收窗口>1，即接收方无需按照顺序去接收数据，会按照任意顺序接收所有处于接收窗口内的数据。按照如果启用超时重传机制的话只需要重新发送没有收到确认的数据即可。
**拥塞避免 分为两种：①慢开始，拥塞避免 ②快重传、快恢复**

**检验和**是TCP和UCP中都有的 要注意检验的是首部和数据字段的有效性

1.添上伪首部
2.首部检验和字段置为0
3.伪首部+首部+data部分用二进制反码求和，并将结果填入到检验和字段
4.去掉伪首部发送
5.发送方接受到该数据之后，首先添上伪首部
6.接着计算伪首部加首部加数据部分的二进制反码求和
7.如果全为1则无差错，去掉伪首部交给网络层，否则丢弃。

## TCP的三次握手和四次挥手

> 三次握手（用于建立连接） 1. 客户端->服务器发送一个SYN，请求建立连接 2. 服务器接收到SYN后向客户端发送SYN+ACK，同意建立连接 3. 客户端接收到服务器的SYN+ACK后，向服务器发送一个ACK表示确认收到服务器的SYN+ACK。连接建立

> 四次挥手（用于断开连接） 1.**客户端发送FIN报文给服务器端**，并进入到FIN-WAIT1阶段，该FIN报文包括首部字段控制位FIN=1，序列号seq=u，告诉服务器我已完成我的数据传输工作，你这边如果还有数据可以继续传送(**发送断开连接的请求**) 2. **服务器收到该FIN报文之后进入close-wait阶段，并返回一个ACK给客户端**，该确认报文包括首部控制位ACK=1，seq=v，ack=u+1。客户端收到该确认报文后进入fin-wait2状态，关闭从客户端到服务器端的数据传送。服务器端仍可向客户端传送数据。 3. **服务器接着发送一个FIN给客户端**,该报文结构包括FIN=1,ACK=1,序列号为w，确认号为u+1，并进入Last-ACK状态 4. **客户端接收到后发送一个ACK**,该确认报文包括首部控制位ACK=1，序列号为u+1，确认号为w+1，并进入time-wait阶段，等待2MSL后确认服务器端收到ACK报文正常断开连接后，客户端关闭。服务器端收到该确认报文，进入closed状态。 至此连接断开

**等待2MSL的原因** 确认服务器端是否正常收到了客户端最后发出的确认报文，如果服务器端没有收到的话，过1MSL（报文在网络中的最大存活时间）会重新再发送一次FIN报文给客户端，如果过了2MSL还没有收到新发的FIN报文的话，证明服务器端已经收到确认报文并正常关闭连接，客户端也可以关闭连接啦
### 为什么三次握手？为什么四次挥手？

**三次握手的原因**

**确保双方间的连接正常建立**，如果只有两次握手的话可能会出现一些异常情况，比如：①客户端的SYN连接请求失效(或者发去时间太久,导致了超时重传的发生)，但是服务器端接收到了该SYN报文，如果不经过第三次握手的话服务器端就会错误地开启一个连接；③如果只有两次握手地话，服务器端返回给客户端的确认报文丢失，会导致客户端因为没有收到确认所以关闭了该连接，但服务器端此时已做好了连接准备，造成资源的浪费

**四次挥手的原因**

因为建立连接时双方都处于closed状态，而释放连接时一方收到FIN报文但有**可能还有数据要继续传输**，不能马上释放连接，所以先返回一个确认报文，**发送完数据后再断开连接**

## SYN洪泛攻击如何解决？
**SYN洪范攻击**攻击者伪装成客户端发送TCP的SYN报文, 当服务器返回ACK确认报文之后, 攻击者不再进行确认, 即不回复确认的确认报文, 这个连接就处于一个挂起的状态, 服务器收不到确认报文的话, 会启用超时重传机制, 重复发送ACK给攻击者

这样的话,如果攻击者开启大量这种TCP连接, 导致服务器端有很多个挂起的连接, 并且需要重复发送很多ACK给攻击者, 这样就会消耗服务器的内存 可能导致最后服务器死机, 无法正常工作

解决方法

**降低SYN timeout时间** 使得服务器在没收到确认报文后尽快释放半连接的占用
**采用SYN cookie设置** 给每一个请求连接的ip地址分配一个cookie,短时间内如果连续收到某个IP的重复的SYN报文,就认定收到了攻击,以后会自动丢弃该ip地址传送过来的包

## TCP拥塞控制的原理

1. 慢开始，在开始传播数据时，TCP会以指数级别增加传输速率，直到发现网络拥塞
2. 拥塞避免：一旦发现网络拥塞，TCP会以线性级别的速度降低传输速率，以避免网络拥塞进一步加剧。
3. 快重传和快恢复：当发现数据包丢失时，TCP会进行快速重传，避免等待超时后再进行重传。

## TCP粘包和拆包

在传输过程中，出现**多个数据包合在一起**（粘包），或**一个数据包被拆分成多个数据包**（拆包）传输

粘包/拆包都可能导致数据传输的混乱，解决方案：
1. 定长包处理：将**数据按照固定长度**进行分割，每个数据包长度相同，接收方按照固定长度介绍数据，避免了粘包和拆包问题
2.分隔符处理：将数据包**按照特定的分隔符**进行分割，每个数据包的长度不同，**接收方**根据**分隔符来判断数据包的边界**，避免了粘包和拆包问题。
3. 增加**消息头**处理：在**每个数据包的头部**增加**一个固定长度的消息头**，用于描述**数据包的长度、类型等信息**，接收方根据消息头来接收数据，避免了粘包和拆包问题。

## HTTP和HTTPS的区别

HTTP：明文传输，不使用SSL/TLS协议加密。用于传输一些不敏感的信息

HTTPS：使用SSL/TLS加密传输，保证数据的安全性和可靠性

### HTTP中的长连接和短连接

长连接和短连接是指客户端和服务器之间TCP连接持续的师姐

- 短连接：每次请求和响应都会建立一个新的TCP连接，完成后客户端立即关闭连接，同时服务器也**立即**释放连接。短连接节省资源，但建立连接的开销较大，对于频繁请求会有较大的延迟，不适合长时间通信。

- 长连接：客户端和服务器建立一个TCP连接后，可以重复使用该链接进行多次请求和响应，直到客户端/服务器发送终止连接的请求/响应。长连接可以减少建立连接的开销和延迟，适合长时间通信，但会占用一定的资源和带宽。

在HTTP/1.1之前，HTTP协议默认使用短连接。在HTTP/1.1中，HTTP协议默认使用长连接，但客户端和服务器可以通过在请求头或响应头中添加"Connection: close"字段来关闭连接。

## http协议的发展历程（1.0 1.1 2.0 3.0）
**http1.0和http 1.1的主要区别是什么？**

1.**连接** HTTP1.0默认使用短连接，每次请求不同的资源都需要重新建立一次连接；HTTP1.1起默认使用长连接，默认开启keep-alive，即同一个TCP连接可以发送和接收多个http请求/响应，这种长连接由流水线方式和非流水线方式，流水线方式是指客户在收到http响应报文之前就能够接着发送新的请求报文，非流水线方式是指客户在收到http响应报文后才能接着发送下一个请求

2.**状态码** HTTP1.1新增24个状态码，409表示请求的资源与资源当前状态发生冲突，410Gone指的是服务器上某个资源被永久删除

3.**带宽优化及网络连接使用** ——http1.1支持断点续传，HTTP1.0中不支持只显示对象的一部分（只能显示全部）、且不支持断点续传功能，浪费带宽；HTTP1.1在请求头中引入了range头域，允许只请求资源的某个部分，返回码是206（partial content）

**http2.0的改进**

1.**头部压缩** 减少冗余头信息，用了首部表来跟踪、存储之前的键值对，相同的数据就无需再每次重复请求和响应了

2.**多路复用** 实现由一个tcp连接并发请求。http1.1多个请求的响应之间会被阻塞

3.**服务器推送**：可以主动将资源推送给客户端缓存中

4.**二进制格式**：采用二进制而非文本格式，将所有传输的信息分割为更小的消息和帧（二进制帧）

## DNS解析过程

域名解析：浏览器根据URL中的域名，向本地DNS服务器发送域名解析的请求
本地DNs解析：本地DNS服务器收到请求后，1.在DNS缓存中查找是否有对应的IP，若有，直接返回。 2. 若没有本地DNs服务器向互联网上的root 服务器发送请求
根DNS解析：根服务器收到请求后，转发给顶级域名服务器
顶级域名服务器解析：转发给对应的刺激域名服务器
次级域名服务器：收到请求后，在自己的DNS缓存中查找对应的IP，若有，返回；否则向下一级域名发送请求直到找到。

## 输入URL到显示网页发生了什么
**浏览器解析URL对应的IP地址**
​ DNS解析过程，浏览器缓存—>操作系统缓存—>本地DNS—>根据转发模式选择迭代还是递归查询

**浏览器向服务器发送一个HTTP请求报文**
​ 传输层上建立TCP连接，网络层用到了IP协议(负责在网络层传输数据），还会用到RIP或者OSPF进行路由选择，然后用ARP协议解析IP地址对应的MAC地址，使得数据能够在数据链路层上进行传输（不应该是最后到物理层传输吗）。

​ HTTP请求方法有哪些（post/get/head/put/delete）

**服务器请求处理并返回一个HTTP响应报文**
​ HTTP响应报文的结构，状态码

**服务器返回一个HTML响应，浏览器收到HTML响应并渲染界面**

## get和post的区别
注意存放在请求行和请求体的不是方法 而是请求/提交的数据啊喂 post和get方法都是在请求行中啦

1.get数据明文存放在http请求行的url之后，post则是将提交的数据放在http请求报文的请求体中

2.受浏览器对url长度的限制，get传送数据量应不超过2KB。post传送数据量则一般无此限制

3.get只接受acsii字符，post没有限制，get只支持url编码，post没有限制

4.get不能改变服务器的数据，一般用于从服务器获取数据，是幂等的；post可以改变服务器的数据，不是幂等的。

5.get请求可以被浏览器主动缓存，下一次若传输数据相同，则优先返回缓存中的内容，以加快显示速度。post请求不会，除非手动设置一下

6.get请求参数会被完整地保存在浏览器历史记录中，post请求参数则不会保留

## 常见状态码

**1xx 表示正在处理**

100 continue 一切正常 可以继续发送（据说是http报文中如果有post方法的话 会先把请求行发送过去，然后返回100，然后再发送请求头部和请求体给服务器端）
**2xx 成功 表示请求已经正常处理**

200 OK 一切正常返回数据
204 No content 请求正常处理，但是没有数据返回
206 指定范围返回（http1.1以上支持的断点续传功能相关）
**3xx 重定向 浏览器需要一些额外的操作才能完成请求**

301 永久性重定向
302 暂时性重定向（跟http劫持有关，运营商可以通过DNS劫持和http劫持两种，返回一个302，然后让用户跳转到处理好的携带广告的页面）
303 暂时性重定向 但是服务器端明确说明希望浏览器用get方法来请求资源
304 浏览器附带了请求的条件，服务器端允许访问，但是不满足请求条件
**4xx 客户端错误**

400 客户端的请求有语法错误
403 forbidden 客户端申请访问的资源被禁止访问
404 Not found 客户端申请访问的资源不存在
405 Method not allowed 客户端请求方法被禁止
**5xx 服务器端错误**

500 服务器在请求处理时内部出错
501 服务器不具备完成请求的功能，如无法识别请求方法
502 服务器作为网关或代理，从上游服务器获得无效响应
503 Bad Gateway 服务器处于停机维护/超负荷状态
504 Gateway timeout服务器作为网关或代理，没有及时从上游服务器获得响应

## cookie和session的区别
首先它们都是用于给无连接的http提供身份认证的功能

cookie是服务器在**本机**存放的小段文本，并随每一个请求发送至同一服务器。cookie分为**会话cookie**（不设置过期时间，关闭浏览器窗口cookie即失效，保存在内存中）和**持久cookie**（设置过期时间，关闭再打开浏览器cookie仍存在，直至达到过期时间）。类似于检查通行证（即请求报文中附带的cookie）来确定用户身份

session则一般是利用session id实现的（session id是浏览器第一次发送请求时服务器自动生成的唯一标识，并返回给浏览器），cookie中携带该session id，客户端根据该session id将session检索出来。类似于在**服务器**上建立一个客户档案，客户来访时需要查询客户档案

1.cookie是存放在客户端，用于记录用户信息的，比如自动填充用户名和密码；session是存放在服务器端的，用于记录用户的状态，比如购物车的实现。

2.cookie不太安全，可以分析存放在本地的cookie进行cookie欺骗，（也可以用加密算法加密后进行存放），session存放于服务器的内存中，所以安全性高

3.单个cookie保存数据不能超过4k，session没有对存储数据量的限制

禁掉cookie的话session仍然可以使用，但是需要使用其他方法获取session id，比如在url后面或者以表单的形式提交给服务器端

## 子网掩码

子网掩码适用于指定IP地址的网络部分和主机部分组成
子网掩码也由32位二进制数表示，它的作用是将IP地址分为网络部分和主机部分，**用于确定网络中的设备是否属于同一子网**。通常，子网掩码与IP地址一起使用，可以将一个大的IP地址空间划分为多个子网，从而更有效地管理网络中的设备。

例如，假设一个公司拥有一个IP地址段为192.168.1.0/24的网络。这个IP地址段中包含的IP地址范围为192.168.1.1~192.168.1.254，其中，/24表示子网掩码为255.255.255.0。这个IP地址段中的每个IP地址的前三个数（即192.168.1）都是网络部分，最后一个数则是主机部分。子网掩码中为1的位表示网络部分，为0的位表示主机部分。在这个例子中，子网掩码中前24位都是1，表示网络部分，后8位都是0，表示主机部分。这样，我们可以将这个IP地址段划分为256个子网，每个子网最多包含254个IP地址。
 
## 负载均衡

负载均衡是一种常用的网络技术，用于**将网络流量分配到多个服务器**上，以实现更高的性能。
负载均衡的实际应用非常广泛，包括以下几个方面：

网站和应用服务器的负载均衡：负载均衡可以将网络流量分配到多个Web服务器和应用服务器上，以提高网站和应用程序的性能、可靠性和可扩展性。
数据库服务器的负载均衡：负载均衡可以将数据库流量分配到多个数据库服务器上，以提高数据库的性能、可靠性和可扩展性。
文件服务器的负载均衡：负载均衡可以将文件流量分配到多个文件服务器上，以提高文件共享的性能和可靠性。
DNS服务器的负载均衡：负载均衡可以将DNS查询流量分配到多个DNS服务器上，以提高DNS服务的性能和可靠性。

## 防火墙是什么
防火墙是指一种网络安全设备，用于对网络流量进行监控和过滤，保护网络免受恶意攻击和威胁。防火墙可以通过过滤规则来控制网络流量的进出，对恶意流量进行拦截和阻止，从而保护网络的安全性和稳定性。

## IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址
MAC地址是网络中**每个设备都有的唯一网络标识**，全世界唯一。

IP地址只是**逻辑上**的标识，任何人都能随意修改，因此不能具体标识一个用户，但MAC地址固化在网卡里，防止被盗用。

但是如果只用MAC地址的话，因为MAC地址无序杂乱，没有明显规则，难以查找。但是IP是分层的，类似通讯地址，可以根据其网络号找到子网再定义主机，逐级查找，每个设备需要存储的信息较少

MAC地址与IP地址的区别：

①**长度不同**，IP地址一般为32位（IPv6 128位），MAC地址则是48位

②**分配依据不同**，IP地址分配基于网络拓扑，能够根据需要改动设备的IP地址，但是MAC地址的分配是基于制造商，在网卡中烧录好，一般不轻易改变

③**寻址协议层不同**，IP地址应用于**网络层**，MAC地址应用于**数据链路层**（数据链路层基于MAC地址转发数据帧，数据链路层的交换机根据其MAC地址记录表中的MAC地址及其对应的端口，将其发送到MAC地址对应的端口，否则广播；网络层则根据IP地址转发报文，路由器根据路由表转发到对应端口，否则发送默认路由）

## ARP协议
作用：**实现IP地址到MAC地址的映射**（由IP地址获得MAC地址）

流程：根据主机A路由表的内容查找B的IP地址，再从A的ARP高速缓存中寻找是否有B的MAC地址，如果没有则广播ARP请求帧（构成为Aip+Bip+A_MAC+全1）至该局域网内所有的主机。如果主机发现该请求帧中的IP地址与自己的相同则返回一个单播ARP帧（构成为Bip+B_MAC)返回给主机A，并且AB均更新自己的ARP高速缓存。

## 客户端故障检测方法？
客户端故障检测方法----**保活计时器**

目的:在长连接的情况下,检测没有响应的连接并且将其断开(即客户端出现了故障), 防止占用过多的连接资源

客户端打开服务器的连接传送数据后,就保持沉默了,此时有可能客户端出了故障.

解决方法就是使用保活计时器, 每当服务器收到客户端的信息的话,该计时器就复位, 如果两个小时之内还没有收到客户信息,就发送探测报文段,如果发送了10个探测报文段还没有响应的话, 就认为客户端出了故障,终止该连接