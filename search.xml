<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络复习</title>
      <link href="/2022/09/13/ji-suan-ji-wang-luo-fu-xi/"/>
      <url>/2022/09/13/ji-suan-ji-wang-luo-fu-xi/</url>
      
        <content type="html"><![CDATA[<p>什么是网络</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习学习笔记1</title>
      <link href="/2022/08/31/qiang-hua-xue-xi-xue-xi-bi-ji-1/"/>
      <url>/2022/08/31/qiang-hua-xue-xi-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p><strong>强化学习（reinforcement learning)是在与环境的互动中为了达成一个目标而进行的学习</strong><br>强化学习基本元素 <strong>Agent</strong>，<strong>Environment</strong>,<strong>goal</strong><br>强化学习主要元素 <strong>state</strong>,<strong>action</strong>,<strong>reward</strong><br>强化学习核心元素 <strong>policy</strong>,<strong>value</strong><br>强化学习学习的是一个好的价值函数，而一个好的价值函数决定了一个好的策略 </p><p><strong>试错</strong>与<strong>延时奖励</strong>是强化学习中主要特点。</p><p>价值是将来能够获得的所有奖励之和的期望值。</p><p>由于随机性，不能一直做贪婪选择。可以再大多数情况下做出贪婪的选择，再一定几率下做出随机的选择。 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路4-HQL的应用1-建表与show语句</title>
      <link href="/2022/08/22/hive-xue-xi-zhi-lu-4-hql-de-ying-yong-1-jian-biao-yu-show-yu-ju/"/>
      <url>/2022/08/22/hive-xue-xi-zhi-lu-4-hql-de-ying-yong-1-jian-biao-yu-show-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>SQL中DDL(Data Defeinition Language)语言，主要是Create，ALter，DROP。DDL并不涉及表内部操作。</p><h2 id="Hive中的数据库"><a href="#Hive中的数据库" class="headerlink" title="Hive中的数据库"></a>Hive中的数据库</h2><p>在默认情况下，Hive的默认数据库default ,位于HDFS的/user/hive/warehouse目录下<br>用户自己创建的数据库位于/user/hive/warehouse/databse_name.db下</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>create databse用于创建新的数据库<br>COMMENT: 数据库的注释说明语句<br>LOCATION: 指定数据库再HDFS存储位置，默认为/user/hive/warehouse/dbname.db<br>With DBPROPERTIES: 用于指定一些数据库的属性配置</p><pre class=" language-SQL"><code class="language-SQL">CREATE (DATABASE|SCHEMA)[IF NOT EXISTS]database_name[COMMENT database_comment][LOCATION hdfs_path][WITH DBPROPERTIES(property_name=property_value,...)];</code></pre><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>use database 进行切换</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>要求数据库下没有标，为空时才可以删除</p><pre class=" language-SQL"><code class="language-SQL">DROP (DATABSE|SCHEMA)[IF EXSITS]database_name;</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>同理SQL</p><p>[可选内容]</p><pre class=" language-SQL"><code class="language-SQL">CREATE TABLE[IF NOT EXSITS][db_name.]table_name(col_name datatype [COMMENT col_comment],...)[COMMENT table_comment][ROW FORMAT DELIMITED...];</code></pre><p>最低限度</p><pre class=" language-SQL"><code class="language-SQL">CREATE TABLE table_name (col_name datatype,...);</code></pre><p>例</p><pre class=" language-SQL"><code class="language-SQL">create table test.t_archar(    id int comment "ID编号",    name string,    hp_max int,    mp_max int,    attack_max int,    defense_max int,    attack_range string,    role_main string,    role_assist string)row format delimitedfields terminated by "\t";</code></pre><h3 id="show语法"><a href="#show语法" class="headerlink" title="show语法"></a>show语法</h3><p>用于查看schemas，tables和databases</p><p>show tables;<br>show databases;<br>show schemas;<br>show tables in database1; // 此处表示展示database1中的表<br>show tables in schema1; // 此处表示展示schema1中的表</p><p>查看元数据类型<br>desc formatted table1;</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路3-Hive客户端的使用</title>
      <link href="/2022/08/21/hive-xue-xi-zhi-lu-3-hive-ke-hu-duan-de-shi-yong/"/>
      <url>/2022/08/21/hive-xue-xi-zhi-lu-3-hive-ke-hu-duan-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>推荐使用第二代客户端$HIVE_Home/bin/beeline，是一个JDBC客户端<br>官方强烈推荐的Hive命令行工具，和第一代客户端相比，性能安全性提高</p><p><img src="/img/posts/DataRepos/hive%E5%AE%A2%E6%88%B7%E7%AB%AF1&amp;2.jpg" alt="Hive客户端与服务的关系"><br>图源：<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=62&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">https://www.bilibili.com/video/BV1CU4y1N7Sh?p=62&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad</a></p><h2 id="HiveServer2服务"><a href="#HiveServer2服务" class="headerlink" title="HiveServer2服务"></a>HiveServer2服务</h2><p>在远程模式下，启动HiveServer2必须先启动mtastore服务<br>Beeline客户端只能通过HiveServer2服务访问Hive问bin/hive是通过一代服务(metastore)访问的</p><pre class=" language-shell"><code class="language-shell">nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service metastore &nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service hiveserver2 &</code></pre><h3 id="其他机器连接一代客户端-metastore"><a href="#其他机器连接一代客户端-metastore" class="headerlink" title="其他机器连接一代客户端(metastore)"></a>其他机器连接一代客户端(metastore)</h3><p>将客户端拷贝到其他机器上，此处以node3为例</p><pre class=" language-shell"><code class="language-shell">scp -r /export/server/apache-hive-3.1.2-bin root@node3:/export/server/</code></pre><p>再在node3的finalshell中输入</p><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive</code></pre><p>但此时连接的是metastore， 是第一代客户端<br>进入hive&gt;<br>可以用show dtabases; show tables;分别查看数据库和表</p><p>ctrl+c退出hive</p><h3 id="其他机器连接二代客户端-HiveServer2"><a href="#其他机器连接二代客户端-HiveServer2" class="headerlink" title="其他机器连接二代客户端(HiveServer2)"></a>其他机器连接二代客户端(HiveServer2)</h3><p>将beeline客户端连接到hive服务器</p><p>在node3的finalshell中输入</p><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/beeline</code></pre><ul><li><p>进入beeline</p></li><li><p>输入 beeline&gt; ! connect jdbc:hive2://node1:10000<br>  连接到hive服务<br>  输入用户名：root<br>  密码直接回车</p></li><li><p>连接成功<br>  可以直接输入 show databases;<br>          show tables;<br>  进行基本查询</p></li></ul><h2 id="Hive可视化客户端"><a href="#Hive可视化客户端" class="headerlink" title="Hive可视化客户端"></a>Hive可视化客户端</h2><p><strong>DataGrip</strong>,Dbeaver, Squirrel SQL client等</p><h3 id="DataGrip的使用"><a href="#DataGrip的使用" class="headerlink" title="DataGrip的使用"></a>DataGrip的使用</h3><ul><li><p>创建项目</p></li><li><p>attach directory to project<br>  这样之后写的sql文件都存在这个目录下</p></li><li><p>关联数据库<br>  选择右边栏database-&gt; 点击+号 -&gt; data source -&gt; Apache Hive</p><p>  点开后，左边选择栏再选择Hive，配置Hive启动jar，配置好后，点击上方localhost，更改host为node1，user名为root，之后测试connection，，显示ok后，点击apply</p></li></ul><h3 id="测试是否连接成功"><a href="#测试是否连接成功" class="headerlink" title="测试是否连接成功"></a>测试是否连接成功</h3><ul><li><p>在node1机器的finalshell中输入jps<br>runjar在运行</p></li><li><p>在datagrip中右侧的hive连接，此处是node1_hive，点击后按住（Fn+f4)或直接(f4)，进入命令行输入模式，输入show databases;选中后点击左上方绿色按钮进行运行。</p></li></ul><p>成功后和说明环境配置成功。</p><h3 id="正式写sql文件"><a href="#正式写sql文件" class="headerlink" title="正式写sql文件"></a>正式写sql文件</h3><p>将结构化语句映射到表中</p><ul><li><p>新建文件“1.create_table.sql”</p></li><li><p>写建表语句</p></li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> test<span class="token punctuation">.</span>t_archar<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name string<span class="token punctuation">,</span>    hp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    mp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_max <span class="token keyword">int</span><span class="token punctuation">,</span>    defense_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_range string<span class="token punctuation">,</span>    role_main string<span class="token punctuation">,</span>    role_assist string<span class="token punctuation">)</span></code></pre><ul><li>指定字段之间的分隔符</li></ul><p>若不用分隔符，只有create table，会采用默认分隔符’\001’<br>\001是打不出来的，在vim编辑器的输入模式下是^A<br>用空格(\t)表示分隔符</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">row</span> format delimited<span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">"\t"</span></code></pre><p>完整语句</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> test<span class="token punctuation">.</span>t_archar<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name string<span class="token punctuation">,</span>    hp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    mp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_max <span class="token keyword">int</span><span class="token punctuation">,</span>    defense_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_range string<span class="token punctuation">,</span>    role_main string<span class="token punctuation">,</span>    role_assist string<span class="token punctuation">)</span><span class="token keyword">row</span> format delimited<span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">"\t"</span><span class="token punctuation">;</span></code></pre><ul><li>切换到对应的schema</li></ul><p><img src="/img/posts/DataRepos/Datagrip_switchSchema.jpg" alt="切换"></p><h3 id="上传原数据"><a href="#上传原数据" class="headerlink" title="上传原数据"></a>上传原数据</h3><ol><li>暴力上传</li></ol><p>进入node1:9870， browse file-&gt; user-&gt;hive -&gt;warehouse -&gt;test.db -&gt;upload</p><p>之后进入datagrip用select 语句进行查看</p><ol start="2"><li>通过将本地文件再finalshell中</li></ol><pre class=" language-shell"><code class="language-shell">hadoop fs -put 1.txt /user/hive/warehouse/test.db/t_1/</code></pre><p>此处是将1.txt的淑君放到test数据库下的t_1表中</p><p>然后再beeline/datagrip中用select语句可以查看</p><ol start="3"><li>用load加载（推荐）<br>load命令是一个纯复制纯移动的树，hive不会对数据做任何形式的改变<br>语句格式如下</li></ol><pre class=" language-SQL"><code class="language-SQL">LOAD DATA[LOCAL] INOATH 'filepath' [OVERWRITE] INTO TABLE tablename;</code></pre><ul><li>Local的本地–如果是对Hiveserver2服务器所在的机器使用此命令，local本地文件系统指的是Hiveserver2服务所在机器的本地linux文件系统，而非Hive客户端所在的本地文件系统。<br>也就是node1上的本地文件系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路2--安装部署</title>
      <link href="/2022/08/19/hive-xue-xi-zhi-lu-2-an-zhuang-bu-shu/"/>
      <url>/2022/08/19/hive-xue-xi-zhi-lu-2-an-zhuang-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=60&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">https://www.bilibili.com/video/BV1CU4y1N7Sh?p=60&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad</a> </p><p>在Linux环境下，保证Hadoop集群健康可用<br>在启动Hive之前必须先启动Hadoop集群，<strong>需等待HDFS安全模式关闭之后再运行Hive</strong></p><pre class=" language-shell"><code class="language-shell">start-dfs.shstart-yarn.sh</code></pre><p>Hive不是分布式安装运行的软件，其分布式特效主要借助于Hadoop完成，包括分布式存储，分布式计算</p><h2 id="Hadoop与Hive"><a href="#Hadoop与Hive" class="headerlink" title="Hadoop与Hive"></a>Hadoop与Hive</h2><p>需要在Hadoop中添加相关配置属性，以满足Hive在Hadoop上运行<br>修改Hadoop中core-site.xml,并且Hadoop集群同步配置文件重启生效</p><!--整合Hive代理设置 --><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.proxyuser.root.hosts<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.proxyuser.root.groups<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><ol><li>卸载Centos7自带的mariadb</li></ol><pre class=" language-shell"><code class="language-shell">rpm -qa|grep mariadb# 结果mariadb-libs-5.5.64-1.el7.x86_64rpm -e mariadb-libs-5.5.64-1.el7.x86_64 --nodeps# 进行删除rpm -qa|grep mariadb                            # 再次查询，无结果</code></pre><ol start="2"><li>安装mysql</li></ol><pre class=" language-shell"><code class="language-shell"># 创建目录mkdir /export/software/mysql# 选择finalShell，找到/export。software/mysql 拖拽文件上传mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar#到上述文件夹下  解压tar xvf mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar#执行安装依赖yum -y install libaio# 进行mysql的安装rpm -ivh mysql-community-common-5.7.29-1.el7.x86_64.rpm    mysql-community-libs-5.7.29-1.el7.x86_64.rpm    mysql-community-client-5.7.29-1.el7.x86_64.rpm      mysql-community-server-5.7.29-1.el7.x86_64.rpm warning: mysql-community-common-5.7.29-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:mysql-community-common-5.7.29-1.e################################# [ 25%]   2:mysql-community-libs-5.7.29-1.el7################################# [ 50%]   3:mysql-community-client-5.7.29-1.e################################# [ 75%]   4:mysql-community-server-5.7.29-1.e################                  ( 49%)</code></pre><ol start="3"><li>mysql初始化设置</li></ol><pre class=" language-shell"><code class="language-shell">#初始化mysqld --initialize#更改所属组chown mysql:mysql /var/lib/mysql -R#启动mysqlsystemctl start mysqld.service#查看生成的临时root密码cat  /var/log/mysqld.log[Note] A temporary password is generated for root@localhost: o+TU+KDOm004</code></pre><ol start="4"><li>修改root密码 授权远程访问 设置开机自启动</li></ol><pre class=" language-shell"><code class="language-shell"># 登录mysqlmysql -u root -p# Enter password:     #这里输入在日志中生成的临时密码# Welcome to the MySQL monitor.  Commands end with ; or \g.# Your MySQL connection id is 3# Server version: 5.7.29Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql> #更新root密码  设置为hadoopmysql> alter user user() identified by "hadoop";Query OK, 0 rows affected (0.00 sec)#授权mysql> use mysql;mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'hadoop' WITH GRANT OPTION;mysql> FLUSH PRIVILEGES; # ctrl+D 结束 退出mysql#mysql的启动和关闭 状态查看 （这几个命令必须记住）systemctl stop mysqldsystemctl status mysqldsystemctl start mysqld#建议设置为开机自启动服务systemctl enable  mysqld    #Created symlink from /etc/systemd/system/multi-user.target.wants/mysqld.service to /usr/lib/systemd/system/mysqld.service.#查看是否已经设置自启动成功systemctl list-unit-files | grep mysqld# mysqld.service enabled </code></pre><h2 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h2><ul><li><p>上传安装包 解压</p><pre class=" language-shell"><code class="language-shell">tar zxvf apache-hive-3.1.2-bin.tar.gz</code></pre></li><li><p>解决Hive与Hadoop之间guava版本差异</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.3.0/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</code></pre></li><li><p>修改配置文件</p><ul><li><p>hive-env.sh</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/confmv hive-env.sh.template hive-env.shvim hive-env.sh## 大G小o 跳转到最后一行export HADOOP_HOME=/export/server/hadoop-3.3.0export HIVE_CONF_DIR=/export/server/apache-hive-3.1.2-bin/confexport HIVE_AUX_JARS_PATH=/export/server/apache-hive-3.1.2-bin/lib# Esc(退出输入模式)+shift+zz 快速保存</code></pre></li></ul></li><li><p>hive-site.xml</p><pre class=" language-shell"><code class="language-shell">vim hive-site.xml</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 存储元数据mysql相关配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionURL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>jdbc:mysql://node1:3306/hive3?createDatabaseIfNotExist=true<span class="token entity" title="&amp;">&amp;amp;</span>useSSL=false<span class="token entity" title="&amp;">&amp;amp;</span>useUnicode=true<span class="token entity" title="&amp;">&amp;amp;</span>characterEncoding=UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionDriverName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>com.mysql.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionUserName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionPassword<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- H2S运行绑定host --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.server2.thrift.bind.host<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>node1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 远程模式部署metastore metastore地址 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.metastore.uris<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>thrift://node1:9083<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 关闭元数据存储授权  --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.metastore.event.db.notification.api.auth<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre></li><li><p>上传mysql jdbc驱动到hive安装包lib下</p><pre class=" language-shell"><code class="language-shell">mysql-connector-java-5.1.32.jar</code></pre></li><li><p>初始化元数据</p></li></ul><p>检验安装是否正确</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/bin/schematool -initSchema -dbType mysql -verbos#初始化成功会在mysql中创建74张表</code></pre><ul><li><p>在hdfs创建hive存储目录（如存在则不用操作）</p><pre class=" language-shell"><code class="language-shell">hadoop fs -mkdir /tmphadoop fs -mkdir -p /user/hive/warehousehadoop fs -chmod g+w /tmphadoop fs -chmod g+w /user/hive/warehouse</code></pre><h2 id="metastore启动"><a href="#metastore启动" class="headerlink" title="metastore启动"></a>metastore启动</h2><h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><p>进程会一直占据终端，ctrl+c结束进程</p><ul><li>启动前台</li></ul><pre class=" language-shell"><code class="language-shell">/export/server/appache-hive-3.1.2-bin/bin/hive --service metastore</code></pre><ul><li>前台启动开启debug日志</li></ul><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive --service metastore --hiveconf hive.root.logger=DEBUG,console </code></pre><h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><ul><li>把程序当成一个进程</li></ul><pre class=" language-shell"><code class="language-shell">nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service metastore &</code></pre><p>回车后再按一次回车，就成功启动在后台了</p><p>之后通过jps 查看进程</p><p>使用kill -9杀死进程</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路1--基本概念</title>
      <link href="/2022/08/19/hive-xue-xi-zhi-lu-1-ji-ben-gai-nian/"/>
      <url>/2022/08/19/hive-xue-xi-zhi-lu-1-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive的优点"><a href="#Hive的优点" class="headerlink" title="Hive的优点"></a>Hive的优点</h2><p>1.接口操作采用类SQL语法，提供快速开发的能力，简单且容易上手<br>2.擅长存储分析海量数据，与Hadoop相似<br>3.避免直接写MapReduce，减少开发人员学习成本</p><p>Hive利用HDFS存储数据，利用MapResuce查询分析数据</p><h2 id="Hive功能的实现"><a href="#Hive功能的实现" class="headerlink" title="Hive功能的实现"></a>Hive功能的实现</h2><ol><li><p>Hive能将结构化文件映射成一张表，Hive并不承担存储数据功能，存储数据是由HDFS实现(将元数据信息描述清楚，转化成一个表)</p></li><li><p>用户写完sql后，Hive对sql进行校验，并且更具元数据信息解读sql背后的含义，最后将执行计划转换成MApReduce程序来具体执行</p></li></ol><p>有点类JDBC？<br>Hive是基于Hadoop的数仓工具 <img src="/%5Cimg%5Cposts%5CDataRepos%5CHive1.jpg" alt="Hive工作原理"></p><h2 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h2><p><img src="/%5Cimg%5Cposts%5CDataRepos%5CHive2.jpg" alt="Hive架构"></p><p>用户接口：包括CLI。JDBC/ODBC，WebGUI</p><p>元数据(metadata)存储 mysql/derby Hive中的元数据(描述数据的数据)包括表明，列的分区及属性，表的属性（是否为外部表等），表的数据所在的目录等</p><p>Driver驱动程序：包括语法解析器，计划编译器，优化器，执行器</p><p>执行引擎：MapReduce/Tez/Spark，Hive并不直接处理数据，而是通过执行引擎处理数据</p><p>Hadoop Yarn</p><p>HDFS/HBase</p><h2 id="Hive与元数据"><a href="#Hive与元数据" class="headerlink" title="Hive与元数据"></a>Hive与元数据</h2><p>Hive的安装模式与元数据服务(metastore)有关</p><p>metasore服务器配置有三种模式内嵌模式、本地模式、<strong>远程模式</strong></p><p><img src="/%5Cimg%5Cposts%5CDataRepos%5CHive3.jpg" alt="metastore"></p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓基本概念</title>
      <link href="/2022/08/19/shu-cang-ji-ben-gai-nian/"/>
      <url>/2022/08/19/shu-cang-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>数据仓库是构建面向分析的集成化数据环境，是一个用于存储、<strong>分析</strong>、报告的环境</p><h2 id="联机事务处理系统-OLTP"><a href="#联机事务处理系统-OLTP" class="headerlink" title="联机事务处理系统(OLTP)"></a>联机事务处理系统(OLTP)</h2><p>特征：前台接收的用户数据可以立即传送到后台进行处理，并在很短的时间内给出处理结果<br>关系型数据库是典型的OLTP应用，如MySQL，Oracle</p><p>数据库可以开展分析，但没必要。数据库一般读取压力明显大于写入的压力，如果直接再OLTP进行各种分析，会导致数据库读取压力倍增。</p><p><img src="/img/posts/DataRepos/01.jpg" alt="数仓例子"></p><h2 id="数仓主要特征"><a href="#数仓主要特征" class="headerlink" title="数仓主要特征"></a>数仓主要特征</h2><h3 id="Subject-Oriented"><a href="#Subject-Oriented" class="headerlink" title="Subject-Oriented"></a>Subject-Oriented</h3><p>主题是一个抽象概念，是较高层次上的<strong>数据综合</strong>、归类、并进行分析利用的抽象。再抽象层次上对数据进行完整、一致和准确的描述</p><h3 id="Non-Volatile"><a href="#Non-Volatile" class="headerlink" title="Non-Volatile"></a>Non-Volatile</h3><p>非易变性。数仓是分析数据的平台，而不是创造数据的平台。<br>书擦干的数据反应的是一段长时间内的历史数据的内容<br>数仓一般有<strong>大量的查询</strong>操作，但修改和删除很少</p><h3 id="Integrated"><a href="#Integrated" class="headerlink" title="Integrated"></a>Integrated</h3><p>主题相关的数据通常会分布在多个操作系统中，彼此分散、独立、异构。需要集成到数仓主题之下。</p><p>要统一源数据中的矛盾：包括字段的同名异义、单位不同、格式不同等</p><p>ETL：抽取、转换、加载</p><h3 id="Time-Variant"><a href="#Time-Variant" class="headerlink" title="Time-Variant"></a>Time-Variant</h3><p>时变性。数仓的数据需要随着时间更新，以适应决策的需要。</p><h2 id="数仓主流语言-SQL"><a href="#数仓主流语言-SQL" class="headerlink" title="数仓主流语言-SQL"></a>数仓主流语言-SQL</h2><p>结构化数据（行与列）–二维表结构来逻辑表达和实现的数据，严格遵循数据格式和长度规范</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop中Yarn的概述</title>
      <link href="/2022/08/19/hadoop-zhong-yarn-de-gai-shu/"/>
      <url>/2022/08/19/hadoop-zhong-yarn-de-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>学习参考<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=49&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">Hadoop入门</a></p><h2 id="Yarn的简介"><a href="#Yarn的简介" class="headerlink" title="Yarn的简介"></a>Yarn的简介</h2><p>Hdfsd大数据存储系统中的资源管理器主要为MapReduce与Yarn，是一个通用的<strong>资源管理系统</strong>和<strong>调度</strong>平台，可为上层应用提供统一的资源管理和调度，为集群再利用率，资源统一管理和数据共享等方面带来了巨大好处</p><p><strong>资源管理系统</strong>: 管理集群的硬件资源，包括内存，CPU等<br><strong>调度平台</strong>： 多个程序同时申请资源，如何进行合理的分配与调度<br>Yarn作为一个通用平台，说明它不仅仅支持MR（MapReuce）程序，理论上支持各种计算程序（Spark，HBase，Storm…）</p><p>可以把Yarn理解为一个分布式的操作系统平台，HDFS是应用最广泛的大数存储系统，Yarn功不可没</p><h2 id="Yarn中的组件"><a href="#Yarn中的组件" class="headerlink" title="Yarn中的组件"></a>Yarn中的组件</h2><p>主要是三大组件</p><p>集群物理层面：   ResourceManager<br>                NodeManager<br>APP层面：       ApplicationMaster</p><h3 id="ResourceManager-RM"><a href="#ResourceManager-RM" class="headerlink" title="ResourceManager(RM)"></a>ResourceManager(RM)</h3><p>Yarn集群中的著角色，决定系统中所有应用程序之间的资源分配器的<strong>最终</strong>权限，接收用户的作业提交，并通过NM分配，管理机器上的计算资源</p><h3 id="NodeManager-NM"><a href="#NodeManager-NM" class="headerlink" title="NodeManager(NM)"></a>NodeManager(NM)</h3><p>Yarn中的从角色，一个机器上一个，负责管理本机器上的计算资源使用情况<br>根据RM命令，启动Container容器，监视容器的资源使用情况，并且向RM著角色汇报资源使用情况</p><h3 id="ApplicationMaster-AM"><a href="#ApplicationMaster-AM" class="headerlink" title="ApplicationMaster(AM)"></a>ApplicationMaster(AM)</h3><p>用户提交的每个应用程序均包含一个AM<br>应用程序中的“老大”，负责程序内部个资源的申请，监督程序的执行情况<br>AM程序是应用程序内部启动的第一个程序</p><h2 id="Yarn程序提交流程"><a href="#Yarn程序提交流程" class="headerlink" title="Yarn程序提交流程"></a>Yarn程序提交流程</h2><p>核心交互流程主要有四步：<br>MR作业提交  Client -&gt; RM<br>资源的申请  MRAppMaster -&gt; RM<br>MR作业状态汇报 Container(Map | Reduce Task) -&gt; Container (MRAppMaster)<br>节点的状态汇报(Yarn集群内布)  NM -&gt;RM </p><h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>当用户向YARN中提交一个应用程序后，YARN将分为了两个阶段运行该应用程序<br>第一个阶段：客户端申请资源启动运行被刺程序的AppMaster<br>第二个阶段有AppMaster更具本次程序内部具体具体情况为她申请资源，并健康它的整个运行过程，知道运行完成</p><p><img src="/img/posts/Yarn/Yarn%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.jpg" alt="Yarn程序提交流程"></p><p>第一步:用户通过客户端向Yarn中的ResourceManager提交应用程序（如Hadoop，jar提交MR程序）</p><p>第二步：RM为该应用程序分配第一个container，并于对应的NM同学，要求它再这个container中启动该应用的AM</p><p>第三步：AM启动成功后，向RM注册并保持同学，这样用户可以直接通过RM查看应用程序的运行状态</p><p>第四步：AM为本次程序内部的各个Task向RM申请资源</p><p>第五步：一旦<strong>AM</strong>申请到资源，便于对应的NM通信，要求他启动任务</p><p>第六版：NM为任务设置好运行环境之后，将任务启动命令写入到一个脚本之中，并通过运行该脚本启动任务</p><p>第七步：各个人物通过某个<a href="https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE/5019569?fr=aladdin">RPC协议</a>向AM汇报自己的状态和进度，以让AM随时掌握各个人物的运行状态，可以再任务失败时重新启动任务。<br>在应用程序运行过沉重，用户可随时通过RPC向AM查询应用程序当前运行状态</p><p>第八步：应用程序运行完成后，AM向RM注销并关闭自己</p><h2 id="Yarn的资源调度器Scheduler"><a href="#Yarn的资源调度器Scheduler" class="headerlink" title="Yarn的资源调度器Scheduler"></a>Yarn的资源调度器Scheduler</h2><p>在Yarn中，负责给应用分配资源的是schduler，是RM的内部核心组件之一。Schduler完全用于调度作业，无法跟踪应用程序的状态。Yarn提供了多种调度器和可配置的策略供选择，可在yarn-sit.xml中的yarn.resourcemanager.schduler.class进行配置</p><h3 id="FIFO-Schduler"><a href="#FIFO-Schduler" class="headerlink" title="FIFO Schduler"></a>FIFO Schduler</h3><p>先入先出，拥有一个控制全局的队列Queue<br>不适合共享集群</p><h3 id="Capacity-Scheduler"><a href="#Capacity-Scheduler" class="headerlink" title="Capacity Scheduler"></a>Capacity Scheduler</h3><p>Apache版本一般默认Capacity Scheduler<br><strong>允许多个组织共享集群资源</strong>，每个组织都可以获得一部分集群计算能力。通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源，整个集群可以通过设置多个队列给多个组织提供服务。</p><p>Capacity 可以理解为一个个的资源队列，这个资源队列是用户自行分配。<br>再在队列内部进行垂直划分，使得一个组织内部分多个成员共享这个队列资源。<br><strong>在一个队列内部，资源调度是FIFO的</strong></p><p><img src="/img/posts/Yarn/Scheduler_task_div.jpg" alt="文件划分"></p><h3 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h3><p>提供了yarn应用程序中共享大型资源的方式</p><hr><p>例如：<br>用户A、B都有自己的队列 -&gt; A启动一个作业，而B还没有，此时A分配了集群中所有可用的资源 -&gt; B在A仍在运行时启动了一个作业，一段时间后，A、B各自作业都使用了一半的资源 -&gt; 若B此时再开启第二个作业，它将于B的另一个作业共享资源。A的一个作业仍占有1/2的资源，而B的两个作业各自占有1/4的资源</p><hr><p>Fair Scheduler支持资源抢占、基于用户的映射</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode部分汇总</title>
      <link href="/2022/08/02/leetcode-bu-fen-hui-zong/"/>
      <url>/2022/08/02/leetcode-bu-fen-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><hr><h2 id="96-不同的二叉搜索树-DP"><a href="#96-不同的二叉搜索树-DP" class="headerlink" title="96. 不同的二叉搜索树:DP"></a>96. 不同的二叉搜索树:DP</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP、卡特兰公式</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                 dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="95-不同的二叉搜索树2-DFS"><a href="#95-不同的二叉搜索树2-DFS" class="headerlink" title="95.不同的二叉搜索树2:DFS"></a>95.不同的二叉搜索树2:DFS</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br>（不只返回数字）</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>DFS</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h2 id="516-最长回文子序列-DP"><a href="#516-最长回文子序列-DP" class="headerlink" title="516. 最长回文子序列:DP"></a>516. 最长回文子序列:DP</h2><p>给定一个字符串s，找到其中最长的回文子序列（的长度）。<br>注意：子序列可以不连续的，可以跳过某些单词，子串是必须连续的</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>DP</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"></code></pre><h2 id="714-买卖股票的最佳时机含手续费-DP"><a href="#714-买卖股票的最佳时机含手续费-DP" class="headerlink" title="714. 买卖股票的最佳时机含手续费:DP"></a>714. 买卖股票的最佳时机含手续费:DP</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">,</span> <span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hold <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cash <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cash<span class="token punctuation">,</span> hold <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee<span class="token punctuation">)</span><span class="token punctuation">;</span>            hold <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">,</span> cash <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cash<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="139-单词拆分-DP-x2F-BST"><a href="#139-单词拆分-DP-x2F-BST" class="headerlink" title="139. 单词拆分:DP/BST"></a>139. 单词拆分:DP/BST</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><pre class=" language-java"><code class="language-java">Javapublic <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="516-最长回文子序列-DP-1"><a href="#516-最长回文子序列-DP-1" class="headerlink" title="516. 最长回文子序列:DP"></a>516. 最长回文子序列:DP</h2><h3 id="DP-步骤版"><a href="#DP-步骤版" class="headerlink" title="DP 步骤版"></a>DP 步骤版</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq2nd</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="300-最长上升子序列-DP、二分法插入"><a href="#300-最长上升子序列-DP、二分法插入" class="headerlink" title="300.最长上升子序列:DP、二分法插入"></a>300.最长上升子序列:DP、二分法插入</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这个数组实际上的长度，就是最后所求</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end<span class="token operator">++</span><span class="token punctuation">;</span>                tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用二分搜索法来做这件事情，二分法实现nlogn的时间复杂度</span>                <span class="token comment" spellcheck="true">// 修改目前tail中比target小的最大数为target</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>                <span class="token keyword">int</span> target <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">+</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//int mid = left + (right - left) / 2;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 只要比目标值要小，要找的位置就至少是当前位置 + 1</span>                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">assert</span> tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 大于目标值，不能盲目向前走，因为向前走很可能，值会变得比目标值小</span>                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                tail<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="494-目标和-DP-背包问题"><a href="#494-目标和-DP-背包问题" class="headerlink" title="494. 目标和:DP+背包问题"></a>494. 目标和:DP+背包问题</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/**     * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合     * 所以题目可以转化为     * sum(P) - sum(N) = target      * => sum(nums) + sum(P) - sum(N) = target + sum(nums)     * => 2 * sum(P) = target + sum(nums)      * => sum(P) = (target + sum(nums)) / 2     * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> S <span class="token operator">||</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>w <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">;</span> j <span class="token operator">>=</span> num<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="638-大礼包-DP"><a href="#638-大礼包-DP" class="headerlink" title="638. 大礼包:DP"></a>638. 大礼包:DP</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shoppingOffers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> price<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> special<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> needs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//统计不使用大礼包的总价</span>        <span class="token keyword">int</span> noSpecial <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>needs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            noSpecial <span class="token operator">+=</span> price<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> noSpecial<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历每一个大礼包</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sp <span class="token operator">:</span> special<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当前大礼包超过购买数量，跳过</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span>needs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用当前大礼包后，还有多少剩下的</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> newNeeds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Integer i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    newNeeds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//剩下的购买数量递归调用本方法，获取最低价格</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">shoppingOffers</span><span class="token punctuation">(</span>price<span class="token punctuation">,</span>special<span class="token punctuation">,</span>newNeeds<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//使用当前大礼包和不使用相比，选价格最低的</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>left <span class="token operator">+</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> special<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> needs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>needs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>special<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="651-4键键盘-DP-贪心算法"><a href="#651-4键键盘-DP-贪心算法" class="headerlink" title="651. 4键键盘:DP+贪心算法"></a>651. 4键键盘:DP+贪心算法</h2><p>复制粘贴还是直接输入，得到最长字符串</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxA</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token operator">></span>b <span class="token operator">?</span> a<span class="token operator">:</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="983-最低票价-DP"><a href="#983-最低票价-DP" class="headerlink" title="983. 最低票价:DP"></a>983. 最低票价:DP</h2><p>买火车票：1天、7天、30天</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> days<span class="token punctuation">,</span> costs<span class="token punctuation">;</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> durations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mincostTickets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> days<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>days <span class="token operator">=</span> days<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>costs <span class="token operator">=</span> costs<span class="token punctuation">;</span>        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>days<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> days<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> days<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> days<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> days<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> durations<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">dp</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目-DFS"><a href="#323-无向图中连通分量的数目-DFS" class="headerlink" title="323. 无向图中连通分量的数目:DFS"></a>323. 无向图中连通分量的数目:DFS</h2><pre class=" language-c++"><code class="language-c++">class Solution {public:    int countComponents(int n, vector<vector<int>>& edges) {        vector<int>a(n, 0);        vector<vector<int>>arr(n, a);        for (auto it : edges) {            arr[it[0]][it[1]] = 1;            arr[it[1]][it[0]] = 1;        }        int res = 0;        vector<int>mark(n, 0);        for (int i = 0; i < n; i++) {            if (mark[i] == 0) {                DFS(arr, mark, i);                res++;            }        }        return res;            }private:    void DFS(vector<vector<int>>&arr, vector<int>& mark,int b) {            mark[b] = 1;            for (int i = 0; i < arr.size(); i++) {                if (arr[i][b] == 1&&mark[i] == 0) {                    DFS(arr, mark,i);                }            }            mark[b] = 2;    }};</code></pre><h2 id="529-扫雷游戏-BFS-x2F-DFS"><a href="#529-扫雷游戏-BFS-x2F-DFS" class="headerlink" title="529. 扫雷游戏:BFS/DFS"></a>529. 扫雷游戏:BFS/DFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateBoard</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> click<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token function">visit</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>click<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>click<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>      <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> board<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span>                   count<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">else</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span><span class="token punctuation">)</span>                       <span class="token function">visit</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>       <span class="token punctuation">}</span>              <span class="token keyword">return</span> board<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="127-单词接龙：BFS"><a href="#127-单词接龙：BFS" class="headerlink" title="127. 单词接龙：BFS"></a>127. 单词接龙：BFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javafx<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Pair<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Since all words are of same length.</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> beginWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dictionary to hold combination of words that can be formed,</span>    <span class="token comment" spellcheck="true">// from any given word. By changing one letter at a time.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span> allComboDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        word <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Key is the generic word</span>            <span class="token comment" spellcheck="true">// Value is a list of words which have the same intermediate generic word.</span>            String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> transformations <span class="token operator">=</span>                allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            transformations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            allComboDict<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> transformations<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Queue for BFS</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Visited to make sure we don't repeat processing same word.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String word <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> level <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Intermediate words for current word</span>        String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Next states are all the words which share the same intermediate state.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String adjacentWord <span class="token operator">:</span> allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// If at any point if we find what we are looking for</span>          <span class="token comment" spellcheck="true">// i.e. the end word - we can return with the answer.</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>adjacentWord<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// Otherwise, add it to the BFS Queue. Also mark it visited</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双向广度优先搜索</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javafx<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Pair<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> L<span class="token punctuation">;</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span> allComboDict<span class="token punctuation">;</span>  <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dictionary to hold combination of words that can be formed,</span>    <span class="token comment" spellcheck="true">// from any given word. By changing one letter at a time.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>      Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q<span class="token punctuation">,</span>      HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visited<span class="token punctuation">,</span>      HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> othersVisited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String word <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Intermediate words for current word</span>      String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Next states are all the words which share the same intermediate state.</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>String adjacentWord <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If at any point if we find what we are looking for</span>        <span class="token comment" spellcheck="true">// i.e. the end word - we can return with the answer.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>othersVisited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> level <span class="token operator">+</span> othersVisited<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Save the level as the value of the dictionary, to save number of hops.</span>          visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wordList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Since all words are of same length.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>L <span class="token operator">=</span> beginWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        word <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Key is the generic word</span>            <span class="token comment" spellcheck="true">// Value is a list of words which have the same intermediate generic word.</span>            String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> transformations <span class="token operator">=</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            transformations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> transformations<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Queues for birdirectional BFS</span>    <span class="token comment" spellcheck="true">// BFS starting from beginWord</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q_begin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// BFS starting from endWord</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q_end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q_begin<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q_end<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>endWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Visited to make sure we don't repeat processing same word.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visitedBegin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visitedEnd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedBegin<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedEnd<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>endWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q_begin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Q_end<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// One hop from begin word</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>Q_begin<span class="token punctuation">,</span> visitedBegin<span class="token punctuation">,</span> visitedEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// One hop from end word</span>      ans <span class="token operator">=</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>Q_end<span class="token punctuation">,</span> visitedEnd<span class="token punctuation">,</span> visitedBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="139-单词拆分：BFS-x2F-DP"><a href="#139-单词拆分：BFS-x2F-DP" class="headerlink" title="139. 单词拆分：BFS/DP"></a>139. 单词拆分：BFS/DP</h2><p>BFS</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>DP</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="279-完全平方数-BST"><a href="#279-完全平方数-BST" class="headerlink" title="279. 完全平方数:BST"></a>279. 完全平方数:BST</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token keyword">int</span> step<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">=</span> step<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将问题转化成图论</span>    <span class="token comment" spellcheck="true">// 该算法在往队列里面添加节点的时候会 add 很多重复的节点，导致超时，</span>    <span class="token comment" spellcheck="true">// 优化办法是，加入 visited 数组，检查要 add 的数据是否已经出现过了，防止数据重复出现，从而影响图的遍历</span>    <span class="token comment" spellcheck="true">// 同时优化：num - i * i 表达式，只让他计算一次</span>    <span class="token comment" spellcheck="true">// 同时在循环体里面判断退出或返回的条件，而不是在循环体外</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 其实一个真正的图的 BSF 是一定会加上 visited 数组来过滤元素的</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">int</span> step <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>step<span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> a <span class="token operator">=</span> num <span class="token operator">-</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 若 a 已经计算到 0 了，就不必再往下执行了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    visited<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="515-在每个树行中找最大值-BFS"><a href="#515-在每个树行中找最大值-BFS" class="headerlink" title="515. 在每个树行中找最大值:BFS"></a>515. 在每个树行中找最大值:BFS</h2><p>在二叉树的每一行中找到最大的值。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">largestValues</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> rlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> rlist<span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> nodeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            rlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rlist<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="994-腐烂的橘子-BFS"><a href="#994-腐烂的橘子-BFS" class="headerlink" title="994. 腐烂的橘子:BFS"></a>994. 腐烂的橘子:BFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">orangesRotting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> R <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">,</span> C <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// queue : all starting cells with rotten oranges</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> depth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> C<span class="token punctuation">;</span> <span class="token operator">++</span>c<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> code <span class="token operator">=</span> r <span class="token operator">*</span> C <span class="token operator">+</span> c<span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>                    depth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> code <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> code <span class="token operator">/</span> C<span class="token punctuation">,</span> c <span class="token operator">=</span> code <span class="token operator">%</span> C<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nr <span class="token operator">=</span> r <span class="token operator">+</span> dr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nc <span class="token operator">=</span> c <span class="token operator">+</span> dc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nr <span class="token operator">&amp;&amp;</span> nr <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> nc <span class="token operator">&amp;&amp;</span> nc <span class="token operator">&lt;</span> C <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    grid<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> ncode <span class="token operator">=</span> nr <span class="token operator">*</span> C <span class="token operator">+</span> nc<span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ncode<span class="token punctuation">)</span><span class="token punctuation">;</span>                    depth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ncode<span class="token punctuation">,</span> depth<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans <span class="token operator">=</span> depth<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ncode<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row<span class="token operator">:</span> grid<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span> row<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a>646. 最长数对链</h2><p>按end排序 然后每次选择能放的end最小的一个数对加入当前的数对链</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLongestChain</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pairs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pairs<span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>tmp <span class="token operator">=</span> pairs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> pairs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>                 res<span class="token operator">++</span><span class="token punctuation">;</span>                 tmp <span class="token operator">=</span> pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="547-省份数量：无向图最小连通数：并查集-x2F-DFS"><a href="#547-省份数量：无向图最小连通数：并查集-x2F-DFS" class="headerlink" title="547.省份数量：无向图最小连通数：并查集/DFS"></a>547.省份数量：无向图最小连通数：并查集/DFS</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//无向图最小连通数</span><span class="token comment" spellcheck="true">// //并查集</span><span class="token comment" spellcheck="true">// class Solution {</span><span class="token comment" spellcheck="true">//     public int findCircleNum(int[][] M) {</span><span class="token comment" spellcheck="true">//         int s = M.length;</span><span class="token comment" spellcheck="true">//         UnionFind uf = new UnionFind(s);</span><span class="token comment" spellcheck="true">//         for(int i = 0;i&lt;s-1;i++)</span><span class="token comment" spellcheck="true">//             for(int j = i+1;j&lt;s;j++)</span><span class="token comment" spellcheck="true">//                 if(M[i][j] == 1) </span><span class="token comment" spellcheck="true">//                     uf.union(i,j);</span><span class="token comment" spellcheck="true">//         return uf.getSetCount();</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">// }</span>    <span class="token comment" spellcheck="true">//     public class UnionFind {</span><span class="token comment" spellcheck="true">// private int[] id; // 表示当前下标是父亲是谁，如in[3] = 1, 3的父亲是1。</span><span class="token comment" spellcheck="true">// private int[] size; </span><span class="token comment" spellcheck="true">// private int setCount; //连通个数</span><span class="token comment" spellcheck="true">// private int maxSetSize; //最大的size</span>        <span class="token comment" spellcheck="true">//         //初始化</span><span class="token comment" spellcheck="true">// public UnionFind(int n) {</span><span class="token comment" spellcheck="true">// id = new int[n];</span><span class="token comment" spellcheck="true">// size = new int[n];</span><span class="token comment" spellcheck="true">//             //父节点以及size的初始化</span><span class="token comment" spellcheck="true">// for (int i = 0; i &lt; n; i++) {</span><span class="token comment" spellcheck="true">// id[i] = i; // self-loop</span><span class="token comment" spellcheck="true">// size[i] = 1;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// setCount = n;</span><span class="token comment" spellcheck="true">// maxSetSize = 1;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// // O(logN)</span><span class="token comment" spellcheck="true">// public void union(int i, int j) {</span><span class="token comment" spellcheck="true">// int ri = root(i);</span><span class="token comment" spellcheck="true">// int rj = root(j);</span><span class="token comment" spellcheck="true">// if (ri == rj)</span><span class="token comment" spellcheck="true">// return;</span><span class="token comment" spellcheck="true">//             //将个数小的合并到个数大的集合中</span><span class="token comment" spellcheck="true">// if (size[ri] >= size[rj]) {</span><span class="token comment" spellcheck="true">// id[rj] = id[ri];</span><span class="token comment" spellcheck="true">// size[ri] += size[rj];</span><span class="token comment" spellcheck="true">// maxSetSize = Math.max(maxSetSize, size[ri]);</span><span class="token comment" spellcheck="true">// } else {</span><span class="token comment" spellcheck="true">// id[ri] = id[rj];</span><span class="token comment" spellcheck="true">// size[rj] += size[ri];</span><span class="token comment" spellcheck="true">// maxSetSize = Math.max(maxSetSize, size[rj]);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// setCount--;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// // O(logN)</span><span class="token comment" spellcheck="true">// public boolean find(int i, int j) {</span><span class="token comment" spellcheck="true">// return root(i) == root(j);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// public int getMaxSetSize() {</span><span class="token comment" spellcheck="true">// return maxSetSize;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// public int getSetCount() {</span><span class="token comment" spellcheck="true">// return setCount;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// private int root(int i) { // 不停向上寻找父节点</span><span class="token comment" spellcheck="true">// while (id[i] != i) { // keep checking for the self-loop</span><span class="token comment" spellcheck="true">// id[i] = id[id[i]]; // set grand-parent as parent (path compression)</span><span class="token comment" spellcheck="true">// i = id[i]; // go up to parent</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// return i;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">//DFS</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> N <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>i<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> si<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>si<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目-dfs"><a href="#323-无向图中连通分量的数目-dfs" class="headerlink" title="323. 无向图中连通分量的数目:dfs"></a>323. 无向图中连通分量的数目:dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countComponents</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> mark<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> map<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="934-最短的桥-dfs-x2F-bfs"><a href="#934-最短的桥-dfs-x2F-bfs" class="headerlink" title="934. 最短的桥:dfs/bfs"></a>934. 最短的桥:dfs/bfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//dfs寻找第一个岛屿，bfs寻找最断桥</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shortestBridge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix <span class="token operator">=</span> A<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//让A变成一个全局变量</span>        queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//控制dfs只寻找一个岛屿</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>found<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>found<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    found <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//cur[1]表示当前步数</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span>n<span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">%</span>n<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dir<span class="token operator">:</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> x <span class="token operator">=</span> i <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> y <span class="token operator">=</span> j <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">>=</span> n <span class="token operator">||</span> y <span class="token operator">>=</span> n <span class="token operator">||</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cur<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>x<span class="token operator">*</span>n<span class="token operator">+</span>y<span class="token punctuation">,</span>cur<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dir<span class="token operator">:</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> i<span class="token operator">+</span>dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> j<span class="token operator">+</span>dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>x<span class="token operator">>=</span>n<span class="token operator">||</span> y<span class="token operator">>=</span>n<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>n<span class="token operator">*</span>x<span class="token operator">+</span>y<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="207-课程表-有向图是否有环：拓扑排序-x2F-dfs"><a href="#207-课程表-有向图是否有环：拓扑排序-x2F-dfs" class="headerlink" title="207. 课程表:有向图是否有环：拓扑排序/dfs"></a>207. 课程表:有向图是否有环：拓扑排序/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*拓扑排序    *每一次都输出入度为0的结点，并移除它、修改它指向的结点的入度    *依次得到的结点序列就是拓扑排序的结点序列    *如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。    *拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面    *并且可以完成所有活动。拓扑排序的结果不唯一。    *拓扑排序还可以用于检测一个有向图是否有环    *拓扑排序实际上应用的是贪心算法    */</span>    <span class="token comment" spellcheck="true">// public boolean canFinish(int numCourses, int[][] prerequisites) {</span>    <span class="token comment" spellcheck="true">//     if (numCourses &lt;= 0) </span>    <span class="token comment" spellcheck="true">//         return false;</span>    <span class="token comment" spellcheck="true">//     int plen = prerequisites.length;</span>    <span class="token comment" spellcheck="true">//     if (plen == 0) </span>    <span class="token comment" spellcheck="true">//         return true;</span>    <span class="token comment" spellcheck="true">//     int[] inDegree = new int[numCourses]; //保存入度</span>    <span class="token comment" spellcheck="true">//     for (int[] p : prerequisites) </span>    <span class="token comment" spellcheck="true">//         inDegree[p[0]]++;</span>    <span class="token comment" spellcheck="true">//     LinkedList&lt;Integer> queue = new LinkedList&lt;>(); //保存入度为0的队列</span>    <span class="token comment" spellcheck="true">//     // 首先加入入度为 0 的结点</span>    <span class="token comment" spellcheck="true">//     for (int i = 0; i &lt; numCourses; i++) {</span>    <span class="token comment" spellcheck="true">//         if (inDegree[i] == 0) {</span>    <span class="token comment" spellcheck="true">//             queue.addLast(i);</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     // 拓扑排序的结果</span>    <span class="token comment" spellcheck="true">//     List&lt;Integer> res = new ArrayList&lt;>();</span>    <span class="token comment" spellcheck="true">//     while (!queue.isEmpty()) {</span>    <span class="token comment" spellcheck="true">//         Integer num = queue.removeFirst();</span>    <span class="token comment" spellcheck="true">//         res.add(num);</span>    <span class="token comment" spellcheck="true">//         // 把邻边全部遍历一下</span>    <span class="token comment" spellcheck="true">//         for (int[] p : prerequisites) {</span>    <span class="token comment" spellcheck="true">//             if (p[1] == num) {</span>    <span class="token comment" spellcheck="true">//                 inDegree[p[0]]--;</span>    <span class="token comment" spellcheck="true">//                 if (inDegree[p[0]] == 0) {</span>    <span class="token comment" spellcheck="true">//                     queue.addLast(p[0]);</span>    <span class="token comment" spellcheck="true">//                 }</span>    <span class="token comment" spellcheck="true">//             }</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return res.size() == numCourses;</span>    <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">/*深度优先遍历    *其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完    */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canFinish</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numCourses <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> prerequisites<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化有向图</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 有向图的 key 是前驱结点，value 是后继结点的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            graph<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span>        <span class="token comment" spellcheck="true">// 所有课程任务可以完成，应该返回 true</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span>    <span class="token comment" spellcheck="true">//return true 表示图中存在环，false 表示访问过了，不用再访问了</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果访问过了，就不用再访问了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从正在访问中，到正在访问中，表示遇到了环</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表示在访问的过程中没有遇到环，这个节点访问过了</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 走到这里，是因为初始化呢，此时 marked[i] == 0</span>        <span class="token comment" spellcheck="true">// 表示正在访问中</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后继结点的集合</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> successorNodes <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer successor <span class="token operator">:</span> successorNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>successor<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 层层递归返回 true ，表示图中存在环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>        <span class="token comment" spellcheck="true">// 状态设置为 2</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// false 表示图中不存在环</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="210-课程表-II：返回有向图路径：拓扑排序-x2F-dfs"><a href="#210-课程表-II：返回有向图路径：拓扑排序-x2F-dfs" class="headerlink" title="210. 课程表 II：返回有向图路径：拓扑排序/dfs"></a>210. 课程表 II：返回有向图路径：拓扑排序/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//拓扑排序</span><span class="token comment" spellcheck="true">//     public int[] findOrder(int numCourses, int[][] prerequisites) {</span><span class="token comment" spellcheck="true">//         if (numCourses &lt;= 0)</span><span class="token comment" spellcheck="true">//             return new int[0];</span>        <span class="token comment" spellcheck="true">//         // 邻接表表示</span><span class="token comment" spellcheck="true">//         HashSet&lt;Integer>[] graph = new HashSet[numCourses];</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//             graph[i] = new HashSet&lt;>();</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         // 入度表</span><span class="token comment" spellcheck="true">//         int[] inDegree = new int[numCourses];</span>        <span class="token comment" spellcheck="true">//         // 遍历 prerequisites 的时候，把 邻接表 和 入度表 都填上</span><span class="token comment" spellcheck="true">//         for (int[] p : prerequisites) {</span><span class="token comment" spellcheck="true">//             graph[p[1]].add(p[0]);</span><span class="token comment" spellcheck="true">//             inDegree[p[0]]++;</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         LinkedList&lt;Integer> queue = new LinkedList&lt;>();</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//             if (inDegree[i] == 0) {</span><span class="token comment" spellcheck="true">//                 queue.addLast(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         ArrayList&lt;Integer> res = new ArrayList&lt;>();</span><span class="token comment" spellcheck="true">//         while (!queue.isEmpty()) {</span><span class="token comment" spellcheck="true">//             Integer inDegreeNode = queue.removeFirst();</span><span class="token comment" spellcheck="true">//             res.add(inDegreeNode);</span><span class="token comment" spellcheck="true">//             HashSet&lt;Integer> nextCourses = graph[inDegreeNode];</span><span class="token comment" spellcheck="true">//             for (Integer nextCourse : nextCourses) {</span><span class="token comment" spellcheck="true">//                 inDegree[nextCourse]--;</span><span class="token comment" spellcheck="true">//                 // 马上检测该结点的入度是否为 0，如果为 0，马上加入队列</span><span class="token comment" spellcheck="true">//                 if (inDegree[nextCourse] == 0) {</span><span class="token comment" spellcheck="true">//                     queue.addLast(nextCourse);</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         // 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span><span class="token comment" spellcheck="true">//         int resLen = res.size();</span><span class="token comment" spellcheck="true">//         if (resLen == numCourses) {</span><span class="token comment" spellcheck="true">//             int[] ret = new int[numCourses];</span><span class="token comment" spellcheck="true">//             for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//                 ret[i] = res.get(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             //返回的是数组而不是ArrayList</span><span class="token comment" spellcheck="true">//             return ret;</span><span class="token comment" spellcheck="true">//         } else {</span><span class="token comment" spellcheck="true">//             return new int[0];</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">//DFS</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numCourses <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> prerequisites<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没有有向边，则表示不存在课程依赖，任务一定可以完成</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 初始化有向图 </span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 有向图的 key 是前驱结点，value 是后继结点的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            graph<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 使用 Stack 或者 List 记录递归的顺序，这里使用 Stack</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回空数组</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">assert</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> numCourses<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>                        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span>                        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">,</span>                        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从正在访问中，到正在访问中，表示遇到了环</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表示在访问的过程中没有遇到环，这个节点访问过了</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> successorNodes <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer successor <span class="token operator">:</span> successorNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>successor<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 层层递归返回 true ，表示图中存在环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>        <span class="token comment" spellcheck="true">// 状态设置为 2</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//拓扑排序</span><span class="token comment" spellcheck="true">//     private int[] inDegree;</span><span class="token comment" spellcheck="true">//     private boolean[][] graph;</span><span class="token comment" spellcheck="true">//     private boolean[] onQueue;</span><span class="token comment" spellcheck="true">//     private Queue&lt;Integer> queue;</span><span class="token comment" spellcheck="true">//     public int[] findOrder(int numCourses, int[][] prerequisites) {</span><span class="token comment" spellcheck="true">//         inDegree=new int[numCourses];</span><span class="token comment" spellcheck="true">//         graph=new boolean[numCourses][numCourses];</span><span class="token comment" spellcheck="true">//         onQueue=new boolean[numCourses];</span><span class="token comment" spellcheck="true">//         queue=new LinkedList&lt;>();</span><span class="token comment" spellcheck="true">//         //初始化</span><span class="token comment" spellcheck="true">//         for(int i=0;i&lt;prerequisites.length;i++){</span><span class="token comment" spellcheck="true">//             graph[prerequisites[i][1]][prerequisites[i][0]]=true;</span><span class="token comment" spellcheck="true">//             inDegree[prerequisites[i][0]]++;</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         int[] rt=new int[numCourses];</span><span class="token comment" spellcheck="true">//         int count=0;</span><span class="token comment" spellcheck="true">//         findNextInDegreeZero();</span><span class="token comment" spellcheck="true">//         while(!queue.isEmpty()){</span><span class="token comment" spellcheck="true">//             int v =queue.poll();</span><span class="token comment" spellcheck="true">//             rt[count++]=v;</span><span class="token comment" spellcheck="true">//             for(int i=0;i&lt;graph[v].length;i++){</span><span class="token comment" spellcheck="true">//                 if(graph[v][i]){</span><span class="token comment" spellcheck="true">//                     inDegree[i]--;</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             findNextInDegreeZero();</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         if(count==numCourses){</span><span class="token comment" spellcheck="true">//          return rt;   </span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return new int[]{};</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">//     public void findNextInDegreeZero(){</span><span class="token comment" spellcheck="true">//         for(int i=0;i&lt;inDegree.length;i++){</span><span class="token comment" spellcheck="true">//             if(inDegree[i]==0&amp;&amp;!onQueue[i]){</span><span class="token comment" spellcheck="true">//                 onQueue[i]=true;</span><span class="token comment" spellcheck="true">//                 queue.add(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="5-最长回文子串-中心扩展算法-x2F-DP-x2F-Manacher-算法-马拉车"><a href="#5-最长回文子串-中心扩展算法-x2F-DP-x2F-Manacher-算法-马拉车" class="headerlink" title="5. 最长回文子串:中心扩展算法/DP/Manacher 算法(马拉车)"></a>5. 最长回文子串:中心扩展算法/DP/Manacher 算法(马拉车)</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 中心扩展算法</span>    <span class="token comment" spellcheck="true">// 2n-1个中心（偶数+奇数）</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//奇数长度</span>            <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//偶数长度</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> L <span class="token operator">=</span> left<span class="token punctuation">,</span> R <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            L<span class="token operator">--</span><span class="token punctuation">;</span>            R<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// //动态规划</span>    <span class="token comment" spellcheck="true">// public String longestPalindrome(String s) {</span>    <span class="token comment" spellcheck="true">//     int len = s.length();</span>    <span class="token comment" spellcheck="true">//     if(len&lt;=1)</span>    <span class="token comment" spellcheck="true">//         return s;</span>    <span class="token comment" spellcheck="true">//     int longest = 1;</span>    <span class="token comment" spellcheck="true">//     String str = s.substring(0,1);</span>    <span class="token comment" spellcheck="true">//     boolean[][] dp = new boolean[len][len];</span>    <span class="token comment" spellcheck="true">//     for(int r=1;r&lt;len;r++) {</span>    <span class="token comment" spellcheck="true">//         for(int l=0;l&lt;r;l++) {</span>    <span class="token comment" spellcheck="true">//             if(s.charAt(l)==s.charAt(r) &amp;&amp; (r-l&lt;=2 || dp[l+1][r-1])) {</span>    <span class="token comment" spellcheck="true">//                 dp[l][r]=true;</span>    <span class="token comment" spellcheck="true">//                 if(r-l+1>longest) {</span>    <span class="token comment" spellcheck="true">//                     longest = r-l+1;</span>    <span class="token comment" spellcheck="true">//                     str = s.substring(l,r+1);</span>    <span class="token comment" spellcheck="true">//                 }</span>    <span class="token comment" spellcheck="true">//             }</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return str;</span>    <span class="token comment" spellcheck="true">// }</span>    <span class="token comment" spellcheck="true">//     //Manacher 算法(马拉车)</span><span class="token comment" spellcheck="true">//     //本质上还是中心扩散法</span><span class="token comment" spellcheck="true">//     int len;</span><span class="token comment" spellcheck="true">//     //插入字符，使长度始终未奇数，且不改变回文子串</span><span class="token comment" spellcheck="true">//     private String generateSDivided(String s, char divide) {</span><span class="token comment" spellcheck="true">//         if (s.indexOf(divide) != -1) {</span><span class="token comment" spellcheck="true">//             throw new IllegalArgumentException("参数错误，您传递的分割字符，在输入字符串中存在！");</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         StringBuilder sBuilder = new StringBuilder();</span><span class="token comment" spellcheck="true">//         sBuilder.append(divide);</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; len; i++) {</span><span class="token comment" spellcheck="true">//             sBuilder.append(s.charAt(i));</span><span class="token comment" spellcheck="true">//             sBuilder.append(divide);</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return sBuilder.toString();</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">//     public String longestPalindrome(String s) {</span><span class="token comment" spellcheck="true">//         len = s.length();</span><span class="token comment" spellcheck="true">//         if (len == 0) {</span><span class="token comment" spellcheck="true">//             return "";</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         String sDivided = generateSDivided(s, '#');</span><span class="token comment" spellcheck="true">//         int slen = sDivided.length();</span><span class="token comment" spellcheck="true">//         int[] p = new int[slen];</span><span class="token comment" spellcheck="true">//         int mx = 0;</span><span class="token comment" spellcheck="true">//         // id 是由 mx 决定的，所以不用初始化，只要声明就可以了</span><span class="token comment" spellcheck="true">//         int id = 0;</span><span class="token comment" spellcheck="true">//         int longestPalindrome = 1;</span><span class="token comment" spellcheck="true">//         String longestPalindromeStr = s.substring(0, 1);</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; slen; i++) {</span><span class="token comment" spellcheck="true">//             if (i &lt; mx) {</span><span class="token comment" spellcheck="true">//                 // 这一步是 Manacher 算法的关键所在，一定要结合图形来理解</span><span class="token comment" spellcheck="true">//                 // 这一行代码是关键，可以把两种分类讨论的情况合并</span><span class="token comment" spellcheck="true">//                 p[i] = Integer.min(p[2 * id - i], mx - i);</span><span class="token comment" spellcheck="true">//             } else {</span><span class="token comment" spellcheck="true">//                 // 走到这里，只可能是因为 i = mx</span><span class="token comment" spellcheck="true">//                 if (i > mx) {</span><span class="token comment" spellcheck="true">//                     throw new IllegalArgumentException("程序出错！");</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//                 p[i] = 1;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             // 老老实实去匹配，看新的字符</span><span class="token comment" spellcheck="true">//             //以i为中心，进行中心扩散</span><span class="token comment" spellcheck="true">//             while (i - p[i] >= 0 &amp;&amp; i + p[i] &lt; slen &amp;&amp; sDivided.charAt(i - p[i]) == sDivided.charAt(i + p[i])) {z</span><span class="token comment" spellcheck="true">//                 p[i]++;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             // 我们想象 mx 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span><span class="token comment" spellcheck="true">//             // 写到这里，我们发现，如果 mx 的值越大，</span><span class="token comment" spellcheck="true">//             // 进入上面 i &lt; mx 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span><span class="token comment" spellcheck="true">//             if (i + p[i] > mx) {</span>        <span class="token comment" spellcheck="true">//                 id = i;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             if (p[i] - 1 > longestPalindrome) {</span><span class="token comment" spellcheck="true">//                 longestPalindrome = p[i] - 1;</span><span class="token comment" spellcheck="true">//                 longestPalindromeStr = sDivided.substring(i - p[i] + 1, i + p[i]).replace("#", "");</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return longestPalindromeStr;</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//         int n = s.length();</span><span class="token comment" spellcheck="true">//         int[][] dp = new int[n][n];</span>        <span class="token comment" spellcheck="true">//         //00, 11, 22, 33, 44</span><span class="token comment" spellcheck="true">//         for(int i=0; i&lt;n; i++){</span><span class="token comment" spellcheck="true">//             dp[i][i] = 1;//从i到j的最长回文子序列长度</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         //01, 12, 23, 34</span><span class="token comment" spellcheck="true">//         //02,13,24</span><span class="token comment" spellcheck="true">//         //03,14</span><span class="token comment" spellcheck="true">//         //04</span><span class="token comment" spellcheck="true">//         for(int l=2; l&lt;=n; l++){//l是子序列长度</span><span class="token comment" spellcheck="true">//             for(int i=0; i&lt;n-l+1; i++){//i是start</span><span class="token comment" spellcheck="true">//                 int j = i+l-1;//j是end</span><span class="token comment" spellcheck="true">//                 if(l==2 &amp;&amp; s.charAt(j) == s.charAt(i)) dp[i][j] = 2;//长度为2</span><span class="token comment" spellcheck="true">//                 else if (s.charAt(j) == s.charAt(i)) dp[i][j] = 2 + dp[i+1][j-1];</span><span class="token comment" spellcheck="true">//                 else dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return dp[0][n-1];//从0到n-1</span>                <span class="token comment" spellcheck="true">//改进 从后往前（应该和从前往后一样）</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> current<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            current<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    current<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>pre<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    current<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>current<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>current<span class="token punctuation">;</span>            current<span class="token operator">=</span>tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//     //回溯</span><span class="token comment" spellcheck="true">//     public boolean isMatch(String text, String pattern) {</span><span class="token comment" spellcheck="true">//         if (pattern.isEmpty())</span><span class="token comment" spellcheck="true">//             return text.isEmpty();</span><span class="token comment" spellcheck="true">//         boolean first_match = (!text.isEmpty() &amp;&amp;</span><span class="token comment" spellcheck="true">//                                (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));</span><span class="token comment" spellcheck="true">//         if (pattern.length() >= 2 &amp;&amp; pattern.charAt(1) == '*'){</span><span class="token comment" spellcheck="true">//             return (isMatch(text, pattern.substring(2)) ||</span><span class="token comment" spellcheck="true">//                     (first_match &amp;&amp; isMatch(text.substring(1), pattern)));</span><span class="token comment" spellcheck="true">//         } else {</span><span class="token comment" spellcheck="true">//             return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">//动态规划 自顶向下</span>    <span class="token comment" spellcheck="true">//其实只是想回溯的结果记录，即备忘录</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不能用boolean,无法判断是否已保存结果（==null）</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans <span class="token operator">=</span> i <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">boolean</span> first_match <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                                   <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">||</span>                                    pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token operator">||</span>                       first_match <span class="token operator">&amp;&amp;</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                ans <span class="token operator">=</span> first_match <span class="token operator">&amp;&amp;</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//     //动态规划 自底向上</span><span class="token comment" spellcheck="true">//     public boolean isMatch(String text, String pattern) {</span><span class="token comment" spellcheck="true">//         boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];</span><span class="token comment" spellcheck="true">//         dp[text.length()][pattern.length()] = true;</span><span class="token comment" spellcheck="true">//         for (int i = text.length(); i >= 0; i--){</span><span class="token comment" spellcheck="true">//             for (int j = pattern.length() - 1; j >= 0; j--){</span><span class="token comment" spellcheck="true">//                 boolean first_match = (i &lt; text.length() &amp;&amp;</span><span class="token comment" spellcheck="true">//                                        (pattern.charAt(j) == text.charAt(i) ||</span><span class="token comment" spellcheck="true">//                                         pattern.charAt(j) == '.'));</span><span class="token comment" spellcheck="true">//                 if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j+1) == '*'){</span><span class="token comment" spellcheck="true">//                     dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];</span><span class="token comment" spellcheck="true">//                 } else {</span><span class="token comment" spellcheck="true">//                     dp[i][j] = first_match &amp;&amp; dp[i+1][j+1];</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return dp[0][0];</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="44-通配符匹配：双指针-x2F-动态规划"><a href="#44-通配符匹配：双指针-x2F-动态规划" class="headerlink" title="44. 通配符匹配：双指针/动态规划"></a>44. 通配符匹配：双指针/动态规划</h2><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><ul><li>‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符串（包括空字符串）。</li></ul></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//双指针</span>    <span class="token comment" spellcheck="true">// public boolean isMatch(String s, String p) {</span>    <span class="token comment" spellcheck="true">//     int sn = s.length();</span>    <span class="token comment" spellcheck="true">//     int pn = p.length();</span>    <span class="token comment" spellcheck="true">//     int i = 0;</span>    <span class="token comment" spellcheck="true">//     int j = 0;</span>    <span class="token comment" spellcheck="true">//     int start = -1;</span>    <span class="token comment" spellcheck="true">//     int match = 0;</span>    <span class="token comment" spellcheck="true">//     while (i &lt; sn) {</span>    <span class="token comment" spellcheck="true">//         if (j &lt; pn &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {</span>    <span class="token comment" spellcheck="true">//             i++;</span>    <span class="token comment" spellcheck="true">//             j++;</span>    <span class="token comment" spellcheck="true">//         } else if (j &lt; pn &amp;&amp; p.charAt(j) == '*') {</span>    <span class="token comment" spellcheck="true">//             start = j;</span>    <span class="token comment" spellcheck="true">//             match = i;</span>    <span class="token comment" spellcheck="true">//             j++;</span>    <span class="token comment" spellcheck="true">//         } else if (start != -1) { //还没到*匹配结束的位置</span>    <span class="token comment" spellcheck="true">//             j = start + 1;</span>    <span class="token comment" spellcheck="true">//             match++;</span>    <span class="token comment" spellcheck="true">//             i = match;</span>    <span class="token comment" spellcheck="true">//         } else {</span>    <span class="token comment" spellcheck="true">//             return false;</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     while (j &lt; pn) { //i=sn 即i指针已结束，但j指针还没结束</span>    <span class="token comment" spellcheck="true">//         if (p.charAt(j) != '*') return false;</span>    <span class="token comment" spellcheck="true">//         j++;</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return true;</span>    <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">//动态规划</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//*为任意字符或空字符</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目要求-2"><a href="#题目要求-2" class="headerlink" title="题目要求"></a>题目要求</h3><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    bool isHappy(int n) {        unordered_set<int> bobo;        while(!bobo.count(n)){            int sum = 0;            bobo.insert(n);            while(n != 0){                sum = sum + (n%10) * (n%10);                n /= 10;            }            n = sum;        }        return n == 1;    }};//递归class Solution {public:    unordered_set<int> bobo;    bool isHappy(int n) {        int sum = 0;        if(n == 1) return true;        else if(bobo.count(n))  return false;        else{            bobo.insert(n);            while(n != 0){                sum = sum + (n%10) * (n%10);                n /= 10;            }            n = sum;        }        return isHappy(n);    }};</code></pre><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><h3 id="题目要求-3"><a href="#题目要求-3" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断无向图是否有换，以及是否为单连通分量</span>    <span class="token comment" spellcheck="true">//当只有n-1条边，且连通数为1时，符合条件</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只应该有n-1条边</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> par <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> par1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>par2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            par<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//并查集，每个点的父节点是自己</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            par1 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            par2 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不断向上寻找得到par1和par2的祖先节点</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">)</span>                par1 <span class="token operator">=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">while</span><span class="token punctuation">(</span>par2 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">)</span>                par2 <span class="token operator">=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par2<span class="token punctuation">)</span><span class="token punctuation">{</span>                par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span> <span class="token operator">=</span> par1<span class="token punctuation">;</span>                n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="695-岛屿的最大面积-最大的无向连通图-x2F-dfs"><a href="#695-岛屿的最大面积-最大的无向连通图-x2F-dfs" class="headerlink" title="695. 岛屿的最大面积:最大的无向连通图/dfs"></a>695. 岛屿的最大面积:最大的无向连通图/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//最大的无向连通图 模板</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        c <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>c<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//直接返回当前dfs的数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> i<span class="token operator">>=</span>r <span class="token operator">||</span> j<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">>=</span>c <span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//grid[i][j]==0一定要放在最后面，避免下标越界</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="394-字符串解码-栈"><a href="#394-字符串解码-栈" class="headerlink" title="394. 字符串解码:栈"></a>394. 字符串解码:栈</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">decodeString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>String<span class="token operator">></span> strStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String tempStr <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i用来控制指针坐标</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> numStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String nowStr <span class="token operator">=</span> <span class="token function">repeatStr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>numStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   StringBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//将后面不需要重复的字符（遇到下一个]和数字之前的字符）加到builder后面</span>                   <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       m<span class="token operator">++</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                   builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    tempStr <span class="token operator">=</span> null<span class="token punctuation">;</span>                    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//可能是个多位数</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    m<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                numStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//得到下一个字符串</span>                <span class="token keyword">int</span> k <span class="token operator">=</span>  i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>                    k<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">repeatStr</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//两遍哈希</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> i<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一遍哈希</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-无重复字符的最长子串：滑动窗口"><a href="#3-无重复字符的最长子串：滑动窗口" class="headerlink" title="3. 无重复字符的最长子串：滑动窗口"></a>3. 无重复字符的最长子串：滑动窗口</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Character<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化：使用 HashMap</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// current index of character</span>        <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化：假设字符集为 ASCII 128</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// current index of character</span>        <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>index<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="20-有效的括号：栈"><a href="#20-有效的括号：栈" class="headerlink" title="20. 有效的括号：栈"></a>20. 有效的括号：栈</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Hash table that takes care of the mappings.</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span> mappings<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Initialize hash map with mappings. This simply makes the code easier to read.</span>  <span class="token keyword">public</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Initialize a stack to be used in the algorithm.</span>    Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// If the current character is a closing bracket.</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Get the top element of the stack. If the stack is empty, set a dummy value of '#'</span>        <span class="token keyword">char</span> topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'#'</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// If the mapping for this bracket doesn't match the stack's top element, return false.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topElement <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If it was an opening bracket, push to the stack.</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If the stack still contains elements, then it is an invalid expression.</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//大顶堆</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// init heap 'the smallest element first'</span>        PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> heap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> n1 <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// keep k largest elements in the heap</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>          heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>            heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// output</span>        <span class="token keyword">return</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//快速选择（类似快排）</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. move pivot to end</span>    <span class="token function">swap</span><span class="token punctuation">(</span>pivot_index<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> store_index <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. move all smaller elements to the left</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>store_index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        store_index<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3. move pivot to its final place</span>    <span class="token function">swap</span><span class="token punctuation">(</span>store_index<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> store_index<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">quickselect</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k_smallest<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    Returns the k-th smallest element of list within left..right.    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If the list contains only one element,</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// return that element</span>    <span class="token comment" spellcheck="true">// select a random pivot_index</span>    Random random_num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot_index <span class="token operator">=</span> left <span class="token operator">+</span> random_num<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>         pivot_index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> pivot_index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the pivot is on (N - k)th smallest position</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_smallest <span class="token operator">==</span> pivot_index<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>k_smallest<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// go left side</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k_smallest <span class="token operator">&lt;</span> pivot_index<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> pivot_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// go right side</span>    <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span>pivot_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// kth largest is (N - k)th smallest</span>    <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="703-数据流中的第K大元素-最小堆"><a href="#703-数据流中的第K大元素-最小堆" class="headerlink" title="703. 数据流中的第K大元素:最小堆"></a>703. 数据流中的第K大元素:最小堆</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">KthLargest</span> <span class="token punctuation">{</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxHeap<span class="token punctuation">;</span>     <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//维护一个大小为k的最小堆 堆顶即是第k大的元素</span>    <span class="token keyword">public</span> <span class="token function">KthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        length <span class="token operator">=</span> k<span class="token punctuation">;</span>        maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;=</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                maxHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//最小堆</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历map，用最小堆保存频率最大的k个元素</span>        PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">,</span> Integer b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取出最小堆中的元素</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//桶排序法</span><span class="token comment" spellcheck="true">//基于桶排序求解「前 K 个高频元素」</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//桶排序</span>        <span class="token comment" spellcheck="true">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取出现的次数作为下标</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>               list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 倒序遍历数组获取出现顺序从大到小的排列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//官方题解</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// build hash map : character and how often it appears</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      count<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// init heap 'the less frequent element first'</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> heap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">-</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// keep k top frequent elements in the heap</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>        heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// build output list</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> top_k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      top_k<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>top_k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> top_k<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习</title>
      <link href="/2022/05/31/shu-ju-jie-gou-fu-xi/"/>
      <url>/2022/05/31/shu-ju-jie-gou-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul><li><p>线式存储结构： 结构地址空间连接，可随机访问，但顺序存储插入操作需要移动之后的元素，要耗费许多时间。</p></li><li><p>链式存储：不要求逻辑上相邻的元素在物理上相连，元素之间的逻辑关系通过指针表示。</p></li><li><p>顺序存储： 逻辑上相邻物理也相邻</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈： 先入后出，在表的末端（栈顶）进行插入删除，栈的存储结构分为<strong>基于数组的存储表示和顺序存储结构</strong>和<strong>基于链表的链式存储结构</strong><br>    - 顺序栈的内存结构：存放栈中元素的数组、栈顶指针、最大容纳元素个数<br>    - 链式栈的内存结构：栈顶指针  </p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列：先入先出，队尾插入队首删除。<ul><li><p>队列的顺序存储结构利用一个<em>一维数组</em>作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。</p></li><li><p>队列的链式队列由队首指针和队尾指针构成。</p></li><li><p>循环队列元素个数 = （尾 - 头 + 表长） % 表长</p><ol><li>当尾 &gt; 头， 元素个数 = 尾 - 头</li><li>因为是循环队列，可能出现头&gt;尾的情况， 此时元素个数 = 尾 - 头 + 表长<br>  为了得到一个统一的公式–循环队列元素个数 = （尾 - 头 + 表长） % 表长</li></ol></li><li><p>判断循环队列队空、队满的方法：<br>  front表示队头指针（指向队列内首元素）,rear表示队尾指针（指向队列内尾元素的下一个位置）,m表示队列的容量（包括那个留空的位置）</p><p>  <strong>队列内元素个数：(rear - front + m) % m</strong></p><p>  <img src="/img/posts/DataStructure/cycle_queue3.jpg"></p><p>  当队列为空时条件：<strong>rear == front</strong>，当队列满时条件为：<strong>（rear+1）% maxsize == front</strong></p></li></ul></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>hash表的实现主要包括构造哈希和处理哈希冲突两个方面：</p><p>对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。</p><p>对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>保持原图的n个系节点，并且有保持图联通的最少边。简单来说是有钱仅有n个点n-1条边的连通图。</p></li><li><p>最小生成树就是最小权重生成树的简称，即所有边的权值之和最小的生成树。</p></li></ul><p>求解最小生成树的方法有一下两种</p><h5 id="Kruskal算法（克鲁斯卡）"><a href="#Kruskal算法（克鲁斯卡）" class="headerlink" title="Kruskal算法（克鲁斯卡）"></a>Kruskal算法（克鲁斯卡）</h5><p>Kruskal是一种贪心算法</p><ul><li><p>核心思想：每次选择一条最小的边，使这两条边两头连通 </p></li><li><p>将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树。</p></li><li><p>如果两个顶点在同一个集合内，说明已经通过其他边相连，如果将这条边加入生成树，就会形成环，因此不可取</p></li></ul><p>Kruskal算法时间复杂的：O(mlogm),Kruskal算法的简单实现</p><pre class=" language-Java"><code class="language-Java">//Kruskal算法简单实现void Kruskal(V,T){    T = V; //初始化树T，仅含顶点    numS = n; //连通分量数    while(numS > 1) //若连通分量数大于1    {        从E中取出权值最小的边(v,u);        if(v和u属于T中不同的连通分量)        {            T=T∪{(v,u)}; //将此边加入生成树中            numS--; //连通分量数减1        }    }}</code></pre><p><img src="/img/posts/DataStructure/kruskal0.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法汇总</title>
      <link href="/2022/05/01/pai-xu-suan-fa-hui-zong/"/>
      <url>/2022/05/01/pai-xu-suan-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<ul><li>为了方便表示,提前定义swap(num[],i,j)<pre class=" language-Java"><code class="language-Java">protected void swap(int[] num, int i, int j) {    int t = a[i];    a[i] = a[j];    a[j] = t;}</code></pre></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>从左到右不断交换相邻的逆序的元素，复杂度为O(N^2)</li></ul><pre class=" language-Java"><code class="language-Java">    public void sort(int[] nums) {        int N = nums.length;        boolean isSorted = false;        for (int i = N - 1; i > 0 && !isSorted; i--) {            isSorted = true;            for (int j = 0; j < i; j++) {                if (nums[j + 1] < nums[j]) {                    isSorted = false;                    swap(nums, j, j + 1);                }            }        }    }    </code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>左侧是以及排好序的涉猎，每次排序都将当前元素插入左侧已经排序的数组中，是的插入之后左侧数组依然有序。</p></li><li><p>以数组[3,4,1,5,2]为例，逆序的对有(3,1),(3,2)(4,1)(4,2)(5,2)，插入排序每次交换逆序元素，因此插入排序交换的次数为逆序的数量插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要交换的次数也少，时间复杂度较低</p></li><li><p>Worst case:数组倒序</p></li><li><p>Best case:数组有序</p></li></ul><pre class=" language-Java"><code class="language-Java">public void sort(int[] nums) {        int N = nums.length;        for (int i = 1; i < N; i++) {            for (int j = i; j > 0 && nums[j] < nums[j - 1]; j--) { /* 这一步会把左边的都排好序 */                swap(nums, j, j - 1);            }        }    }</code></pre><p>时间复杂度：*<em>最坏情况下为O(N</em>N)**，此时待排序列为逆序，或者说接近逆序最好情况下为O(N)，此时待排序列为升序，或者说接近升序。<br>空间复杂度：O(1)</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>插入排序不适用于，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的难以处理大规模数组的问题，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><ul><li><p>先将待排序数组进行与排序，是的待排序数组接近于有序，再对该序列进行一次插入排序</p></li><li><p>eg:<br>  3 2 5 4 1 6(gap = 6)<br>  3 2 5 4 1 6(gap = 6/2 = 3) (3,4)是正序，不需要改变<br>  3 1 5 4 2 6(gap = 3) (2,1)变成（1,2）<br>  3 1 5 4 2 6(gap = 3) (5,6)是正序不需要改变<br>  3/2 = 1,此时用插入排序（若gap = 10，10/2 = 5， 5/2 =2&gt;1,则在以gap = 2进行排序</p></li></ul><pre class=" language-Java"><code class="language-Java">public void sort(T[] nums) {        int N = nums.length;        int h = 1;        while (h < N / 3) {            h = 3 * h + 1; // 1, 4, 13, 40, ...        }        while (h >= 1) {            for (int i = h; i < N; i++) {                for (int j = i; j >= h && less(nums[j], nums[j - h]); j -= h) {                    swap(nums, j, j - h);                }            }            h = h / 3;        }    }</code></pre><p><strong>时间复杂度平均：O(N^1.3)</strong><br><strong>空间复杂度：O(1)</strong></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。</p><pre class=" language-Java"><code class="language-Java">public void sort(int[] nums) {        int N = nums.length;        for (int i = 0; i < N - 1; i++) {            int min = i;            for (int j = i + 1; j < N; j++) {                if (nums[j]< nums[min]) {                    min = j;                }            }            swap(nums, i, min);        }    }</code></pre><p>时间复杂度：最坏情况：<strong>O(N^2)</strong><br>            最好情况：O(N^2)<br>空间复杂度：O(1)</p><ul><li>改进：我们可以一次性选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆是一颗完全二叉树</strong>，可以用数组来表示，因为完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。</p><ul><li>大根堆：所有父节点大于子节点<br>  小根堆：所有父节点小于子节点</li></ul><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><pre class=" language-Java"><code class="language-Java">public class Heap<T extends Comparable<T>> {    private T[] heap;    private int N = 0;    public Heap(int maxN) {        this.heap = (T[]) new Comparable[maxN + 1];    }    public boolean isEmpty() {        return N == 0;    }    public int size() {        return N;    }    private boolean less(int i, int j) {        return heap[i].compareTo(heap[j]) < 0;    }    private void swap(int i, int j) {        T t = heap[i];        heap[i] = heap[j];        heap[j] = t;    }}</code></pre><h4 id="堆的上浮与下沉"><a href="#堆的上浮与下沉" class="headerlink" title="堆的上浮与下沉"></a>堆的上浮与下沉</h4><ul><li>一般采用大根堆–当一个节点比父节点大时，需要交换这两个节点。交换后可能还比它的新的父节点大，因此需要不断地进行比较和交换，这就是上浮操作。</li></ul><p>k/2是父节点</p><pre class=" language-Java"><code class="language-Java">private void swim(int k) {    while (k > 1 && k / 2 < k) {        swap(k / 2, k);        k = k / 2;    }}</code></pre><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><pre class=" language-Java"><code class="language-Java">private void sink(int k) {    while (2 * k <= N) {        int j = 2 * k;        if (j < N && j < j + 1)            j++;        if (k > j)            break;        swap(k, j);        k = j;    }}</code></pre><h4 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h4><ul><li><p>插入：将新元素放到数组末尾，然后上浮到合适的位置</p><pre class=" language-Java"><code class="language-Java">    public void insert(Comparable v) {        heap[++N] = v;        swim(N);    }</code></pre></li><li><p>删除：从堆顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><pre class=" language-Java"><code class="language-Java">    public T delMax() {        T max = heap[1];        swap(1, N--);        heap[N + 1] = null;        sink(1);        return max;    }</code></pre></li></ul><h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本知识</title>
      <link href="/2022/03/16/linux-ji-ben-zhi-shi/"/>
      <url>/2022/03/16/linux-ji-ben-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-环境"><a href="#linux-环境" class="headerlink" title="linux 环境"></a>linux 环境</h2><p>Linux内核的源码开源网站(<a href="http://www.kernel.org/">http://www.kernel.org</a>)<br>Linux常用的发行版本： Ubuntu， CentOs， RedHat</p><h2 id="Linux-目录"><a href="#Linux-目录" class="headerlink" title="Linux 目录"></a>Linux 目录</h2><p>~ home目录<br>/ root目录<br>/lib 系统使用的函数库的沐浴露<br>/etc 系统配置文件村对方的目录<br>/bin 二进制文件存放目录</p><h2 id="Linux-指令"><a href="#Linux-指令" class="headerlink" title="Linux 指令"></a>Linux 指令</h2><h3 id="目录指令"><a href="#目录指令" class="headerlink" title="目录指令"></a>目录指令</h3><p>ls 列出目录下的文件 ls -a 显示包括隐藏目录 ls -l 显示文件的详细信息</p><p>mkdir 创建新的目录 /文件 mkdir -p</p><pre class=" language-Linux"><code class="language-Linux">mkdir test/test01.txt -p</code></pre><p>若不存在test文件夹，会创建test文件夹后创建你test01文件</p><p>touch创建空白文件</p><pre class=" language-Linux"><code class="language-Linux">touch 01.txt</code></pre><p>rm 删除 rm -f强制删除 rm -r删除目录及其下面的子文件</p><p>pwd 查询当前位置</p><p>cd 切换目录</p><p>mv 移动文件</p><p>cp 复制文件，若要同时移动该文件下的子文件要用cp -r</p><h3 id="查看文件中内容"><a href="#查看文件中内容" class="headerlink" title="查看文件中内容"></a>查看文件中内容</h3><p>cat 查看文件内容</p><pre class=" language-Linux"><code class="language-Linux">Cat 1.txt</code></pre><p>查看1文件中的内容</p><p>more 查看大文件内容</p><pre class=" language-Linux"><code class="language-Linux">More 1.txt</code></pre><p>当1为大文件时，可以用more查看，more支持分页查看（space切换下一页，b返回上一页）</p><p>tail 查看追加内容， 其中tail -f可以查看实时更新的结果（ctrl+c结束）<br>可以同时开两个窗口，在第一个窗口输入</p><pre class=" language-Linux"><code class="language-Linux">tail 1.txt</code></pre><p>在第二各窗口输入</p><pre class=" language-Linux"><code class="language-Linux">date >> 1.txt</code></pre><p>查看1文件中新追加的内容(当下时间)</p><p>echo 追加新的内容<br>echo a &gt; 1.txt  直接覆盖于<br>Echo a &gt;&gt; 1.txt 将a插入1.txt 文件的末端<br>echo a会直接将结果打印到控制台上</p><p>Date &gt;&gt; 1.txt 将当前时间插入文件中 date本身用于时间chakan</p><p>Cal 查看日历 cal &gt;&gt; 1.txt 将日历添加到1.txt中</p><h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>将一个命令的执行的结果作为内容提交给下一个命令处理， 类似嵌套</p><pre class=" language-Linux"><code class="language-Linux">    ps -ef | grep 1001</code></pre><h3 id="文件与进程交互命令"><a href="#文件与进程交互命令" class="headerlink" title="文件与进程交互命令"></a>文件与进程交互命令</h3><p>grep 搜索<br>tar 解压</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON配置</title>
      <link href="/2022/01/14/json-pei-zhi/"/>
      <url>/2022/01/14/json-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-项目中以来的配置"><a href="#Maven-项目中以来的配置" class="headerlink" title="Maven 项目中以来的配置"></a>Maven 项目中以来的配置</h2><p>在maven项目中的pom.xml<br>该项目有<br><groupid>com.example</groupid>  //一般是公司名<br><artifactid>project</artifactid>  //一般是项目名<br><version>1.0</version>  </p><p>如果要配置依赖，需要在所有依赖外面先加dependencies，如</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>jdk15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>若配置了依赖，maven install时仍然报错，勾选settings-&gt;buid,execution,deployment中buol tolls下的maven下的runner，勾选嘴上的delegate IDE build/run action to Maven</p><p><img src="/img/posts/config/trust_maven.jpg" alt="Delegate IDE build/run action to Maven"></p><p>记得配置maven的setting file和repository</p><h2 id="配置JSON"><a href="#配置JSON" class="headerlink" title="配置JSON"></a>配置JSON</h2><p>在maven项目中的pom文件中先配置相关依赖</p><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后到java程序中</p><pre class=" language-JAVA"><code class="language-JAVA">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协同过滤推荐算法</title>
      <link href="/2021/12/01/xie-tong-guo-lu-tui-jian-suan-fa/"/>
      <url>/2021/12/01/xie-tong-guo-lu-tui-jian-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>协同过滤(collaborative filtering)算法</p><h2 id="基于内容的推荐系统"><a href="#基于内容的推荐系统" class="headerlink" title="基于内容的推荐系统"></a>基于内容的推荐系统</h2><p><img src="/img/posts/MachineLearning/recommend_system0.jpg" alt="4人对于5门电影的打分表，x1,x2表示电影的特征"></p><p>把每个用户的评分看作一个线性回归问题，对用户评分进行预测，不同的用户与不同的参数$\theta$相关</p><h2 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h2><ul><li>特征学习：可以自动学习所要使用的特征</li></ul><p>用户有一定的特征变量，并且已知用户对部分商品的兴趣</p><p>仍然是这个例子</p><p><img src="/img/posts/MachineLearning/recommend_system1.jpg" alt="现在不知道x1，x2的倾向"></p><p>但是已知用户对于romance和action电影的喜爱度，$\theta^{(1)}$是Alice的特征，由此可知她对于romance电影的喜爱度为5，action的喜爱程度为0，$\theta^{(3)}$是Carol的特征，由此可知她对于romance电影的喜爱度为0，action的喜爱程度为5。</p><p><img src="/img/posts/MachineLearning/recommend_system2.jpg" alt="用户特征"></p><p>由此我们得出，需要满足以下条件：<br>$$(\theta^{(1)})x^{(1)} = 5$$<br>$$(\theta^{(2)})x^{(1)} = 5$$<br>$$(\theta^{(3)})x^{(1)} = 0$$<br>$$(\theta^{(4)})x^{(1)} = 0$$</p><p>所以<br>$$ x^{(1)}  =  \begin{bmatrix}1 &amp; 1.0 &amp; 0.0 \end{bmatrix}$$<br>第一项是截距项</p><h3 id="算法推导过程"><a href="#算法推导过程" class="headerlink" title="算法推导过程"></a>算法推导过程</h3><p>如果用户已经给了我们偏好–特征$\theta^{(1)}$,$\theta^{(2)}$…$\theta^{(n)}$对$x^{(i)}$进行学习，我们要做的是求出：</p><p>$$\min \frac{1}{2} \displaystyle \sum_{j:r(i,j)=1}({(\theta^{(j)})}^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)})^2$$</p><p>这一步要做的是选择一个特征$x^{(i)}$，算法根据所有评价过电影的用户计算出一个值来预测某个用户会如何评价这部电影<br>$\frac {\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)}$是一个正则项，防止特征值过大</p><p>为了学习所有电影的所有特征，也就是学习$x^{(1)},x^{(2)}…x^{(n_m)}$\，需要求出<br><img src="/img/posts/MachineLearning/recommend_system_equation.jpg"></p><p>$\displaystyle \sum_{i=1}^{n_m}$是对所有电影求和</p><h3 id="算法作用"><a href="#算法作用" class="headerlink" title="算法作用"></a>算法作用</h3><ul><li><p>可以通过用户喜爱程度$\theta^{(1)},\theta^{(2)}…\theta^{(n_u)}$来预测电影的特征$x^{(1)}…x^{(n_m)}$</p></li><li><p>也可以通过电影特征$x^{(1)}…x^{(n_m)}$来预测用户喜爱程度$\theta^{(1)},\theta^{(2)}…\theta^{(n_u)}$</p></li></ul><p>可以通过先随机地选取一些$\theta$地值来学习出不同电影地特征，在得到电影特征之后，再通过这些特征来预测另外的$\theta$值（用户喜爱程度，再根据这些$\theta$来预测电影特征…如此反复，最终将会收敛到一组合理的电影特征以及合理的对用户地预测</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>将$x^{(1)},x^{(2)}…x^{(n_m)}$,$\theta^{(1)},\theta^{(2)}…\theta{(n_u)}$初始化为一些小地随机出</p></li><li><p>使用梯度下降将代价函数最小化，</p></li></ol><p><img src="/img/posts/MachineLearning/recommend_system3.jpg" alt="括号内的内容是对代价函数地偏导"></p><ol start="3"><li>用一些有参数$\theta$的用户和有特征$x$的电影，来预测用户评分$\theta^Tx$</li></ol><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><p>用户对电影评分可以写成如图所示评分矩阵<br><img src="/img/posts/MachineLearning/recommend_system4.jpg"></p><p>该评分矩阵的实质是$\theta^{(j)}*x^{(i)}$</p><p><img src="/img/posts/MachineLearning/recommend_system5.jpg"></p><p>如果要给用户推荐相似的电影，可以通过两个电影之间的距离来判断，如果电影$x^{(i)}$与$x^{(j)}$非常相近，那么可以把$x^{(j)}$推荐给喜欢$x^{(i)}$的人</p><h2 id="协同过滤算法中的均值归一化"><a href="#协同过滤算法中的均值归一化" class="headerlink" title="协同过滤算法中的均值归一化"></a>协同过滤算法中的均值归一化</h2><p>对于没有看过电影的人，或者那些给所有电影都打分为零分的人，很难推荐电影给他们。可以通过已知用户对于电影的打分，计算出该电影的均分，最后生成均分矩阵<br>$$\mu = \begin {bmatrix} \mu_1 &amp; \mu_2 &amp; …&amp; \mu_n \end {bmatrix} $$</p><p><img src="/img/posts/MachineLearning/recommend_system6.jpg" alt="5个电影的评分矩阵如图，但不知道最后一个人对于每个电影的打分"></p><p><img src="/img/posts/MachineLearning/recommend_system7.jpg" alt="通过计算均值，得到了每个电影的均分矩阵"></p><p><img src="/img/posts/MachineLearning/recommend_system8.jpg" alt="原评分矩阵中的元素减去对应的均值后，德奥新的评分矩阵"></p><p>将均一化后的矩阵作为额数据集进行$\theta^{(j)}$参数的学习，预测函数为：<br>$${(\theta^{(j)})}^T{(X^{(i)})}+\mu_i$$</p><p>对于没有打分的用户5<br>$$\theta^{(5)} = \begin {bmatrix}0 &amp; 0 \end {bmatrix}$$</p><p>最终用户5的打分为 $\mu_i$</p><p><strong>可用于解决用户冷启动问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 协同过滤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python实现的PING功能</title>
      <link href="/2021/11/28/ji-yu-python-shi-xian-de-ping-gong-neng/"/>
      <url>/2021/11/28/ji-yu-python-shi-xian-de-ping-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是PING"><a href="#什么是PING" class="headerlink" title="什么是PING"></a>什么是PING</h2><p>ping通常用于测试网络连通，再命令行输入ping 目标主机地址， 得到回复如下：</p><p><img src="/img/posts/Ping/ping_cmd.jpg" alt="ping"></p><p>其中的数据内容如下：</p><p>bytes值：字节数，也就是数据包大小。</p><p>time值：响应时间，这个时间越小，说明连接速度越快。</p><p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p><p>默认情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255。</p><p>因此一般TTL值：</p><p>100~130ms之间，Windows系统 ；</p><p>240~255ms之间，UNIX/Linux系统。</p><h2 id="ping的步骤"><a href="#ping的步骤" class="headerlink" title="ping的步骤"></a>ping的步骤</h2><p>完整代码见：<a href="https://github.com/ClaireYuj/PING-Traceroute/blob/main/ICMPPing.py">PING</a></p><p>解析主机并，进行多次ping操作，输出结果，判断最终结果并输出四个步骤<br>ping的代码如下</p><pre class=" language-Python"><code class="language-Python">def ping(host, timeout=1):    """    do the ping use doOnePing method in a while loop, and show the details    :param host:    :param timeout:    :return:    """    # 1. Look up hostname, resolving it to an IP address    # 2. Call doOnePing function, approximately every second    # 3. Print out the returned delay    # 4. Continue this process until stopped    try:        destinationAddress = socket.gethostbyname(host)    except Exception as e:        print(e)        print(" Error on extract the hostname")        return    print(" Ping {0} [{1}] with 32 bytes of data:".format(host, destinationAddress))    lost = 0    accept = 0    timesum = 0.0    count = 4    times = []    ttl = 0    for i in range(count):        sequence = i        delay, ttl = doOnePing(destinationAddress, timeout)        if delay < 0:            if delay == -1:                print(" %s The request is overtime ...... can not receive the icmpPacket " % delay)                lost += 1                times.append(delay * 1000)            elif delay == -3:                print("3 The destination is unreachable")            elif delay == -11:                print("11 Overtime")            else:                print("%s failed......." %delay)        else:            delay = delay * 1000            print("reply from {0} : byte=32 seq = {1} time={2:.2f}ms ttl = {3} ".format(destinationAddress, sequence, delay, ttl))            accept += 1            timesum += delay            times.append(delay) # all the time        time.sleep(1)    print('packet: send = {0}，received = {1}，loss= {2} ({3}% loss) \n\    Estimated round trip time: min = {4:.2f}ms，max = {5:.2f}ms，average = {6:.2f}ms'.format(        count, accept, lost, lost / (lost + accept) * 100, min(times),        max(times), sum(times) // (lost + accept)    ))</code></pre><h3 id="进行一次ping"><a href="#进行一次ping" class="headerlink" title="进行一次ping"></a>进行一次ping</h3><p>ping命令共输出四次ping的结果，其中一次ping的结果如下</p><pre class=" language-Python"><code class="language-Python">def doOnePing(destinationAddress, timeout):    """    create the ICMP socket, then call the sendOnePing and receiveOnePing method in sequence    :param destinationAddress:    :param timeout:    :return totalDelay, ttl:    """    # 1. Create ICMP socket    icmpSocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.getprotobyname("icmp"))    dataID = os.getpid() & 0xFFFF    # 2. Call sendOnePing function    icmpPacket, sendtime = sendOnePing(icmpSocket, destinationAddress, dataID)    # 3. Call receiveOnePing function    totalDelay, ttl = receiveOnePing(icmpSocket, destinationAddress, dataID, timeout, sendtime)    # 4. Close ICMP socket    icmpSocket.close()    # 5. Return total network delay    return totalDelay, </code></pre><h3 id="发出ping请求"><a href="#发出ping请求" class="headerlink" title="发出ping请求"></a>发出ping请求</h3><p>每次ping需要发出请求以及接收请求两个步骤</p><pre class=" language-Python"><code class="language-Python">  """    build the icmp header, and pack the checksum in header    record the time to send packet    :param icmpSocket:    :param destinationAddress:    :param ID:    :return icmpPacket, sendTime:    """def sendOnePing(icmpSocket, destinationAddress, ID):      # 1. Build ICMP header    ip = socket.gethostbyname(destinationAddress)    icmpChecksum = 0    icmpHeader = struct.pack(">BBHHH", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1) #htons - trans the byte sequence of host nto network byte order    # 2. Checksum ICMP packet using given function    data = struct.pack(">d", time.time())    icmpChecksum = checksum(icmpHeader + data)    # 3. Insert checksum into packet    # icmpHeader = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1)    icmpHeader = struct.pack(">BBHHH", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1) # B-unsigned char h -short    icmpPacket = icmpHeader + data    # 4. Send packet using socket    icmpSocket.sendto(icmpPacket, (ip, 80))    #  5. Record time of sending    sendTime = time.time()    return icmpPacket, sendTime</code></pre><p>checksum是checksum意思是较验和，就是将一段已有长度的数据按照某种整数类型(通常是16位无符号整数)进行累加(进位部分再继续加到低位)，累加后的结果再取反以用于校验。具有校验合的数据包再次进行校验后结果则为0。</p><pre class=" language-Python"><code class="language-Python">def checksum(string):    csum = 0    countTo = (len(string) // 2) * 2    count = 0    while count < countTo:        thisVal = string[count + 1] * 256 + string[count]        csum = csum + thisVal        csum = csum & 0xffffffff        count = count + 2    if countTo < len(string):        csum = csum + string[len(string) - 1]        csum = csum & 0xffffffff    csum = (csum >> 16) + (csum & 0xffff)    csum = csum + (csum >> 16)    answer = ~csum    answer = answer & 0xffff    answer = answer >> 8 | (answer << 8 & 0xff00)    answer = socket.htons(answer)    return answer</code></pre><h3 id="接收ping请求"><a href="#接收ping请求" class="headerlink" title="接收ping请求"></a>接收ping请求</h3><pre class=" language-Python"><code class="language-Python">"""    wait the socket to receive the reply by select.select, calculate the time to receive the packet    :param icmpSocket:    :param destinationAddress:    :param ID:    :param timeout:    :param startTime:    :return delay, ttl:    """def receiveOnePing(icmpSocket, destinationAddress, ID, timeout, startTime):        # 1. Wait for the socket to receive a reply    while True:        what_ready = select.select([icmpSocket], [], [], timeout)        receivedTime = time.time()        # 2. Once received, record time of receipt, otherwise, handle a timeout        if what_ready[0] == []:            return -1, 0        # 3. Compare the time of receipt to time of sending, producing the total network delay        else:            delay = receivedTime - startTime        # 4. Unpack the packet header for useful information, including the ID        recPacket, addr = icmpSocket.recvfrom(1024)        icmpHeader = recPacket[20: 28]        # ip_type, code, checksum, packet_ID, sequence = struct.unpack("<bbHHh", icmpHeader)        icmpType, icmpCode, icmpChecksum, icmpPacketID, icmpSequence = struct.unpack(">BBHHH", icmpHeader)        ipversion, iptype, iplength, ipid, ipflags, ipttl, ipprotocol, ipchecksum, ipsrc_ip, ipdest_ip = struct.unpack(            "!BBHHHBBHII", recPacket[:20])        # 5. Check that the ID matches between the request and reply        if icmpType == ICMP_ECHO_REPLY and icmpPacketID == ID:            # 6. Return total network delay            return delay, ipttl        elif icmpType == ICMP_UNREACHED:            return -3, 0        elif icmpType == ICMP_OVERTIME:            return -11, 0        else:            return -2, 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Idea的SpringBoot项目搭建</title>
      <link href="/2021/11/17/ji-yu-idea-de-springboot-xiang-mu-da-jian/"/>
      <url>/2021/11/17/ji-yu-idea-de-springboot-xiang-mu-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Spring-Boot-Helper插件"><a href="#安装Spring-Boot-Helper插件" class="headerlink" title="安装Spring Boot Helper插件"></a>安装Spring Boot Helper插件</h2><p>File &gt; Settings &gt; Plugins &gt;</p><p>安装好之后File &gt; new &gt; Spring Initializr &gt; 此时注意到选择初始化服务器的defalut那有一个start.spring.io<br>File &gt; Appearance $ Beahavior &gt; System Settings &gt;HTTP Proxy &gt; 选择 Auto-detect后点击左下角的check connection按钮，输入<a href="http://start.spring.io/">http://start.spring.io</a></p><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>版本选择 2.2.6.RELEASE<br>包的名字记得改</p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p>File &gt; Buil, Execution, Deployment &lt; Build Tools &gt; Maven 配置maven的setting.xml于repository， 在maven的安装路径下conf文件夹中找到settings.xml，再在maven根目录新建repository文件夹，并在 setting.xml 文件中添加（找到repository注释下一行，进行添加）</p><pre class=" language-XML"><code class="language-XML">    <localRepository>        D:\Environment\Maven\apache-maven-3.2.5\store        </localRepository></code></pre><p>此处地址为自己创建的repository的地址</p><p>再找到mirror<br>将原代码更换为</p><pre class=" language-XML"><code class="language-XML">    <mirror>        <id>alimaven</id>        <name>aliyun maven</name>        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>        <mirrorOf>central</mirrorOf>               </mirror> </code></pre><p>再重新生成maven项目，拉开idea右侧maven栏，点击左上角刷新按钮</p><h3 id="报错java-程序包org-springframework-boot不存在"><a href="#报错java-程序包org-springframework-boot不存在" class="headerlink" title="报错java: 程序包org.springframework.boot不存在"></a>报错java: 程序包org.springframework.boot不存在</h3><p>是依赖库仓库出现问题，cd到该项目目录下，mvn idea:idea 重新安装依赖即可</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA输入输出</title>
      <link href="/2021/11/17/java-shu-ru-shu-chu/"/>
      <url>/2021/11/17/java-shu-ru-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-I-x2F-O"><a href="#JAVA-I-x2F-O" class="headerlink" title="JAVA I/O"></a>JAVA I/O</h1><p>在Java程序中要读取外部IO设备中的内容，要求先将数据传输到内存中，这一步需要借助操作系统实现。<br>JDK中提供的IO操作框架，根据流的传输方向和读取单位分为字节流InputStream和outputSteam以及字符流Reader和Writer</p><p>字节流一次<strong>读取一个字节</strong>（1 byte）<br>字符流一次<strong>读取一个字符</strong>（1 char =  2 byte）</p><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><p>头文件</p><pre class=" language-Java"><code class="language-Java">import java.io.FileInputStream;import java.io.FileNotFoundException;</code></pre><h3 id="创建输入流"><a href="#创建输入流" class="headerlink" title="创建输入流"></a>创建输入流</h3><pre class=" language-Java"><code class="language-Java">try{    FileInputStream inputStream = new FileInputStream("test.txt"); }catch(FileNotFoundException e){    e.printStackTrace();}</code></pre><p>在使用完成后，要关闭流进行资源释放，在catch后加入finally</p><pre class=" language-Java"><code class="language-Java">        FileInputStream inputStream = null;        try{            inputStream = new FileInputStream("test.txt");        }catch (FileNotFoundException e){            e.printStackTrace();        }finally {            try{                if(inputStream !=null) inputStream.close();            }catch (IOException e){                e.printStackTrace();            }        }</code></pre><p><strong>但这样过于繁琐，尝试以下面方式进行简化</strong></p><pre class=" language-Java"><code class="language-Java">    try(FileInputStream inputStream  = new FileInputStream("test.txt")){                }catch (FileNotFoundException e){            e.printStackTrace();    }</code></pre><p>将inputStream的初始化放到的括号中且不报错，原因是InputStream这个抽象类使用了Closeable的接口<br>而Closeable接口继承了AutoCloseable，如果一个对象是在try-with-resource(在JDK7中引入，JDK9中改进)代码块中生命的，则AutoCloseable的对象的close()方法会自动执行<br>字节流，字符流等都可以直接使用</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>inputStream.read() 一次读取一个英文字母（读的是ASCII码，需要char转换）</p><p>一次性全部读完</p><pre class=" language-Java"><code class="language-Java">try( FileInputStream inputStream = new FileInputStream("test.txt")){            int tmp;            while((tmp = inputStream.read()) != -1){                System.out.println((char)tmp);            }        }catch (IOException e){            e.printStackTrace();        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口协议</title>
      <link href="/2021/11/11/hua-dong-chuang-kou-xie-yi/"/>
      <url>/2021/11/11/hua-dong-chuang-kou-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><ul><li><p>是<strong>TCP协议</strong>的一种，用于数据传输时的流量控制，避免拥塞的发送。  </p></li><li><p>滑动窗口协议允许发送方在在收到确认之前发送多个数据分组，因此<strong>发送方不必没收到一个分组就停下来等待确认</strong>，因此该协议可以加速数据的传输，提高网络吞吐量。</p></li><li><p>如果多个客户端向服务器发送到大量数据包，但服务器没有足够的接收这么多数据包的能力，那么会导致拥塞的发生。因此我们需要控制发送方的发送速度，控制它不要发送过快。</p></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><p>窗口：允许使用的序列号范围</p><ul><li>窗口尺寸： 若窗口尺寸为n，意味着最多有n个等待确认的消息</li></ul></li><li><p>滑动窗口： 随着协议的运行，窗口在序列号范围内向前移动  </p></li><li><p>滑动窗口协议： GBN，SR</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据传输 </tag>
            
            <tag> 流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode--树相关</title>
      <link href="/2021/10/17/leetcode-shu-xiang-guan/"/>
      <url>/2021/10/17/leetcode-shu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="树的特征"><a href="#树的特征" class="headerlink" title="树的特征"></a>树的特征</h2><p>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一颗树。图的生成树森林是它的所有连通子图的生成树的集合。</p><p>有多个子节点，层层递归（一般是二叉树）<br>二叉树的定义如下</p><pre class=" language-Java"><code class="language-Java"> public class TreeNode {     int val;     TreeNode left;     TreeNode right;     TreeNode(int x) { val = x; } }</code></pre><h2 id="剑指Offer25-树的子结构"><a href="#剑指Offer25-树的子结构" class="headerlink" title="剑指Offer25. 树的子结构"></a>剑指Offer25. 树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br><img src="/img/posts/Leetcode/offer26.jpg"><br>前序遍历，从A树和B树相同的结点开始，B树的左子树 = A树的左子树；A树的右子树 = B树的右子树<br>结束条件==》B树符合A树左子树条件||A树 = null</p><pre class=" language-Java"><code class="language-Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public boolean isSubStructure(TreeNode A, TreeNode B) {        if(A==null||B==null) return false;        return travel(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B); // 从该节点开始遍历||判断从A的左节点开始遍历，B是不是A的左子树的子结构|| 判断B是不是A的右子树的子结构    }    public boolean travel(TreeNode A, TreeNode B){        if(B == null) return true; // 表示在B为null前A与B 的val一直相等        else if(A == null && B != null) return false;        else if(A.val != B.val) return false;        return travel(A.left, B.left)&&travel(A.right, B.right); // 分辨遍历左右子树    }}</code></pre><h2 id="Offer27-二叉树的镜像"><a href="#Offer27-二叉树的镜像" class="headerlink" title="Offer27.二叉树的镜像"></a>Offer27.二叉树的镜像</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">请完成一个函数，输入一个二叉树，该函数输出它的镜像</a><br><img src="/img/posts/Leetcode/offer27.jpg"></p><ul><li>思路： 从根的叶结点开始， 一个一个交换左右子树，一直到为null</li></ul><pre class=" language-Java"><code class="language-Java">    class Solution {    public TreeNode invertTree(TreeNode root) {        if(root == null ) return null;        TreeNode tmp = root.left;        root.left = root.right;        root.right = tmp;        invertTree(root.right);        invertTree(root.left);        return root;    }}</code></pre><h2 id="Offer28-对称的二叉树"><a href="#Offer28-对称的二叉树" class="headerlink" title="Offer28.对称的二叉树"></a>Offer28.对称的二叉树</h2><p><img src="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d412v/"><br>依旧是递归，不过考虑到判断对称，要求：<br>左子树的左子树等于右子树的右子树，右子树的左子树=左子树的右子树，依次递归</p><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isSymmetric(TreeNode root) {        if(root == null) return true;        TreeNode left = root.left;        TreeNode right = root.right;        if(left!=null&&right!=null&&right.val==left.val){            return travel(left,right);        }        else if(left == null &&right==null)return true;        else return false;    }    public boolean travel(TreeNode left, TreeNode right){        if(left==null&&right==null) return true;        if(left!=null&&right!=null&&left.val!=right.val) return false;        else if(left==null||right==null) return false;        return travel(left.left,right.right)&&travel(right.left,left.right);    }}</code></pre><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p><img src="/img/posts/Leetcode/leetcode94.jpg" alt="Leetcode94"></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>中序遍历 左-&gt;中-右</p><pre class=" language-JAVA"><code class="language-JAVA">class Solution {    public List<Integer> inorderTraversal(TreeNode root) {        List<Integer> tree = new ArrayList<Integer>();        inOrder(root,tree);        return tree;            }    public void inOrder(TreeNode root,List<Integer> tree){        if(root==null){            return;        }        inOrder(root.left,tree);        tree.add(root.val);        inOrder(root.right,tree);    }}</code></pre><h2 id="95-不同的二叉搜索树"><a href="#95-不同的二叉搜索树" class="headerlink" title="95.不同的二叉搜索树"></a>95.不同的二叉搜索树</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br>（不只返回数字）</p><h3 id="解法一-DFS-深度优先"><a href="#解法一-DFS-深度优先" class="headerlink" title="解法一:DFS 深度优先"></a>解法一:DFS 深度优先</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List<TreeNode> generateTrees(int n) {        if(n == 0) return new ArrayList<TreeNode>();        return helper(1, n);     }     List<TreeNode> helper(int start, int end){        List<TreeNode> list = new ArrayList<>();        if(start > end) list.add(null);                for(int i = start; i <= end; i++){            List<TreeNode> left = helper(start, i - 1);            List<TreeNode> right = helper(i + 1, end);                        for(int j = 0; j < left.size(); j++){                for(int k = 0; k < right.size(); k++){                    TreeNode root = new TreeNode(i);                    root.left = left.get(j);                    root.right = right.get(k);                    list.add(root);                }            }        }        return list;      }}  </code></pre><h3 id="解法二：DP-动态规划"><a href="#解法二：DP-动态规划" class="headerlink" title="解法二：DP 动态规划"></a>解法二：DP 动态规划</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int numTrees(int n) {        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;                for(int i = 2; i < n + 1; i++)            for(int j = 1; j < i + 1; j++)                 dp[i] += dp[j-1] * dp[i-j];                return dp[n];    }}</code></pre><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    //判断无向图是否有换，以及是否为单连通分量    //当只有n-1条边，且连通数为1时，符合条件    public boolean validTree(int n, int[][] edges) {        if(edges.length+1 != n) //只应该有n-1条边            return false;        int[] par = new int[n];        int par1 = 0,par2 = 0;        for(int i=0;i<n;i++)            par[i]=i; //并查集，每个点的父节点是自己        for(int i=0;i<edges.length;i++){            par1 = edges[i][0];            par2 = edges[i][1];            //不断向上寻找得到par1和par2的祖先节点            while(par1 != par[par1])                par1 = par[par1];             while(par2 != par[par2])                par2 = par[par2];            //par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--            if(par1 != par2){                par[par2] = par1;                n--;            }        }        return n == 1;            }}</code></pre><h2 id="515-在二叉树的每一行中找到最大的值。"><a href="#515-在二叉树的每一行中找到最大的值。" class="headerlink" title="515. 在二叉树的每一行中找到最大的值。"></a>515. 在二叉树的每一行中找到最大的值。</h2><h3 id="解法：BFS-广度优先"><a href="#解法：BFS-广度优先" class="headerlink" title="解法：BFS 广度优先"></a>解法：BFS 广度优先</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List<Integer> largestValues(TreeNode root) {        List<Integer> rlist = new ArrayList<>();        if(root==null) return rlist;                List<TreeNode> nodeList = new LinkedList<>();        nodeList.add(root);        while(!nodeList.isEmpty()){            int size = nodeList.size();            int max = nodeList.get(0).val;            for(int i = 0;i< size;i++){                TreeNode node = nodeList.remove(0);                max = Math.max(node.val,max);                if(node.left!=null) nodeList.add(node.left);                if(node.right!=null) nodeList.add(node.right);            }            rlist.add(max);        }        return rlist;            }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA常见容器</title>
      <link href="/2021/10/14/java-chang-jian-rong-qi/"/>
      <url>/2021/10/14/java-chang-jian-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterable被Collection所继承。它只有一个方法： Iterator<t> iterator() </t></p><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为<strong>“轻量级”</strong>对象，因为创建它的代价小。</p><p>Java中的Iterator功能比较简单，并且只能单向移动：<br>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br>　　(2) 使用next()获得序列中的下一个元素。<br>　　(3) 使用hasNext()检查序列中是否还有元素。<br>　　(4) 使用remove()将迭代器新返回的元素删除。</p><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>一般不会直接实现collection接口，而是实现它的子类</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><em><strong>有序的，可重复的</strong></em><br>List是有序的 collection子接口。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>用户插入的顺序或者指定的位置就是元素插入的位置。它与Set不同，List允许插入重复的值。</p><p>List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法(如下)来获取从列表中指定位置开始的列表迭代器。</p><p>ListIterator <e> listIterator(int index)<br>返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始</e></p><p>List 接口提供了两种搜索指定对象的方法。从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。</p><p>List 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><em><strong>无序的，不可重复的</strong></em></p><p>java的集合和数学的集合一样，集合的无序性，确定性，单一性。所以可以很好的理解，Set是无序、不可重复的。同时，如果有多个null，则不满足单一性了，Set只能有一个null。<br>Set判断两个对象相同不是使用”==”运算符，<strong>而是根据equals方法</strong>。——因为Set的这个制约，在使用Set集合的时候，应该注意两点：<br>为Set集合里的元素的实现类实现一个有效的equals(Object)方法；<br>对Set的构造函数，传入的Collection参数不能包含重复的元素。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><em><strong>有序的，可重复的</strong></em><br>用于模拟“队列”数据结构（FIFO）。新插入的元素放在队尾，队头存放着保存时间最长的元素。</p><p>Queue的子类、子接口<br>1.1） PriorityQueue—— 优先队列（类）<br>其实它并没有按照插入的顺序来存放元素，而是按照队列中某个属性的大小来排列的。故而叫优先队列。</p><p>1.2） Deque——双端队列（接口）<br>1.2.1）ArrayDeque（类）<br>基于数组的双端队列，类似于ArrayList有一个Object[] 数组。<br>1.2.2）LinkedList （类）</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map不是collection的子接口或者实现类，Map是一个接口。</p><p>Map用于保存具有“映射关系”的数据。每个Entry都持有<strong>键-值</strong>两个对象。其中，Value可能重复，但是Key不允许重复（和Set类似）。</p><p>Map可以有多个Value为null，但是只能有一个Key为null</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在hexo的matery主题下显示数学公式</title>
      <link href="/2021/09/29/zai-hexo-de-matery-zhu-ti-xia-xian-shi-shu-xue-gong-shi/"/>
      <url>/2021/09/29/zai-hexo-de-matery-zhu-ti-xia-xian-shi-shu-xue-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>Markdown中激活mathjax插件，并使用数学公式，如矩阵与各种数学符号</p><h2 id="激活mathjax插件"><a href="#激活mathjax插件" class="headerlink" title="激活mathjax插件"></a>激活mathjax插件</h2><p>主题config.yml文件里找到mathjax,改为true<br>由于mathjax的渲染时间较长，故勾选全局mathjax为true后还需要在每篇文章的最上方输入mathjax:true</p><p>此时就可以输入数学公式了，以矩阵为例</p><p>输入</p><pre class=" language-Latex"><code class="language-Latex">$$\begin{bmatrix}                     1&1&0\\                                     1&0&1\\        \end{bmatrix}$$</code></pre><p>以$$\begin开始,以\end{}$$结束<br>但由于matery主题的限制，矩阵不会换行，因此考虑使用markdown it Plus代替Marked渲染器</p><h2 id="利用Katex"><a href="#利用Katex" class="headerlink" title="利用Katex"></a>利用Katex</h2><pre class=" language-shell"><code class="language-shell">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save</code></pre><p>卸载marked，安装markdown-it-plus</p><pre class=" language-shell"><code class="language-shell">npm un hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save</code></pre><p>也可以考虑吧直接用升级版</p><p>再修改hexo的config.yml文件</p><pre class=" language-yml"><code class="language-yml">markdown_it_plus:  render:    html: true    xhtmlOut: false    breaks: true    linkify: true    typographer: true    quotes: '“”‘’'  plugins:  anchors:    level: 2    collisionSuffix: 'v'    permalink: true    permalinkClass: header-anchor    permalinkSide: 'left'    permalinkSymbol: ¶</code></pre><p>就完成了配置<br>可以用</p><pre class=" language-Latex"><code class="language-Latex">$$\begin{bmatrix}                     1&1&0\\                                     1&0&1\\        \end{bmatrix}$$</code></pre><p>再测试一下，此时的matrix会分行了</p><h2 id="Markdown数学公式的使用"><a href="#Markdown数学公式的使用" class="headerlink" title="Markdown数学公式的使用"></a>Markdown数学公式的使用</h2><h3 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{equation}公式\\公式\\\end{equation}$$</code></pre><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p><strong>^</strong>表示上标，**_<strong>表示下标，需要用</strong>{}** </p><pre class=" language-Latex"><code class="language-Latex">$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</code></pre><p>结果<br><img src="/img/posts/Markdown/index.jpg" alt="结果"></p><h3 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{matrix}0&1&1\\1&1&0\\1&0&1\\\end{matrix}$$</code></pre><p><img src="/img/posts/Markdown/matrix0.jpg" alt="矩阵表示"></p><p>在起始、结束标记用下列词替换 matrix</p><ul><li>pmatrix：小括号边框</li><li>bmatrix：中括号边框</li><li>Bmatrix：大括号边框</li><li>vmatrix：单竖线边框</li><li>Vmatrix：双竖线边框</li></ul><p><img src="/img/posts/Markdown/matrix1.jpg" alt="边框矩阵表示"></p><h3 id="方程组表示"><a href="#方程组表示" class="headerlink" title="方程组表示"></a>方程组表示</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{cases}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\\\end{cases}$$</code></pre><p><img src="/img/posts/Markdown/equation0.jpg" alt="方程组表示"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-栈相关</title>
      <link href="/2021/09/09/leetcode-zhan-xiang-guan/"/>
      <url>/2021/09/09/leetcode-zhan-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>栈在JAVA中，可以用LinkedList来表示</p><p>LinkedList<integer> A = new LinkedList<integer>(); </integer></integer></p><ul><li>栈中加入元素<br>  A.add(a);</li><li>栈中移除元素<br>  A.removeLast();</li></ul><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d3i87/">https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d3i87/</a></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )</p><p><img src="/img/posts/Leetcode/offer09.jpg" alt="剑指offer09"></p><pre class=" language-Java"><code class="language-Java">/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */class CQueue {    LinkedList<Integer> A;    LinkedList<Integer> B;    public CQueue() {        A = new LinkedList<Integer>();        B = new LinkedList<Integer>();    }        public void appendTail(int value) {        A.add(value);    }        public int deleteHead() {        if(!B.isEmpty()) return B.removeLast();        if(A.isEmpty()) return -1;        while(!A.isEmpty())            B.add(A.removeLast());        return B.removeLast();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-链表相关</title>
      <link href="/2021/08/28/leetcode-lian-biao-xiang-guan/"/>
      <url>/2021/08/28/leetcode-lian-biao-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9pdjbm/">剑指Offer24.反转链表</a></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>如：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h3 id="解法一，头插：用一个节点暂存"><a href="#解法一，头插：用一个节点暂存" class="headerlink" title="解法一，头插：用一个节点暂存"></a>解法一，头插：用一个节点暂存</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {        if(head==null) return head;        ListNode reve = new ListNode(head.val);        ListNode tmp = null;        while(head.next!=null){            tmp = new ListNode(head.next.val);            tmp.next = reve;            reve = tmp;            head = head.next;        }        return reve;    }}</code></pre><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public ListNode reverseList(ListNode head) {        return recur(null,head);    }    public ListNode recur(ListNode cur,ListNode head){        if(head==null) return cur; //递归终止条件，所以最后返回的是cur        ListNode res = recur(head,head.next);        head.next = cur; //        return res;    }}</code></pre><h2 id="赋值带随机指针的链表"><a href="#赋值带随机指针的链表" class="headerlink" title="赋值带随机指针的链表"></a>赋值带随机指针的链表</h2><p><img src="/img/posts/Leetcode/leetcode138.jpg" alt="Leetcode138"></p><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9plk45/">解法</a></p><h3 id="解法一：拼接-拆分"><a href="#解法一：拼接-拆分" class="headerlink" title="解法一：拼接+拆分"></a>解法一：拼接+拆分</h3><p>将原链表假设为1-&gt;2-&gt;3复制<br>1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null<br>这样cur-&gt;random-&gt;next = cur-&gt;next-&gt;random<br>比如如果1-&gt;random = 3,那么1-&gt;random = 3, 3-&gt;next = 3 ===&gt;1-&gt;random-&gt;next = 3, 且1-&gt;next = 1, 1-&gt;random = 3 ===&gt; 1-&gt;next-&gt;random = 3, 所以cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</p><pre class=" language-JAVA"><code class="language-JAVA">/*// Definition for a Node.class Node {    int val;    Node next;    Node random;    public Node(int val) {        this.val = val;        this.next = null;        this.random = null;    }}*/class Solution {    public Node copyRandomList(Node head) {        if(head == null) return head;        Node cur = head;        Node p = cur;        //1. 复制节点并拼接        while(cur!=null){             Node copy = new Node(cur.val);  //复制该节点            copy.next = cur.next; //连接copy节点的next            cur.next = copy; //关联该节点与复制节点            cur = copy.next; //移动指针        }        // 2.构建random,使得cur->random->next = cur->next->random        cur = head; // java中对象传递是引用传递        while(cur!=null){            if(cur.random!=null){                cur.next.random = cur.random.next;              }            cur = cur.next.next;        }        // 3. 将random拆出来        cur = head.next;        Node pre = head,res=head.next;        while(cur.next!=null){            /**注意pre和cur节点的顺序， pre要在cur之前，             */            pre.next = pre.next.next;             cur.next = cur.next.next;            pre = pre.next;            cur = cur.next;                             }        pre.next = null;        return res;    }}</code></pre><h3 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维护博客所遇到的问题汇总</title>
      <link href="/2021/08/18/wei-hu-bo-ke-suo-yu-dao-de-wen-ti-hui-zong/"/>
      <url>/2021/08/18/wei-hu-bo-ke-suo-yu-dao-de-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="链接到本地图片"><a href="#链接到本地图片" class="headerlink" title="链接到本地图片"></a>链接到本地图片</h2><p>在source下创建img文件夹，每次引用都是/img…</p><h2 id="上传图片加载不出来，但在本地预览可以显示"><a href="#上传图片加载不出来，但在本地预览可以显示" class="headerlink" title="上传图片加载不出来，但在本地预览可以显示"></a>上传图片加载不出来，但在本地预览可以显示</h2><p>图片格式最好选用jpg而不是png</p><h2 id="无法解析XML和HTML语言"><a href="#无法解析XML和HTML语言" class="headerlink" title="无法解析XML和HTML语言"></a>无法解析XML和HTML语言</h2><p>尚未完全解决，实在不行就不标明那一段是个代码段，直接放代码</p><h2 id="首页博客排序方式"><a href="#首页博客排序方式" class="headerlink" title="首页博客排序方式"></a>首页博客排序方式</h2><p>主题下_config.yml中index_generate:order_by: (+/-)(title/date)<br>+表示正序排列<br>-表示倒序排列</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-图论</title>
      <link href="/2021/08/17/leetcode-tu-lun/"/>
      <url>/2021/08/17/leetcode-tu-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><p>定义：<strong>无向图是由一组顶点（vertex）和一组能够将两个顶点相连的边（edge）组成的</strong><br>在无向图中，允许出现1.自环，即一条连接一个顶点和其自身的边，2. 连接同一对顶点的两条边称为平行边</p><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><p><img src="/img/posts/Leetcode/leetcode261.jpg" alt="Leetcode261图示"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-Java"><code class="language-Java">    class Solution {        //判断无向图是否有换，以及是否为单连通分量        //当只有n-1条边，且连通数为1时，符合条件        public boolean validTree(int n, int[][] edges) {            if(edges.length+1 != n) //只应该有n-1条边                return false;            int[] par = new int[n];            int par1 = 0,par2 = 0;            for(int i = 0;i < n;i++)                par[i]=i; //并查集，每个点的父节点是自己            for(int i = 0;i < edges.length;i++){                par1 = edges[i][0];                par2 = edges[i][1];                /*不断向上寻找得到par1和par2的祖先节点*/                while(par1 != par[par1])                    par1 = par[par1];                 while(par2 != par[par2])                    par2 = par[par2];                /*par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--*/                if(par1 != par2){                    par[par2] = par1;                    n--;                }            }            return n == 1;                    }    }</code></pre><h2 id="323-无向图中连通分量的数目"><a href="#323-无向图中连通分量的数目" class="headerlink" title="323. 无向图中连通分量的数目"></a>323. 无向图中连通分量的数目</h2><p>你有一个包含&nbsp;n 个节点的图。给定一个整数 n 和一个数组&nbsp;edges&nbsp;，其中&nbsp;edges[i] = [ai, bi]&nbsp;表示图中&nbsp;ai&nbsp;和&nbsp;bi&nbsp;之间有一条边。</p><p><img src="/img/posts/Leetcode/leetcode323.jpg" alt="Leetcode323图示"></p><h3 id="c-vector容器进行DFS-深度优先"><a href="#c-vector容器进行DFS-深度优先" class="headerlink" title="c++ vector容器进行DFS 深度优先"></a>c++ vector容器进行DFS 深度优先</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    int countComponents(int n, vector<vector<int>>& edges) {        vector<int>a(n, 0);        vector<vector<int>>arr(n, a);        for (auto it : edges) {            arr[it[0]][it[1]] = 1;            arr[it[1]][it[0]] = 1;        }        int res = 0;        vector<int>mark(n, 0);        for (int i = 0; i < n; i++) {            if (mark[i] == 0) {                DFS(arr, mark, i);                res++;            }        }        return res;            }private:    void DFS(vector<vector<int>>&arr, vector<int>& mark,int b) {            mark[b] = 1;            for (int i = 0; i < arr.size(); i++) {                if (arr[i][b] == 1&&mark[i] == 0) {                    DFS(arr, mark,i);                }            }            mark[b] = 2;    }};</code></pre><h3 id="java-二维数组进行dfs"><a href="#java-二维数组进行dfs" class="headerlink" title="java 二维数组进行dfs"></a>java 二维数组进行dfs</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int countComponents(int n, int[][] edges){        int[][] map = new int[n][n];        for(int[] edge : edges) {            map[edge[0]][edge[1]] = 1;            map[edge[1]][edge[0]] = 1;        }        int res = 0;        int[] mark = new int[n];        for(int i = 0; i < n; i ++) {            if(mark[i] == 0) {                dfs(map, mark, i);                res ++;            }        }        return res;    }        public void dfs(int[][] map, int[] mark, int i) {        mark[i] = 1;        for(int j = 0; j < map.length; j ++) {            if(map[i][j] == 1 && mark[j] == 0) {                dfs(map,mark,j);            }        }    }}</code></pre><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有n个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p><img src="/img/posts/Leetcode/leetcode547.jpg" alt="Leetcode547"></p><h3 id="解法：DFS-深度优先"><a href="#解法：DFS-深度优先" class="headerlink" title="解法：DFS 深度优先"></a>解法：DFS 深度优先</h3><p>关键在于：无向图最小连通数：并查集</p><pre class=" language-Java"><code class="language-Java">class Solution {    public int findCircleNum(int[][] M) {        int ans = 0, N = M.length;        int[] mark = new int[N];        for(int i = 0; i < N; i++){            if(mark[i] == 0){                ans++;                DFS(M,mark,i,N);            }        }        return ans;    }        public void DFS(int[][] M, int[] mark, int si, int N){        mark[si] = 1;        for(int j = 0; j < N; j++){            if(M[si][j] == 1 && mark[j] == 0){                DFS(M,mark,j,N);            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求最大子集和</title>
      <link href="/2021/08/15/zui-da-zi-ji-he/"/>
      <url>/2021/08/15/zui-da-zi-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="求最大子集和"><a href="#求最大子集和" class="headerlink" title="求最大子集和"></a>求最大子集和</h2><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><h4 id="法一-暴力"><a href="#法一-暴力" class="headerlink" title="法一 暴力"></a>法一 暴力</h4><pre class=" language-c++"><code class="language-c++">class Solution {    public int numTrees(int n) {        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;                for(int i = 2; i < n + 1; i++)            for(int j = 1; j < i + 1; j++)                 dp[i] += dp[j-1] * dp[i-j];                return dp[n];    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习学习笔记1</title>
      <link href="/2021/08/05/shen-du-xue-xi-xue-xi-bi-ji-1/"/>
      <url>/2021/08/05/shen-du-xue-xi-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于深度学习"><a href="#关于深度学习" class="headerlink" title="关于深度学习"></a>关于深度学习</h2><p>深度学习是通过多层来获得更为抽象的特征表达，如果有一个n层(S1,S2,S3…Sn)的深度学习系统, 输入为I，输出是O，那么深度学习的过程可以抽象的表示为: I =&gt;S1=&gt;S2=&gt;S3=&gt;…=&gt;O，每一层的信息处理都会丢失部分信息，最后的O很难是初始的I，<strong>但是如果我们可以通过深度学习调节系统中的参数使得它的输出仍然是I那么我们就可以自动的获取输入I的一系列层次特征，即S1，S2…Sn</strong></p><p><img src="/img/posts/MachineLearning/Mindmap.jpg" alt="神经网络与深度学习结构(图片选自《神经网络与深度学习》一邱锡鹏"></p><p><a href="https://blog.csdn.net/qq_36816848/article/details/122286610?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166244950816782391845436%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166244950816782391845436&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-122286610-null-null.142%5Ev46%5Epc_rank_34_2&amp;utm_term=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&amp;spm=1018.2226.3001.4187">参考学习</a></p><h3 id="浅层学习"><a href="#浅层学习" class="headerlink" title="浅层学习"></a>浅层学习</h3><p>是只含有一层隐层节点/没有节点的浅层模型，如支持向量机、最大熵方法（逻辑回归）、多层感知机等</p><p><img src="/img/posts/MachineLearning/perceptron.jpg" alt="感知机perceptron"></p><p><img src="/img/posts/MachineLearning/simple_perceptron.jpg" alt="简单感知机"></p><p><img src="/img/posts/MachineLearning/multi_layel_perceptron.jpg" alt="多层感知机"></p><p>利用人工神经网络的反向传播算法（Back Propagation算法或者BP算法），让一个人工神经网络模型从大量训练样本中学习统计规律，从而对未知事件做预测。</p><ul><li>前向传播与反向传播：前向传播（foward propagation）作用于<strong>每一层的输入</strong>，通过逐层计算得到输出结果；反向传播（backward propagation）作用于网络的<strong>输出</strong>，通过计算<strong>梯度</strong>由<strong>深</strong>到<strong>浅</strong>更新网络参数。</li></ul><p>由于我们前向传播最终得到的结果，以分类为例，最终总是有误差的，可以通过<strong>梯度下降算法</strong>减少误差。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习的实质，是通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习更有用的特征，从而最终提升分类或预测的准确性。<strong>通过深度学习最终达到特征学习的目标</strong></p><p>在深度学习中，明确突出了特征学习的重要性，通过<strong>逐层特征变换</strong>，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。</p><h2 id="深度学习与神经网络"><a href="#深度学习与神经网络" class="headerlink" title="深度学习与神经网络"></a>深度学习与神经网络</h2><p><img src="/img/posts/MachineLearning/neutral_network.jpg" alt="神经网络的结构"></p><p><img src="/img/posts/MachineLearning/model_nw.jpg" alt="神经网络的主要模型"></p><p>深度学习采用了神经网络相似的分层结构，系统由包括输入层、隐层（多层）、输出层组成的多层网络，只有相邻层节点之间有连接，同一层以及跨层节点之间相互无连接，每一层可以看作是一个<strong>逻辑回归</strong>模型。</p><p>但DL与传统神经网络的区别在于，传统神经网络中，采用的是反向传播的方式进行，也就是采用迭代的算法来训练整个网络，随机设定初值，计算当前网络的输出，然后根据当前输出和label之间的差去改变前面各层的参数，直到收敛（整体是一个梯度下降法）。而DL整体上是一个layer-wise的训练机制。这样做的原因是因为，如果采用b反向传播的机制，对于一个深层网络（7层以上），残差传播到最前面的层已经变得太小，便会出现梯度扩散(gradient diffusion)。因此传统的BP算法不能用在深度神经网络。</p><ul><li>BP算法用于深度学习会出现的问题：</li></ul><ol><li>梯度越来越稀疏，偏差原来越小，可能出现过拟合</li><li>由于随机初始值，最终收敛到局部最小</li><li>只能通过有标签的数据集进行训练，不能学习无标签的数据集，也就是监督学习</li></ol><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/8775518">参考博客</a></p><p>如果对所有层同时训练，时间复杂度会太高；如果每次训练一层，偏差就会逐层传递。这会面临跟上面监督学习中相反的问题，会严重欠拟合（因为深度网络的神经元和参数太多了）。</p><p>简单来说分为两步：</p><p>1）首先逐层构建单层神经元，这样每次都是训练一个单层网络。</p><p>2）当所有层训练完后，使用wake-sleep算法进行调优。</p><p>Wake-Sleep算法分为醒（wake）和睡（sleep）两个部分。</p><p>1）wake阶段：认知过程，通过外界的特征和向上的权重（认知权重）产生每一层的抽象表示（结点状态），并且使用梯度下降修改层间的下行权重（生成权重）。也就是“如果现实跟我想象的不一样，改变我的权重使得我想象的东西就是这样的”。</p><p>2）sleep阶段：生成过程，通过顶层表示（醒时学得的概念）和向下权重，生成底层的状态，同时修改层间向上的权重。也就是“如果梦中的景象不是我脑中的相应概念，改变我的认知权重使得这种景象在我看来就是这个概念”。</p><h4 id="使用自下而上的非监督学习"><a href="#使用自下而上的非监督学习" class="headerlink" title="使用自下而上的非监督学习"></a>使用自下而上的非监督学习</h4><p>采用无标定数据（有标定数据也可）分层训练各层参数（可以看作无监督训练过程–也是特征学习的过程）</p><ol><li>首先用无标定数据训练第一层，训练时先学习第一层的参数，可以将这一步看作一个使得输出如输出差异化的最小神经网络的隐层</li><li>一次学习没在学习到低n层时，将低n层的输出作为第n+1层的输入来训练第n+1层，以此得到每一层的参数</li></ol><h4 id="采用自顶而下的监督学习"><a href="#采用自顶而下的监督学习" class="headerlink" title="采用自顶而下的监督学习"></a>采用自顶而下的监督学习</h4><p>通过有标签的数据去训练，将误差自顶而下传输，堆网络进行微调</p><p>基于第一步各层参数进一步微调整个模型的参数，由于DL的第一步不是随机初始化，而是通过学习输入数据的结构得到的，因而这个初值更接近全局最优，从而能够取得更好的效果；所以DL效果好很大程度上归功于第一步自下而上非监督学习中的特征学习过程。</p><h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p>超参数是在<strong>开始学习过程之前设置值的参数</strong>，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。具体来讲比如算法中的学习率、梯度下降法迭代的数量、隐藏层数目、隐藏层单元数目、激活函数都需要根据实际情况来设置，这些参数实际上控制了最后的参数和的值，所以它们被称作超参数。</p><p>因此，寻求超参数的最优值是十分重要的，常见的设置超参数的方法有</p><ol><li>随机搜索：让计算机随机挑选以阻止</li><li>贝叶斯优化：使用贝叶斯优化超参数，但贝叶斯算法本身就有很多困难。</li><li>MITIE方法：先进性局部优化，利于寻找局部最优解。</li></ol><p><strong>超参数搜索的一般过程是</strong></p><ol><li>将数据集划分成训练集、验证集及测试集。</li><li>在训练集上根据模型的性能指标对模型参数进行优化。</li><li>在验证集上根据模型的性能指标对模型的超参数进行搜索</li><li>步骤 2 和步骤 3 交替迭代，最终确定模型的参数和超参数，在测试集中验证评价模型的优劣</li></ol><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>激活函数将非线性特性引入到网络中，在神经网络的神经元中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数。激活函数是为了增加神经网络模型的<strong>非线性</strong>。<strong>没有激活函数的每层都相当于矩阵相乘。就算你叠加了若干层之后，无非还是个矩阵相乘罢了。</strong>激活函数还可以把当前特征空间通过一定的线性映射转换到另一个空间，让数据能够更好的被分类。</p><ul><li>激活函数是个非线性函数：<ol><li>假若网络中全部是线性部件，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数</li><li>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</li></ol></li></ul><p>常见的激活函数有：Logistic函数，Tanh函数，ReLU函数，SoftPlus函数，可见参考<a href="https://www.cnblogs.com/wj-1314/p/12015278.html">【推荐】深度学习笔记——常用的激活（激励）函数</a><br><img src="/img/posts/MachineLearning/activate_fun.jpg" alt="激活函数"></p><h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p>Sigmoid也就是Logistic函数，表达式如下：  </p><p>$${S(x)} = \frac{1}{1+e^{(-x)}}$$  </p><p><img src="/img/posts/MachineLearning/Sigmoid.jpg" alt="Sigmoid函数即其导数图像"><br>绘图对应代码：</p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()# np.arrange(起点，终点，步长)x = np.arange(-10, 10, 0.025) # plot(x,y)plt.plot(x,1/(1+np.exp(-x)))plt.title("y = 1/(1+exp(-x))")# savefig存储要在show之前，不然输出的图片 会是空白plt.savefig('img/output_relu\'(x).png')plt.show() plt.plot(x,np.exp(-x)/(1+np.exp(-x))**2)plt.title("y = exp(-x)/(1+exp(-x))^2")plt.show()</code></pre><ul><li>Sigmoid函数连续可导，值域为(0,1)</li><li>相比较于阶跃函数，可以直接利用梯度下降算法优化网络参数</li><li>作为激活函数，将inputs映射到(0,1)，在早期的神经网络中使用地非常多，因为它很好地解释了神经元受到刺激后是否被激活和向后传递的场景（0：几乎没有被激活；1：完全被激活）。因此可以通过Simoid函数将<strong>输出转化为概率输出</strong>，常用于分类问题的<strong>事件概率</strong></li></ul><p>$$ {S’(x)} = {S(x)}{(1-S(x))} = \frac{e^{-x}}{(1+e^{-x})}$$</p><ul><li>在input x = 0时，导数醉倒为0.25，当输入为正负无穷时，导数趋于0，会发生梯度弥散  </li><li>Sigmoid函数光滑，易于求导，但是时指数级计算，计算量大，容易出现梯度弥散或者梯度饱和</li><li>当神经网络的层数很多时，如果每一层的激活函数都采用Sigmoid函数的话，就会产生梯度弥散和梯度爆炸的问题，其中梯度爆炸发生的概率非常小，而梯度消失发生的概率比较大。</li></ul><p>当一个激活函数S(x)满足<br>右饱和：$ \lim_{n\to +\infty} {S(x)} = 0 $<br>左饱和：$ \lim_{n\to -\infty} {S(x)} = 0 $<br>当S(x)同时满足左饱和与右饱和时，称之为饱和</p><h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>tanh是双曲函数中的一个，tanh() 为双曲正切，关于原点中心对称。在数学中，双曲正切 tanh 是由双曲正弦和双曲余弦这两者基本双曲函数推导而来。  </p><p>正切函数时非常常见的激活函数，<strong>与Sigmoid函数相比，它的输出均值是0</strong>，使得其<strong>收敛速度要比Sigmoid快</strong>，减少迭代次数。相对于Sigmoid的好处是它的输出的均值为0，克服了第二点缺点。<strong>但是当饱和的时候还是会杀死梯度。</strong></p><p>$$ {tanh(x)} = \frac {1-e^{-2x}}{1+e^{-2x}}$$</p><p>$$ {tanh’(x)} = {1-(tanh(x)^2)} =\frac {4e^{-2x}}{(1+e^{-2x})^2}$$</p><p><img src="/img/posts/MachineLearning/tanh.jpg" alt="tanh函数即其导数图像"><br>绘图代码如下</p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()x = np.arange(-10, 10, 0.025)plt.plot(x,(1-np.exp(-2*x))/(1+np.exp(-2*x)))plt.title("y = (1-exp(-2x))/(1+exp(-2x))")plt.show() plt.plot(x,4*np.exp(-2*x)/(1+np.exp(-2*x))**2)plt.title("y = 4exp(-2x)/(1+exp(-2x))^2")plt.show()</code></pre><ul><li>tanh函数的值域(-1,1)</li><li>在神经网络的应用中，tanh通常要优于Sigmoid的，因为tanh的输出在 -1~1之间，均值为0，更方便下一层网络的学习。</li><li>但是如果做二分类，输出层可以使用 Sigmoid，因为它可以算出属于某一类的概率。</li><li>tanh函数也存在着梯度弥散或梯度饱和和幂运算的缺点</li></ul><p>从tanh函数和sigmoid函数表达式中可以看出，<strong>tanh(x)的梯度消失问题比Simgoid(x)要轻，梯度如果过早消失会导致收敛速度较慢</strong></p><ul><li>以零为中心的影响，如果当前参数（w0, w1）的最佳优化方向是 （+d0, -d1），则根据反向传播计算公式，我们希望x0和x1符号相反，但是如果上一级神经元采用 Sigmoid 函数作为激活函数，Sigmoid不以零为中心，输出值恒为正，那么我们无法进行更快的参数更新，而是走Z字形逼近最优解。</li></ul><h3 id="ReLu函数"><a href="#ReLu函数" class="headerlink" title="ReLu函数"></a>ReLu函数</h3><p>针对Sigmoid函数和tanh的缺点，提出ReLU函数。</p><p>线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数。<strong>解决了梯度消失现象</strong>，,收敛速度远远大于 Sigmoid函数和 tanh函数,计算速度更快。计算方便，求导方便，计算速度非常快，只需要判断输入是否大于0。  </p><ul><li><strong>无饱和区，收敛快，计算简单</strong>，有时候会比较脆弱，如果变量的更新太快，还没有找到最佳值，就进入小于零的分段就会使得梯度变为零，无法更新直接死掉了。</li></ul><p>$$ {ReLu(x) = max(x,0)}$$</p><center>当x&gt;=0时，ReLu(x) = x </center><center>当x&lt;0时， ReLu(x) = 9 </center><center>ReLu'(x) = 1, 当x&gt;=0时</center><center>ReLu'(x) = 0, 当x&lt;0时</center>    <p><img src="/img/posts/MachineLearning/ReLu.jpg" alt="ReLu函数即其导数图像"></p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()x = np.arange(-10, 10, 0.025)# clip(x,最小，最大)plt.plot(x,np.clip(x,0,10e30))plt.title("y = relu(x)=max(x,0)")plt.show() from matplotlib import pyplot as pltplt.plot(x,x>0,"o")plt.title("y = relu'(x)")plt.show()</code></pre><p><strong>ReLU函数在零点不可导</strong><br>在反向传播中，对于ReLU间断点的求导按照做到书来计算，即默认情况下默认导数为零，negative_gradient = 0</p><p>可由caffe源码可知<br>~/caffe/src/caffe/layers/relu_layer.cpp倒数第十行代码：</p><pre class=" language-Python"><code class="language-Python">bottom_diff[i] = top_diff[i] * ((bottom_data[i] > 0)+ negative_slope * (bottom_data[i] <= 0));</code></pre><h4 id="ReLU的优缺点"><a href="#ReLU的优缺点" class="headerlink" title="ReLU的优缺点"></a>ReLU的优缺点</h4><p>ReLU函数就是一个取最大值函数，因为它的导数等于1或者就是0<br><strong>因为ReLU是线性的，而sigmoid和tanh是非线性的</strong>。相对于sigmoid和tanh激励函数，对ReLU求梯度非常简单，计算也很简单，可以非常大程度地提升随机梯度下降的收敛速度。</p><ul><li><p>优点： </p><ol><li>解决了梯度消失</li><li>计算方便，秩序判断输入是否大于0</li><li>收敛速度远远大于Sigmoid函数和tanh函数，可以加速网络训练</li></ol></li><li><p>缺点： 随着训练的进行，可能出现神经元死亡的情况，当有一个很大的梯度流经ReLu后，权重的更新结果可能是在此之后的任何数据点都无法激活改神经元</p><ol><li>由于负数部分恒为零，，、当x为负时导数等于零，会导致一些神经元无法激活</li><li>输出不是zero-centered</li><li>learning rate 太高，导致在训练过程中参数更新太大</li></ol></li></ul><h4 id="Leaky-ReLu函数"><a href="#Leaky-ReLu函数" class="headerlink" title="Leaky ReLu函数"></a>Leaky ReLu函数</h4><p>Leaky ReLU解决了ReLU会杀死一部分神经元的情况。Leaky ReLU 是给所有负值赋予一个非零斜率。Leaky ReLU 激活函数是在声学模型（2013）中首次提出。</p><p><img src="/img/posts/MachineLearning/LeakyReLu.jpg"></p><p><img src="/img/posts/MachineLearning/Leaky_ReLu.jpg" alt="Leaky_ReLu函数即其导数图像"></p><p>　人们为了解决 Dead ReLU Problem(ReLU的死神经问题), 提出了将 ReLU 的前半段设为 ax 而非0，通常 a = 0.01，另外一种直观的想法是基于参数的方法，即 ParmetricReLU ： f(x)=max(ax, x)，其中 a 可由方向传播算法学出来。理论上来说，Leaky ReLU 有ReLU的所有优点，外加不会有 Dead ReLU 问题，但是在实际操作当中，并没有完全证明 Leaky ReLU 总是好于 ReLU。</p><p><strong>Leaky  ReLU 主要是为了避免梯度消失，当神经元处于非激活状态时，允许一个非0的梯度存在</strong>，这样不会出现梯度消失，收敛速度快。他的优缺点和ReLU类似。</p><h3 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h3><p><a href="https://blog.csdn.net/lz_peter/article/details/84574716?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166289193816800184112865%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166289193816800184112865&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84574716-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Eadd_ask&amp;utm_term=softmax&amp;spm=1018.2226.3001.4187">Softmax理解</a></p><p>　　softmax 函数，又称为归一化指数函数。它是二分类函数 Sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。</p><p>他把<strong>一些输入映射为0-1之间的实数，并且归一化保证和为1，因此多分类的概率之和也刚好为1。</strong></p><p><img src="/img/posts/MachineLearning/Softmax01.jpg" alt="Softmax解释"></p><p>假设有一个数组V， $V_i$​表示V中的第i个元素，那么这个元素的softmax值为:</p><p>$$ S_i = \frac {e^i}{\sum_je^j} $$</p><p>该元素的softmax值，就是该元素的指数与所有元素指数和的比值。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在机器学习任务中，大部分监督学习算法都会有一个目标函数 (Objective Function),算法对该目标函数进行优化，称为优化算法的过程。 例如在分类或者回归任务中，<strong>使用损失函数( Loss Function )作为其目标函数对算法模型进行优化</strong>。</p><p>在BP神经网络中，使用均方误差作为损失函数，而在实际中，常用交叉熵作为损失函数。</p><ul><li><p>均方误差作为损失函数收敛速度慢，可能会陷入局部最优解；<strong>交叉熵</strong>作为损失函数的<strong>收敛速度</strong>比均方误差<strong>快</strong>，且较为容易找到函数最优解.</p></li><li><p>均方差损失函数：<br>  <img src="/img/posts/MachineLearning/avg_sqar.jpg"></p></li><li><p>Logistic 损失函数<br>  <img src="/img/posts/MachineLearning/logistic_loss.jpg"></p></li><li><p>负对数似然损失函数<br>  <img src="/img/posts/MachineLearning/neg_log_loss.jpg"></p></li><li><p><a href="https://blog.csdn.net/tsyccnh/article/details/79163834?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166289228816782412517434%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166289228816782412517434&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79163834-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Eadd_ask&amp;utm_term=%E4%BA%A4%E5%8F%89%E7%86%B5&amp;spm=1018.2226.3001.4187">交叉熵损失函数</a>:Logistic损失函数和负对数似然损失函数只能处理二分类问题，对于两个分类扩展到M个分类，使用交叉熵损失函数(Cross Entropy Loss)，熵用来表示所有信息量的期望[信息量：当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小，信息量和事件发生的概率]，其定义如下：</p><h2 id=""><a href="#" class="headerlink" title="  "></a>  <img src="/img/posts/MachineLearning/cross_entropy_loss.jpg"></h2></li><li><p>Hige:典型分类器是SVM算法因为 Hinge 损失可以用来解决间隔最大化问题。当分类模型需要硬分类结果的，例如分类结果是 0 或 1 、 -1或 1 的二分类数据， Hinge 损失是最方便的选择 。Hinge 损失函数定义如下：<br>  <img src="/img/posts/MachineLearning/hinge_loss.jpg"></p></li></ul><h3 id="神经网络中常用的损失函数"><a href="#神经网络中常用的损失函数" class="headerlink" title="神经网络中常用的损失函数"></a>神经网络中常用的损失函数</h3><p><a href="https://blog.csdn.net/weixin_44222014/article/details/103271192">常用损失函数参考介绍</a></p><ol><li><p>ReLU + MSE(均方差)<br> 均方误差损失函数无法处理梯度消失问题，而使用 Leak ReLU 激活函数能够减少计算时梯度消失的问题，因此在神经网络中如果需要使用均方误差损失函数，一般采用 Leak ReLU 等可以减少梯度消失的激活函数。另外，由于均方误差具有普遍性，一般作为衡量损失值的标准，因此使用均方误差作为损失函数表现既不会太好也不至于太差。</p></li><li><p>Sigmoid + Logistic<br> Sigmoid 函数会引起梯度消失问题：根据链式求导法，Sigmoid 函数求导后由多个［0, 1］范围的数进行连乘，如其导数形式为 ，当其中一个数很小时，连成后会无限趋近于零直至最后消失。而类 Logistic 损失函数求导时，加上对数后连乘操作转化为求和操作，在一定程度上避免了梯度消失，所以我们经常可以看到 Sigmoid 激活函数＋交叉摘损失函数 的组合。</p></li><li><p>Softmax + Logisitc<br> 在数学上，Softmax 激活函数会返回输出类的互斥概率分 布，也就是能把离散的输出转换为一个同分布互斥的概率，如(0.2, 0.8)。另外，Logisitc 损失函数是基于概率的最大似然估计函数而来的，因此输出概率化能够更加方便优化算法进行求导和计算，所以我们经常可以看到输出层使xu用Softmax激活函数＋交叉熵损失函数 的组合。</p></li></ol><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>深度学习网络训练过程可以分成两大部分：前向计算过程与反向传播过程。前向计算过程，是指通过我们预先设定好的卷积层、池化层等等，<strong>按照规定的网络结构一层层前向计算，得到预测的结果</strong>。反向传播过程，是为了将设定的网络中的<strong>众多参数</strong>一步步调整，使得<strong>预测结果能更加贴近真实值</strong>。在反向传播中参数更新显得尤为重要。</p><p>参数应该是<strong>朝着目标损失函数下降最快的方向</strong>更新，更确切的说，要朝着<strong>梯度方向</strong>更新</p><ul><li><p>随机梯度下降法：每次迭代（更新参数）只使用单个训练样本<br>  优点：一次迭代只需对一个样本进行计算，因此运行速度很快，还可用于在线学习<br>  缺点：（1）由于单个样本的随机性，实际过程中，目标损失函数值会剧烈波动，一方面，SGD 的波动使它能够跳到新的可能更好的局部最小值。另一方面，使得训练永远不会收敛，而是会<strong>一直在最小值附近波动</strong>。（2）一次迭代只计算一张图片，没有发挥GPU并行运算的优势，使得<strong>整体计算的效率不高</strong>。</p></li><li><p>批量梯度下降法：每次迭代更新中使用所有的训练样本<br>  优缺点分析：批量梯度下降算法能保证收敛到凸误差表面的全局最小值和非凸表面的局部最小值。但每迭代一次，需要用到训练集中的所有数据，如果数据量很大，那么迭代速度就会非常慢。</p></li><li><p>小批量梯度下降法：折中了 BGD 和 SGD 的方法，每次迭代使用 batch_size 个训练样本进行计算<br>  优缺点分析：因为每次迭代使用多个样本，所以 MBGD 比 SGD 收敛更稳定，也能避免 BGD 在数据集过大时迭代速度慢的问题。因此，MBGD是深度学习网络训练中经常使用的梯度下降方法。</p></li></ul><h3 id="动量梯度下降"><a href="#动量梯度下降" class="headerlink" title="动量梯度下降"></a>动量梯度下降</h3><p>动量梯度下降使得当前的参数更新方向不仅与当前的梯度有关，也受历史的加权平均梯度影响。对于梯度指向相同方向的维度，动量会积累并增加，而对于梯度改变方向的维度，动量会减少更新。这也就使得收敛速度加快，同时又不至于摆动幅度太大。</p><p>本质上，当使用动量时，如同我们将球推下山坡。球在滚下坡时积累动量，在途中变得越来越快。同样的事情发生在参数更新上：对于梯度指向相同方向的维度，动量会积累并增加，而对于梯度改变方向的维度，动量会减少更新。<strong>结果，我们获得了更快的收敛和减少的振荡</strong>。</p><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><p>Adam 是另一种参数自适应学习率的方法，相当于 RMSprop + Momentum，利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率</p><h2 id="激活函数、损失函数、优化函数的区别"><a href="#激活函数、损失函数、优化函数的区别" class="headerlink" title="激活函数、损失函数、优化函数的区别"></a>激活函数、损失函数、优化函数的区别</h2><p>1.激活函数：将神经网络上一层的输入，经过神经网络层的<strong>非线性变换转换</strong>后，通过激活函数，<strong>得到输出</strong>。常见的激活函数包括：sigmoid, tanh, relu等。</p><p><a href="https://blog.csdn.net/u013250416/article/details/80991831">激活函数</a></p><p>2.损失函数：度量神经网络的<strong>输出的预测值与实际值之间的差距</strong>的一种方式。常见的损失函数包括：最小二乘损失函数、交叉熵损失函数、回归中使用的smooth L1损失函数等。</p><p>3.优化函数：也就是如何把<strong>损失值</strong>从神经网络的最外层<strong>传递到最前面</strong>。如最基础的梯度下降算法，随机梯度下降算法，批量梯度下降算法，带动量的梯度下降算法，Adagrad，Adadelta，Adam等。</p><p><a href="https://blog.csdn.net/u013250416/article/details/81090059">优化函数</a></p><p>CNN由<strong>卷积层</strong>、<strong>池化层</strong>、<strong>全连接层</strong>三部分组成。</p><h2 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h2><p><a href="https://www.zhihu.com/question/22298352/answer/91131073">卷积</a></p><p>卷积网络执行的是监督训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。</p><ul><li><p>CNN的特点：</p><ol><li>能够有效的将大数据量的图片降维成小数据量。</li><li>能够有效的保留图片特征，符合图片处理的原则。</li></ol></li><li><p>CNN的核心：</p><ol><li>局部连接：通过卷积操作实现局部连接，这个局部区域的大小就是滤波器filter，避免了全连接中参数过多造成无法计算的情况。<br>  一般认为图像的空间联系是局部的像素联系比较密切，而距离较远的像素相关性较弱，因此，<strong>每个神经元没必要对全局图像进行感知，只要对局部进行感知</strong>，然后在<strong>更高层</strong>将<strong>局部的信息综合起来</strong>得到全局信息。</li></ol><ul><li>具体实现： 网络部分连通，每个神经元只与上一层的部分神经元相连，只感知局部，而不是整幅图像。</li></ul><ol start="2"><li>权值(参数)共享：通过权值共享来缩减实际参数的数量，为实现多层网络提供了可能。<br>  在局部连接中，每个神经元的参数都是一样的，即：<strong>同一个卷积核在图像中都是共享的。</strong>(对于图像上这部分学到的特征也可以用到另一部分上。所以对图像上的所有位置，都能使用同样的学习特征。)<br>  但卷积核共享会导致提取特征不充分，因此要<strong>通过增加多个卷积核来弥补</strong>，学习多种特征</li></ol></li></ul><p>CNN在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>以图像处理为例， 一般用一个正方形卷积核，遍历图片上的每一个像素点。<strong>图片与卷积核重合区域内</strong>相对应的<strong>每一个像素值</strong>，乘<strong>卷积核内相对应点</strong>的<strong>权重</strong>，然后<strong>求和</strong>， 再加上偏置后，最后得到输出图片中的一个像素值。<br>图片分<strong>灰度图</strong>和<strong>彩色图</strong>，卷积核可以是<strong>单个</strong>也可以是<strong>多个</strong>，因此卷积操作分以下三种情况：</p><ol><li><p>单通道输入，单卷积核</p><p> 单通道输入即灰度图，但卷积核即卷积核个数为1。<br> <img src="/img/posts/MachineLearning/simple_convo.jpg"></p><p> 上面是 5x5x1 的灰度图片，1表示单通道，5x5 表示分辨率，共有 行5列个灰度值。若用一个 3x3x1 的卷积核对  此5x5x1的灰度图片进行卷积，偏置项b=1，则求卷积的计算是：(-1)x1+0x0+1x2+(-1)x5+0x4+1x2+(-1)x3+0x4+1x5+1=1（注意不要忘记加偏置 1）。</p></li><li><p>多通道输入，单卷积核</p><p> 输入为彩色图片，输入的图片包含了红、绿、蓝三层数据，<strong>卷积核的深度（通道数）应该等于输入图片的通道数</strong>，所以使用 3x3x3的卷积核，最后一个 3 表示匹配输入图像 的 3 个通道，这样这个卷积核有三通道，<strong>每个通道都会随机生成 9 个待优化的参数</strong>，一共有<strong>27 个待优化参数  w</strong>和<strong>一个偏置 b</strong>。<br>  <img src="/img/posts/MachineLearning/simple_convo.jpg"></p><p> 这里还是单个卷积核的情况，但是一个卷积核可以有多个通道。默认情况下，卷积核的通道数等于输入图片的通道数。</p></li><li><p>多通道输入，多卷积核</p><p> 这是神经网络中最常见的方式，此处以3通道输入，两个卷积核为例。<br> <img src="/img/posts/MachineLearning/multi_convo.jpg"></p><ol><li>和多通道输入，单卷积核一样,先取出一个卷积核与3通道的输入进行卷积,得到一个1通道的输出output1。同样再取出第二个卷积核进行同样的操作,得到第二个输出output2。</li><li>将相同size的output1与output2进行堆叠，就得到2通道的输出output。<br> 图中输入X:[1,h,w,3]指的是：输入1张高h宽w的3通道图片。<br> 卷积核W:[k,k,3,2]指的是：卷积核尺寸为3*3，通道数为3，个数为2。</li></ol></li></ol><ul><li><strong>卷积核的个数和卷积核的通道数</strong>是不同的概念。每层卷积核的个数在设计网络时会给出，但是卷积核的通道数不一定会给出。<strong>默认情况下，卷积核的通道数=输入的通道数</strong>，因为这是进行卷积操作的必要条件。</li><li>卷积操作后，<strong>输出的通道数=卷积核的个数</strong></li><li>偏置数=卷积核数</li></ul><p>在卷积层中，可以通过调节步长参数 s 实现特征图的高宽成倍缩小，从而降低网络的参数量。</p><p>卷积层参数/卷积计算量<br>卷积参数 = 卷积核长度x卷积核宽度x输入通道数x输出通道数+输出通道数（偏置）<br>卷积计算量 = 输出数据大小x卷积核的尺度x输入通道数</p><p>例：输入：224x224x3，输出：224x244x64，卷积核：3x3</p><p>参数量 = 3x3x3x64+64<br>计算量 = 224x224x64x3x3x3</p><h4 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充 Padding"></a>填充 Padding</h4><p>为了使卷积操作后能得到满意的输出图片尺寸，经常会使用padding对输入进行填充操作。默认在图片周围填充0。</p><h3 id="池化层（Pooling-layel"><a href="#池化层（Pooling-layel" class="headerlink" title="池化层（Pooling-layel)"></a>池化层（Pooling-layel)</h3><p>功能：主要作用是把数据降维，可以有效的避免过拟合<br>池化作用如下</p><ol><li>使卷积神经网络<strong>抽取特征</strong>是<strong>保证特征局部不变性。</strong></li><li>池化操作能<strong>降低维度</strong>，<strong>减少参数数量</strong>。</li><li>池化操作优化比较简单。</li></ol><p><img src="/img/posts/MachineLearning/pooling.jpg"></p><p><img src="/img/posts/MachineLearning/pooling2.jpg"></p><p>池化层同样基于<strong>局部相关性</strong>的思想，通过从<strong>局部相关</strong>的一组元素中进行采样或信息聚合，从而得到新的元素值。通常我们用到两种池化进行下采样：<br>（1）最大池化(Max Pooling)，从局部相关元素集中选取最大的一个元素值。<br>（2）平均池化(Average Pooling)，从局部相关元素集中计算平均值并返回。</p><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>功能：根据不同任务输出我们想要的结果</p><p>每个神经元与前后相邻层的每一个神经元都有连接关系,输入特征，输出预测的结果。<br>全连接层的参数量 = $\sum {(前层x后层+后层)}$</p><p>由于一般全连接层参数较多，实际应用中一般不会将原始图片直接喂入全连接网络。尤其现实生活中高分辨率的彩色图像，像素点更多，且为红绿蓝三通道信息。待优化的参数过多， 容易导致模型过拟合。<br>在实际应用中，会先对原始图像<strong>进行卷积特征提取</strong>，把提取到的<strong>特征</strong>喂给全连接网络，再让全连接网络计算出分类评估值。</p><h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>卷积神经网络中最常用的是ReLU。<br><a href="https://blog.csdn.net/wjinjie/article/details/104729911">激活函数的选择</a></p><h3 id="卷积神经网络的训练步骤"><a href="#卷积神经网络的训练步骤" class="headerlink" title="卷积神经网络的训练步骤"></a>卷积神经网络的训练步骤</h3><p><img src="/img/posts/MachineLearning/convo_procedure.jpg"></p><ol><li><p>用随机数初始化<strong>所有的卷积核参数/权重</strong></p></li><li><p>将训练集图片作为输入，进行前向步骤，包括<strong>卷积</strong>、<strong>ReLU激活</strong>、<strong>池化</strong>、<strong>全连接层的前向传播</strong>，并计算各个类别对应的输出概率</p></li><li><p>计算出书层的总误差</p></li><li><p>用误差<strong>反向传播</strong>算法计算<strong>误差相对于所有权重的梯度</strong>，利用梯度下降<strong>更新所有的卷积核参数/权重的值</strong></p></li></ol><p>卷积核个数、卷积核尺寸、网络架构这些参数，是在 之前就已经固定的，且不会在训练过程中改变——只有<strong>卷积核矩阵</strong>和<strong>神经元权重</strong>会更新。</p><h4 id="经典网络介绍"><a href="#经典网络介绍" class="headerlink" title="经典网络介绍"></a>经典网络介绍</h4><p><a href="https://blog.csdn.net/jiaoyangwm/article/details/80011656">卷积神经网络介绍</a></p><ul><li><p>残差网络(Residual Network,ResNet)：通过非线性的卷积层增加直连边，也就是残差连接的方式来提高信息传播小笼包</p></li><li><p>AlexNet</p></li></ul><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p><a href="https://my.oschina.net/u/876354/blog/1621839">循环神经网络</a>通过使用带自反馈的神经元，能够处理任意长度的序列，比前馈神经网络更符合生物神经网络结构。<br>RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。</p><h2 id="目标检测算法-Yolo"><a href="#目标检测算法-Yolo" class="headerlink" title="目标检测算法-Yolo"></a>目标检测算法-Yolo</h2><p>Yolo是one-stage，一步回归到位，与two-stage相比，核心优势在于速度非常快，适合做实时检测任务，但可能相比two-stage(MaskRcnn)的检测精度效果会相对较差</p><p>考虑指标；</p><ul><li>map：map越高，效果越好，，不要单看精度、召回率。把所有阈值都考虑进来，以recall为横轴，precison为纵轴，作一个曲线图，map值就是所有类别的平均值</li><li>IoU：/frac {预测值与真实值的重叠区域(交集)}{预测值与真实值的并集}，IoU越高越好</li><li>精度 = /frac {TP}{TP+FP}</li><li>召回率 = /frac {TP}{TP+FN}</li></ul><p>在检测任务中的精度与招呼率代表：</p><ul><li><p>TP = true positive(1被正确的判断为1) FN = false Negative（1被错误的判断为0）</p></li><li><p>FP = false positive(0被错误的判断为1) FN = false negative（0被正确的判断为0）</p></li><li><p>置信度(confidence)：通俗而言就是检测一个物体它是一个人的可能性有多大，需要基于置信度阈值来计算</p></li></ul><p>Yolo的map比fast-Rcnn低，但速度比rcnn快</p><h3 id="Yolo-V1"><a href="#Yolo-V1" class="headerlink" title="Yolo-V1"></a>Yolo-V1</h3><p>输入： SxS的网格</p><p>预测得出得出bounding box（x,y,w,h） + confidence ==&gt; 四个偏移量加上一个置信度</p><ul><li>置信度较高才说明是一个物体，此时再去作筛选</li></ul><h3 id="Yolo-v3"><a href="#Yolo-v3" class="headerlink" title="Yolo-v3"></a>Yolo-v3</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习3-多元梯度下降</title>
      <link href="/2021/07/30/ji-qi-xue-xi-3-duo-yuan-ti-du-xia-jiang/"/>
      <url>/2021/07/30/ji-qi-xue-xi-3-duo-yuan-ti-du-xia-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>多元线性回归也就是用多个特征变量来进行预测  </p><div align="center"><font size="4">$h_\theta$($\theta$) = $\theta_0$+$\theta_1$$x_1$+$\theta_2$$x_2$+$\theta_3$$x_3$+$\theta_4$$x_4$...+$\theta_n$$x_n$</font></div>    <center>定义$x_0$ = 1</center>  <p>所以<br>    x =<br>        $$\begin{bmatrix}<br>        x_0 x_1 x_2 … x_n<br>        \end{bmatrix}$$</p><p>$\theta$ = $$\begin{bmatrix}\theta_0 \ \theta_1  \ \theta_2 \ … \theta_n\end{bmatrix}$$</p><p>所以得出$h_\theta(x) = \theta^Tx$</p><h2 id="用梯度下降处理多元线性回归"><a href="#用梯度下降处理多元线性回归" class="headerlink" title="用梯度下降处理多元线性回归"></a>用梯度下降处理多元线性回归</h2><p>在梯度下降中的假设<br>$$h_\theta(x) = \theta^Tx$$</p><p>代价函数</p><p>$$J(\theta_0,\theta_1…\theta_n) = \frac{1}{2m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))^2$$</p><p>梯度下降</p><center>重复多次</center>    <p>$$\theta := \theta_j - \alpha \frac{\partial {J(\theta)}}{\partial \theta_j}$$</p><p>$\alpha$是学习率</p><p>最终梯度下降</p><center>重复</center>$$ \theta_j := \theta_j - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_j^{(i)}$$<p>即<br>$$ \theta_0 := \theta_0 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_0^{(i)}$$<br>$$ \theta_1 := \theta_1 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_1^{(i)}$$<br>$$ \theta_2 := \theta_2 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_2^{(i)}$$</p><h2 id="特征缩放-Feature-scaling"><a href="#特征缩放-Feature-scaling" class="headerlink" title="特征缩放(Feature scaling)"></a>特征缩放(Feature scaling)</h2><blockquote><p>不同特征的取值在一个相近的范围，这样梯度下降容易更好地收敛</p></blockquote><p>特征地范围不要过小也不要过大</p><h3 id="均值归一化-Mean-normalization"><a href="#均值归一化-Mean-normalization" class="headerlink" title="均值归一化(Mean normalization)"></a>均值归一化(Mean normalization)</h3><blockquote><p>将$x_i$用$x_i-\mu_i$代替是的特征均值为0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-哈希表</title>
      <link href="/2021/07/30/leetcode-ha-xi-biao/"/>
      <url>/2021/07/30/leetcode-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="构造哈希表"><a href="#构造哈希表" class="headerlink" title="构造哈希表"></a>构造哈希表</h2><p>参考<a href="https://leetcode.cn/problems/design-hashset/">Leetcode705-设计哈希结合</a></p><p>要解决的问题</p><ul><li>映射： 将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</li><li>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理</li><li>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</li></ul><p>考虑到哈希表后期需要扩容，一般不会考虑直接用数组，而是采用链表</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习2-矩阵方程</title>
      <link href="/2021/07/23/ji-qi-xue-xi-2-ju-zhen-fang-cheng/"/>
      <url>/2021/07/23/ji-qi-xue-xi-2-ju-zhen-fang-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵的基本概念"><a href="#矩阵的基本概念" class="headerlink" title="矩阵的基本概念"></a>矩阵的基本概念</h2><ul><li>dimension ：行x列 </li><li>矩阵表示<br>  2x3的矩阵表示:<br>  $$\begin{bmatrix}<br>  1&amp;1&amp;0 \<br>  1&amp;0&amp;1 \<br>  \end{bmatrix}$$<br><br>  3x2的矩阵表示:<br>  $$\begin{bmatrix}<br>  0&amp;1 \<br>  1&amp;0 \<br>  1&amp;1 \<br>  \end{bmatrix}$$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch配置</title>
      <link href="/2021/07/21/torch-pei-zhi/"/>
      <url>/2021/07/21/torch-pei-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cuda:11.3.0（官网安装）<a href="https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local">https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local</a><br>Nvida CUDA 11.4.141<br>显卡： NVDIA Getforce RTX 3050 Ti</p></blockquote><p>troch安装网址：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><h2 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h2><p>直接在C:\user\.condarc中修改</p><pre class=" language-shell"><code class="language-shell">channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - defaultsssl_verify: falseshow_channel_urls: truereport_errors: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习1--机器学习是干什么</title>
      <link href="/2021/07/20/ji-qi-xue-xi-1-ji-qi-xue-xi-shi-gan-shi-me/"/>
      <url>/2021/07/20/ji-qi-xue-xi-1-ji-qi-xue-xi-shi-gan-shi-me/</url>
      
        <content type="html"><![CDATA[<p>监督学习与非监督学习，假设函数与代价函数，梯度下降</p><h2 id="监督学习与非监督学习"><a href="#监督学习与非监督学习" class="headerlink" title="监督学习与非监督学习"></a>监督学习与非监督学习</h2><blockquote><p><strong>有无预期输出</strong>是监督学习与非监督学习的最大区别</p></blockquote><ul><li>监督学习：学习一个模型使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</li></ul><p>即：利用训练数据集学习一个模型，再用模型对测试样本集进行预测。</p><p><strong>分类问题（离散）</strong>与<strong>回归问题（连续）</strong>等都是监督学习。</p><ul><li>非监督学习：直接对数据进行建模。没有给定事先标记过的训练范例，所用的数据没有属性或标签这一概念。事先不知道输入数据对应的输出结果是什么。</li></ul><p>自动对输入的资料进行分类或分群，以寻找数据的模型和规律。</p><p><strong>聚类算法</strong>是一种非监督学习，针对数据集，自动找出数据中的结构，从而把数据分成不同的簇。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>此处以最简单的线性回归（如房价预测）为例，线性回归的学习是为了预测未来房价</p><p>机器学习是在已知部分x与y的情况下，得出一个房价相关的线性函数y = ax + b</p><p>所以代价函数是与参数a,b相关的函数,使得代价函数最小化，是线性回归中的学习目标</p><p>常用的代价函数有<br>    <img src="/img/posts/MachineLearning/cost_function.jpg" alt="平方和代价函数"></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="梯度下降的过程"><a href="#梯度下降的过程" class="headerlink" title="梯度下降的过程"></a>梯度下降的过程</h3><ol><li>选定几个参数a1,a2,a3…</li><li>选择初始值</li><li>从初值开始按照给定的步幅进行梯度下降，寻找局部极小值</li></ol><p><img src="/img/posts/MachineLearning/slope0.jpg" alt="梯度下降可以用等高线图具象化"></p><p><img src="/img/posts/MachineLearning/slope1.jpg" alt="选择初始点"></p><p><img src="/img/posts/MachineLearning/slope3.jpg" alt="从a点一步一步往下梯度下降"></p><p><img src="/img/posts/MachineLearning/slope2.jpg" alt="从b点一步一步往下梯度下降"></p><blockquote><p>从不同的点进行梯度下降可能得到<strong>不同</strong>的局部极小值</p></blockquote><h3 id="梯度下降的数理解释"><a href="#梯度下降的数理解释" class="headerlink" title="梯度下降的数理解释"></a>梯度下降的数理解释</h3><p><img src="/img/posts/MachineLearning/slope_definition.jpg" alt="梯度下降的数理解释"></p><p>a是学习率<br>下一步的值 = 这一步的值 - 学习率*代价函数分别对参数a1,a2,a3…的偏导</p><p>对于梯度下降公式中偏导的简化</p><p><img src="/img/posts/MachineLearning/slope_deri0.jpg" alt="符合求偏导"></p><p>梯度下降是一种<strong>同步更新</strong>算法，要求参数a1,a2,a3同步更新，所以<br><img src="/img/posts/MachineLearning/slope_detail0.jpg" alt="要按照左侧的顺序来"></p><h3 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h3><p><img src="/img/posts/MachineLearning/slope_linear.jpg" alt="梯度下降再线性回归中的模型"></p><p>将代数函数用等高线图（右侧）表示</p><p><img src="/img/posts/MachineLearning/slope4.jpg" alt="由于该代数函数是一个凹函数，所以局部极小就是全局最小，因此要得到左侧最拟合的目标函数，需要右侧趋近于等高线图最中间的圆圈"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度下降 </tag>
            
            <tag> 代价函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>识别mnist手写数字数据集</title>
      <link href="/2021/07/11/shi-bie-mnist-shou-xie-shu-zi-shu-ju-ji/"/>
      <url>/2021/07/11/shi-bie-mnist-shou-xie-shu-zi-shu-ju-ji/</url>
      
        <content type="html"><![CDATA[<p>MNIST包含70,000张手写数字图像: 60,000张用于培训，10,000张于测试。图像是灰度的，28x28像素的。<br>识别mnist手写数字及可以视作图像识别的入门学习任务<br>需要准备pytorch环境</p><pre class=" language-Python"><code class="language-Python">import torchimport torchvisionfrom torch.utils.data import DataLoader</code></pre><h2 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h2><pre class=" language-Python"><code class="language-Python">n_epochs = 3 # 整个训练集训练的次数batch_size_train = 64  # 训练集的批次大小batch_size_test = 1000  # 测试机batchsizelearning_rate = 0.01momentum = 0.5log_interval = 10# 对于可重复实验设置随机种子，进行重复实验，设置随机种子random_seed = 1torch.manual_seed(random_seed)</code></pre><p>learning_rate和momentum是我们稍后将使用的优化器的超参数。  </p><h2 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h2><p>直接利用torchvision加载minist数据集，我们将使用batch_size=64进行训练，并使用size=1000对这个数据集进行测试。下面的Normalize()转换使用的值0.1307和0.3081是MNIST数据集的全局平均值和标准偏差，此处我们将它们作为给定值。</p><pre class=" language-Python"><code class="language-Python"> # 下载训练集和测试集, './minist_data'是目录下相对路径 # 记得要设置download为true，不然可能下载到一般突然中断 # train=True是训练集，batch_size=batch_size_traintrain_loader = dataLoader(    torchvision.datasets.MNIST('./mnist_data',train=True, download=True,                          transform= torchvision.transforms.Compose([                              torchvision.transforms.ToTensor(),                              torchvision.transforms.Normalize((0.1307,),(0.3081,))                          ])),    batch_size=batch_size_train, shuffle=True) # train=False是测试集，batch_size=batch_size_testtest_loader = dataLoader(    torchvision.datasets.MNIST('./mnist_data',train=False, download=True,                          transform= torchvision.transforms.Compose([                              torchvision.transforms.ToTensor(),                              torchvision.transforms.Normalize((0.1307,),(0.3081,))                          ])),    batch_size=batch_size_test, shuffle=True)</code></pre><p>下载完成后，在目录./mnist_data/MNIST/raw目录下可以看到这些<br><img src="/img/posts/Programming/mnist0.jpg"></p><p>利用train_loader来看训练数据的组成</p><pre class=" language-Python"><code class="language-Python">examples = enumerate(train_loader)batch_idx, (example_data, example_targets) = nex(examples)print(example_targets)  # example_targets是图片实际对应的数字标签print(example_data.shape)  # 一批训练数据是一个数据张量</code></pre><p>输出结果<br><img src="/img/posts/Programming/mnist1.jpg"></p><p>这意味着我们有64个例子的28x28像素的灰度(即没有rgb通道)。</p><p>尝试用mathplotllib绘制部分</p><pre class=" language-Python"><code class="language-Python">import matplotlib.pyplot as pltfig = plt.figure()for i in range(12):    plt.subplot(3,4,i+1)  # subplot(m,n,i) 说明是m*n的网格表示，i表示每个plot的编号， 这样可以把几张图放在一张图片中表示出来    plt.tight_layout()    plt.imshow(example_data[i][0], cmap='gray', interpolation='none')    plt.title("Ground Truth:{}".format(example_targets[i]))    plt.xticks([])    plt.yticks([])plt.show()</code></pre><p><img src="/img/posts/Programming/mnist2.jpg" alt="输出结果"></p><h2 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
