<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode101--二分查找</title>
      <link href="/2023/04/12/leetcode101-er-fen-cha-zhao/"/>
      <url>/2023/04/12/leetcode101-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></h2><p>给定一个&nbsp;n&nbsp;个元素有序的（升序）整型数组&nbsp;nums 和一个目标值&nbsp;target &nbsp;，写一个函数搜索&nbsp;nums&nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>注意二分查找主要是边界的确定 也就是判断是使用while(left &lt; right)还是whie(left &lt;= right),这个时候就要判断时左闭右闭区间还是左闭右开区间</p><h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span>mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//right初值改变</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//while判断条件改变</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//right改变，因为 右开， 不需要mid-1</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// left不变，因为左闭</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试八股--Java</title>
      <link href="/2023/04/11/mian-shi-ba-gu-java/"/>
      <url>/2023/04/11/mian-shi-ba-gu-java/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的特性"><a href="#Java的特性" class="headerlink" title="Java的特性"></a>Java的特性</h2><p><strong>封装</strong>：把一个对象的属性和方法封装起来，为了提高安全性<br><strong>继承</strong>：子类继承父类的方法和熟悉，Java不支持多继承<br><strong>多态</strong>：同一个类型的对象在指向同一个方法，可能出现多种行为 如 Animal cat = new cat</p><p>实现多态：先继承，再重写父类中的方法，最后向上转型</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>如果一个类加载器收到了类加载请求，它不会自己先去加载，而是把请求委托给父类的加载器，父类加载器再委托给父类的父类加载器，直到到达顶层或者某一层的父类加载器无法完成加载任务</p><p>作用：</p><ol><li>通过类加载器之间的优先级关系，避免重复加载</li><li>提高安全性，避免修改java的核心api</li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>byte，boolean: 一个字节 8 bits<br>short，char: 两个字节 16 bits<br>int，float：四个字节 32 bits<br>long，double：八个字节 64 bits</p><h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>Integer是int的包装类，int只是一种数据类型<br>所以Integer必须经过实例化才能使用，Integer实际上是对象的的引用，每次new一个Integer时，是生成一个指向该对象的指针，而int是直接存储数据的值<br>Integer默认null，int 默认0</p><h3 id="String，StringBuilder，StringBuffer的区别"><a href="#String，StringBuilder，StringBuffer的区别" class="headerlink" title="String，StringBuilder，StringBuffer的区别"></a>String，StringBuilder，StringBuffer的区别</h3><p><a href="https://blog.csdn.net/qq_47183158/article/details/123729517">参考</a></p><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>String底层是<strong>通过char类型</strong>的数据实现的，是被 <strong>final</strong> 修饰的类，不能被继承；String实现了 Serializable 和 Comparable 接口，表示String支持序列化和可以比较大小；所以字符串的值创建之后就不可以被修改，具有不可变性。</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token string">"456"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 打印出来的a为456</span></code></pre><p>因为第二次赋值时会生成一个新的对象，a指向新的实例对象，而之前的实例对象如果不再引用会被当作垃圾回收。</p><p>实例化一个String对象时：string a = “123”;此时的a存在字符串<strong>常量池</strong>中，而new String(“123”)会存在<strong>堆中</strong></p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer代表一个<strong>字符序列可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列，但都不会产生新的对象。通过StringBuffer生成的字符串，可以调用toString()方法将其转换为一个String对象。</p><pre class=" language-java"><code class="language-java">StringBuffer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// b打印结果为：123456</span></code></pre><p>且<strong>StringBuffer是线程安全的</strong>：</p><ol><li><p>StringBuffer类中的方法都添加了synchronized关键字，用来保证线程安全。</p></li><li><p>StringBuffer 每次<strong>获取 toString</strong> 都会<strong>直接使用缓存区的 toStringCache 值来构造一个字符串</strong>。StringBuffer 的这个toString 方法仍然是同步的。</p></li></ol><p>而 StringBuilder 则每次都需要<strong>复制一次字符数组</strong>，再构造一个字符串。<br>3. 性能：StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，<strong>所以StringBuilder 的性能要大于 StringBuffer。</strong></p><p>StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，而 StringBuilder 更适合单线程场合。</p><h5 id="StringBuffer的扩容机制"><a href="#StringBuffer的扩容机制" class="headerlink" title="StringBuffer的扩容机制"></a>StringBuffer的扩容机制</h5><p>StringBuffer和StringBuilder都是继承自AbstractStringBuilder，它们两个的区别在于buffer是线程安全的，builder是线程不安全的，前者安全效率低，后者高效不安全。它们的扩容机制也是这样的区别，所以我们只需要分析一个的扩容就可以了，分析buffer，另一个只用把synchronized关键字去掉就是一样的。</p><ol><li>初始容量</li></ol><p>既然是容器，那么是一定会有个初始容量的，目的在于避免在内存中过度占用内存。容器的初始容量有默认和使用构造函数申明两种。</p><p>StringBuffer类可以创建可修改的字符串序列，该类有以下三个改造方法。</p><p>StringBuffer()的初始容量可以容纳16个字符，当该对象的体存放的字符的长度大于16时，实体容量就自动增加StringBuffer对象可以通过length()方法获取实体中存放的符序列长度，通过 capacity()方法来获取当前实体的实际量。</p><p>StringBuffer(int size)可以指定分配给该对象的实体的初容量参数为参数size指定的字符个数。当该对象的实体存放的符序列的长度大于size个字符时，实体的容量就自动的增加。便存放所增加的字符。<br>StringBuffer(String s)可以指定给对象的实体的初始容量参数字符串s的长度额外再加16个字符。当该对象的实体存放字符序列长度大于size个字符时，实体的容量自动的增加，以存放所增加的字符。</p><ol start="2"><li>扩容实现</li></ol><p>在父类AbstractStringBuilder中,底层是一个字符数组来保存字符串的</p><pre class=" language-java"><code class="language-java"><span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>StringBuffer:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">StringBuffer</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>因此扩容其实是，使用append()方法在字符串后面追加值的时候，如果长度超过了该字符串存储空间大小了就就会先进性扩容。<strong>构建新的并且存储空间更大的字符串</strong>，将旧的复制过去。</p><blockquote><p>扩容规则：<br>    先原始容量 * 2 + 2（加2是因为拼接字符串通常末尾都会有个多余的字符）<br>    如果扩容了之后，容量够用，新的容量就为扩容之后的容量。<br>    如果扩容了之后，容量不够用，新的容量就是所需要的容量，即原始字符串长度加上新添加的字符串长度。<br>    扩容完成之后，将原始数组复制到新的容量中，然后将新的字符串添加进去</p></blockquote><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p><strong>StringBuilder</strong>: 也代表可变字符串对象，这点和StringBuffer很相似，但StringBuilder不是线程安全的</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>参数化类型–把一种明确的工作推迟到<strong>实际创建对象</strong>时才确定名曲的数据类型<br>如：ArrayList<object> arr = new Arraylist&lt;&gt;()<br>各种泛型类：List，Set，Map<p></p><h2 id="java的四种引用类型"><a href="#java的四种引用类型" class="headerlink" title="java的四种引用类型"></a>java的四种引用类型</h2><p>强引用:</p></object></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目问答--分布式订票系统项目</title>
      <link href="/2023/04/11/xiang-mu-wen-da-fen-bu-shi-ding-piao-xi-tong-xiang-mu/"/>
      <url>/2023/04/11/xiang-mu-wen-da-fen-bu-shi-ding-piao-xi-tong-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><ol><li><p>用户注册和登录功能测试用例<br>检查用户注册时输入的用户名、密码等信息是否合法；<br>检查用户登录时输入的用户名、密码是否正确；<br>检查用户登录后是否可以正常进入系统；<br>检查用户登录后是否可以退出系统；<br>检查用户登录后是否可以修改个人信息；<br>检查用户登录后是否可以查看订单历史记录。</p></li><li><p>票务查询和购买功能测试用例<br>检查用户可以根据起点站和终点站查询车票；<br>检查用户可以选择购买某个车次的车票；<br>检查用户可以选择座位类型和数量；<br>检查用户购买车票后系统能够正确扣除相应的余额；<br>检查用户购买车票后系统能够正确更新余票数量。</p></li><li><p>订单管理功能测试用例<br>检查用户可以查看当前的订单列表；<br>检查用户可以查看某个订单的详细信息；<br>检查用户可以取消某个未出行的订单；<br>检查用户可以退票并获得相应的退票金额；<br>检查用户可以重新预定某个已取消的订单。</p></li><li><p>数据库备份和同步功能测试用例<br>检查数据库备份是否正常；；<br>检查数据库备份和同步的时间间隔是否合理；<br>检查数据库备份和同步的数据完整性和一致性。</p></li><li><p>网络服务和数据库分布式部署功能测试用例<br>检查网络服务的故障转移是否正常；<br>检查数据库分布式部署的数据同步是否正常；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测开 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目问答--Unity项目who am I</title>
      <link href="/2023/04/11/xiang-mu-wen-da-unity-xiang-mu-who-am-i/"/>
      <url>/2023/04/11/xiang-mu-wen-da-unity-xiang-mu-who-am-i/</url>
      
        <content type="html"><![CDATA[<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>在白盒测试中，我们将关注角色攻击的各种状态和技能的具体实现，编写针对代码的测试用例。</p><ol><li><p>静止状态测试用例<br>检查角色在静止状态下是否可以使用技能；<br>检查角色在静止状态下是否可以切换到移动状态；<br>检查角色在静止状态下是否可以切换到跑动状态；<br>检查角色在静止状态下是否可以攻击敌人；<br>检查角色在静止状态下是否可以受到敌人的攻击。</p></li><li><p>移动状态测试用例<br>检查角色在移动状态下是否可以使用技能；<br>检查角色在移动状态下是否可以切换到静止状态；<br>检查角色在移动状态下是否可以切换到跑动状态；<br>检查角色在移动状态下是否可以攻击敌人；<br>检查角色在移动状态下是否可以受到敌人的攻击。</p></li><li><p>跑动状态测试用例<br>检查角色在跑动状态下是否可以使用技能；<br>检查角色在跑动状态下是否可以切换到静止状态；<br>检查角色在跑动状态下是否可以切换到移动状态；<br>检查角色在跑动状态下是否可以攻击敌人；<br>检查角色在跑动状态下是否可以受到敌人的攻击。</p></li><li><p>释放技能状态测试用例<br>检查角色在释放技能状态下是否可以攻击敌人；<br>检查角色在释放技能状态下是否可以受到敌人的攻击；<br>检查角色在释放技能状态下技能释放是否正常；<br>检查角色在释放技能状态下是否可以正常切换状态；<br>检查角色在释放技能状态下技能的读条是否正常。</p></li><li><p>技能测试用例<br>针对四种技能，我们需要编写具体的测试用例来测试技能的具体实现：</p></li></ol><p>检查技能释放的动画效果是否正常；<br>检查技能对敌人造成的伤害是否正确；<br>检查技能的范围是否正确；<br>检查技能的冷却时间是否正常；<br>检查需要读条的技能读条的时间是否正常；<br>检查技能的持续时间是否正常。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><ol><li><p>攻击敌人测试用例<br>检查角色攻击敌人时，敌人是否会受到相应的伤害；<br>检查角色攻击敌人时，敌人的状态是否会发生相应的变化；<br>检查角色攻击敌人时，角色的状态是否会发生相应的变化；<br>检查角色攻击敌人时，攻击的范围是否正确；<br>检查角色攻击敌人时，攻击的次数是否正确；<br>检查角色攻击敌人时，攻击的速度是否正确。</p></li><li><p>技能测试用例<br>检查使用技能时，技能释放是否成功；<br>检查使用技能时，技能对敌人是否造成了相应的伤害；<br>检查使用技能时，技能的范围是否正确；<br>检查使用技能时，技能的冷却时间是否正确；<br>检查使用技能时，需要读条的技能读条的时间是否正确；<br>检查使用技能时，技能的持续时间是否正确。</p></li><li><p>状态转换测试用例<br>检查角色在不同的状态下，是否可以进行相应的操作；<br>检查角色在不同的状态下，是否可以进行正确的状态转换；<br>检查角色在不同的状态下，是否可以受到正确的攻击；<br>检查角色在不同的状态下，是否可以对敌人进行正确的攻击；<br>检查角色在不同的状态下，是否可以对技能进行正确的释放。</p></li><li><p>用户体验测试用例<br>检查游戏中角色攻击的流畅性和稳定性；<br>检查游戏中角色攻击的音效和视觉效果是否正常；<br>检查游戏中角色攻击的操作是否容易上手；<br>检查游戏中角色攻击的难度是否适当；<br>检查游戏中角色攻击的交互是否友好。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 测开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-树</title>
      <link href="/2023/04/10/leetcode101-shu/"/>
      <url>/2023/04/10/leetcode101-shu/</url>
      
        <content type="html"><![CDATA[<p>二叉树的遍历( traversing binary tree )是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><ol><li>先序遍历<br> 先序遍历(PreOrder) 的操作过程如下：<br> 若二叉树为空，则什么也不做，否则，<br> 1)访问根结点;<br> 2)先序遍历左子树;<br> 3)先序遍历右子树</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根节点</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>中序遍历<br> 中序遍历( InOrder)的操作过程如下：<br> 若二叉树为空，则什么也不做，否则，<br> 1)中序遍历左子树;<br> 2)访问根结点;<br> 3)中序遍历右子树。</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根结点</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>后序遍历</li></ol><p> 后序遍历(PostOrder) 的操作过程如下：<br> 若二叉树为空，则什么也不做，否则，<br> 1)后序遍历左子树;<br> 2)后序遍历右子树;<br> 3)访问根结点。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历右子树</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根结点</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>二叉树可以通过<strong>遍历序列</strong>构造</p><p>由二叉树的<strong>先序序列</strong>和<strong>中序序列</strong>可以唯一地确定一棵二叉树。<br>在先序遍历序列中,第一个结点一定是二叉树的根结点;而在中序遍历中,根结点必然将中序序列分割成两个子序列,前一个子序列是根结点的左子树的中序序列,后一个子序列是根结点的右子树的中序序列。根据这两个子序列,在先序序列中找到对应的左子序列和右子序列。在先序序列中,左子序列的第一个结点是左子树的根结点,右子序列的第一个结点是右子树的根结点。<br>如此递归地进行下去,便能唯一地确定这棵二叉树<br>同理,由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。<br>因为后序序列的最后一个结点就如同先序序列的第一个结点,可以将中序序列分割成两个子序列,然后采用类似的方法递归地进行划分,进而得到一棵二叉树。<br>由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树。<br>要注意的是,若只知道二叉树的先序序列和后序序列,则无法唯一确定一棵二叉树。<br>例如,求先序序列( ABCDEFGHI)和中序序列(BCAEDGHFI）所确定的二叉树<br>首先,由先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列,EDGHFI为右子树的中序序列。然后由先序序列可知B是左子树的根结点,D是右子树的根结点。以此类推,就能将剩下的结点继续分解下去,最后得到的二叉树如图所示。<br><img src="/img/posts/Leetcode/binarytree.jpg"></p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p><img src="/img/posts/Leetcode/leetcode94.jpg"></p><p>虽然给的是要返回List，但可以自己写一个inorder来进行递归</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子节点递归</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 根节点</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右子节点</span>    <span class="token punctuation">}</span></code></pre><h2 id="98-验证二叉搜索数"><a href="#98-验证二叉搜索数" class="headerlink" title="98.验证二叉搜索数"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98.验证二叉搜索数</a></h2><p><img src="/img/posts/Leetcode/leetcode98.jpg"></p><p>注意 <strong>root.left&lt;root.left.right&lt;root</strong>，因此可以给每个值设置一个max和min，每次迭代时更新：<br><img src="/img/posts/Leetcode/leetcode98_false.jpg" alt="因为4<5，但4是5的右子树中的节点，所有为false"></p><ol><li>若该节点为左子节点，max更新为root.val，min保持（因为该节点可能是上上一个节点的右节点，保存上上个节点的值为最小值）</li><li>若为右节点，则反之</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> min <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义边界，注意等于号！！</span>        <span class="token keyword">long</span> max <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">return</span> <span class="token function">judge</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> min<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judge</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token operator">||</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val <span class="token operator">||</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">>=</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当左节点不为空，且左子节点大于根节点或小于最小值 || 当右节点不为空，且右节点大于最大值或小于根节点时 为false</span>        <span class="token keyword">return</span> <span class="token function">judge</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">judge</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门</title>
      <link href="/2023/04/09/django-ru-men/"/>
      <url>/2023/04/09/django-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>进入虚拟环境 pip install django<br>打开anaconda，cd 到一个你想放置你代码的目录，输入：</p><pre class=" language-cmd"><code class="language-cmd">        django-admin startproject web</code></pre><p>在该目录下会新建一个web项目存在<br>|web/<br>|── manage.py<br>|── web/<br>|       ├── <strong>init</strong>.py<br>|       | settings.py<br>|       | urls.py<br>|       | asgi.py<br>|       | wsgi.py</p><p>分别的用处：<br>这些目录和文件的用处是：</p><p>最外层的 <strong>web/ 根目录</strong>只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。<br><strong>manage.py</strong>: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin 和 manage.py 获取所有 manage.py 的细节。<br><strong>里面一层的 web/ 目录</strong>包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 myweb.urls).<br><strong>web/<strong>init</strong>.py：</strong>一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。<br><strong>web/settings.py：</strong>Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。<br><strong>web/urls.py：</strong>Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。<br><strong>web/asgi.py：</strong>作为你的项目的运行在 ASGI 兼容的 Web 服务器上的入口。阅读 如何使用 ASGI 来部署 了解更多细节。<br><strong>web/wsgi.py：</strong>作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。<br>在该目录下运行</p><pre class=" language-cmd"><code class="language-cmd">py manage.py runserver</code></pre><p>在localhost:8000上部署成功<br>如果想要换端口，就输入py manage.py runserver+端口。<br>如果想要用ip地址访问（也称为远程访问），需要在8080前加上0.0.0.0:<br>也就是</p><pre class=" language-cmd"><code class="language-cmd">py manage.py runserver 0.0.0.0:8080</code></pre><p>然后可以在浏览器输入本机ip：8080访问</p><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><pre class=" language-cmd"><code class="language-cmd">python manage.py startapp myapp</code></pre><p>myapp目录如下：</p><p>|web项目根目录<br>├── myapp应用名称<br>│   ├── migrations数据模型迁移记录目录<br>│   │   └── <strong>init</strong>.pyinti文件，标识当前所在的数据模型迁移记录目录是一个 Python 包<br>│   ├── <strong>init</strong>.pyinti文件，标识当前所在的应用目录是一个 Python 包<br>│   ├── admin.pyDjango Admin 应用的配置文件<br>│   ├── apps.py应用程序本身的属性配置文件<br>│   ├── models.py用于定义应用中所需要的数据表的配置文件<br>│   ├── tests.py用于编写当前应用程序的单元测试的测试文件<br>│   └── views.py用来定义视图处理函数的文件<br>├── web项目名称<br>│   ├── <strong>init</strong>.py<br>│   ├── settings.py<br>│   ├── urls.py<br>│   └── wsgi.py<br>└── manage.py</p><p>migrations 数据模型迁移记录目录：migrations 目录用于存储数据库迁移时生成的文件，该目录下的 <strong>init</strong>.py 文件标识 migrations 是一个 Python 包。</p><p>admin.py 文件：admin.py 用于将 Model 定义的数据表注册到管理后台，是 Django Admin 应用的配置文件；</p><p>apps.py 文件：apps.py 用于应用程序本身的属性配置文件；</p><p>models.py 文件：models.py 用于定义应用中所需要的数据表；</p><p>tests.py 文件：tests.py 用于编写当前应用程序的单元测试；</p><p>views.py 文件：views.py 用来定义视图处理函数的文件；</p><h3 id="添加项目"><a href="#添加项目" class="headerlink" title="添加项目"></a>添加项目</h3><p>在settings.py中</p><pre class=" language-python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'myapp'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 添加应用</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的cmd命令</title>
      <link href="/2023/04/04/chang-yong-de-cmd-ming-ling/"/>
      <url>/2023/04/04/chang-yong-de-cmd-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>netstat -ano|findstr “8080”<br>可用于查找8080端口是否被占用，若出现  TCP    [::]:8080              [::]:0                 LISTENING       40788</p><p>可用tasklist|findstr “40788”找到该进程名，假设进程为01.exe</p><p>可用taskkill /f /t /im 01.exe 强制结束该进程</p><p>net start mysql80可启动mysql服务</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本数据结构</title>
      <link href="/2023/04/04/c-ji-ben-shu-ju-jie-gou/"/>
      <url>/2023/04/04/c-ji-ben-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h3><ol><li>不存在空引用，但可以有空指针。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ol><p>在64位系统中地址的总线宽度是8个字节，32位系统4个字节，所以32位系统中一个指针式4个bit，64位系统上是8个bit</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">&amp;</span>s <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"i: "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s："</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"p: "</span><span class="token operator">&lt;&lt;</span>p<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>输出：<br> i: 0x61ff04<br> s：0x61ff04<br> p: 0x61ff04</p></blockquote><p> 引用分配到内存和指针指向的内存都是同一块内存</p><p> C++中用引用传参更加安全，如swap(&amp;a,&amp;b)</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能</p><ol><li>struct能包含成员函数</li><li>struct能继承</li><li>struct能实现多态</li></ol><p>结构体和类最本质的一个区别就是默认的访问控制： </p><p>默认的继承访问权限：struct是public的，class是private的</p><p>C++中，不使用结构体丝毫不会影响程序的表达能力。C++之所以要引入结构体，是为了保持和C程序的兼容性</p><p>但有时仍会在C++中使用结构体，是因为可以使用结构体将不同类型数据组成整体，方便于保存数据(若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦)</p><p>struct可以继承class，同样class也可以继承struct</p><p>struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它们并无区别</p><p>概念：class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到<br>类型：<strong>struct是值类型，class是引用类型</strong>，因此它们具有所有值类型和引用类型之间的差异<br>效率：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑<br>关系：struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存分成5个区，<strong>堆，栈，自由存储区，全局/静态存续区，常量存续区</strong>。</p><p>栈区(stack sagment)：由<strong>编译</strong>器自动分配释放，存放<strong>函数的参数的值，局部变量的值</strong>等。在Windows下，栈是向低地址扩展的数据结构，是一块<strong>连续的内存的</strong>区域。这句话的意思是<strong>栈顶的地址和栈的最大容量是系统预先规定好的</strong>，在Windows下，栈的大小是1M，如果申请的空间超过栈的剩余空间时，将提示stack overflow。因此，能从栈获得的空间较小。</p><p>堆区(heap sagment) ：程序<strong>运行时动态内存分配</strong>，堆是可以上增长的。 一般由程序员分配释放，内存使用new进行分配，使用delete或delete[]释放。如果未能对内存进行正确的释放，会造成内存泄漏。但在程序结束时，会由操作系统自动回收。它与数据结构中的堆是两回事。<strong>堆是向高地址扩展的数据结构，是不连续的内存区域</strong>。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>自由存储区：使用malloc进行分配，使用free进行回收。</p><p>全局/静态存储区：<strong>全局变量和静态变量被分配到同一块内存中</strong>，C语言中区分初始化和未初始化的，C++中不再区分了。（全局变量、静态数据 存放在全局数据区）</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>构造函数–初始化对象时执行<br>析构函数在每次删除所创建的对象时执行，它<strong>不会返回任何值，也不能带有任何参数</strong>。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">test</span><span class="token punctuation">{</span>       <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token function">test</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>test<span class="token operator">::</span><span class="token function">test</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"create test:"</span><span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>test<span class="token operator">::</span><span class="token operator">~</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"delete test"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        test <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"test 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world, %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>输出<br> create test:test 1<br> hello world, 10<br> delete test</p></blockquote><h4 id="实例化方法"><a href="#实例化方法" class="headerlink" title="实例化方法"></a>实例化方法</h4><h5 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h5><pre class=" language-cpp"><code class="language-cpp">test <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建在栈里</p><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><pre class=" language-cpp"><code class="language-cpp">    test<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"hello:"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> t<span class="token punctuation">;</span></code></pre><p>指针形式，常用于初始化链表头。<br>创建在堆里，需要自己手动释放内存</p><p>使用new的方式，如果对象没有初始化，此时没有分配内存空间，也无法delete。<br>不要new一个null对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>class derived-class: access-specifier base-class</p></blockquote><p>访问修饰符是public，protected，private</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 基类</span><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// eat() 函数</span>    <span class="token comment" spellcheck="true">// sleep() 函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//派生类</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token operator">:</span> <span class="token keyword">public</span> Animal <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// bark() 函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><strong>public</strong>: 可以被类以外成员访问<br><strong>private</strong>： 只可以被类和友元函数访问，要想修改相应的参数或操作，只能通过类中public函数和友元函数，类中成员默认是private<br><strong>protected</strong>： 可以被派生类访问</p><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>拷贝是指将一个对象的值或状态复制到另一个对象中，使得两个对象在某些方面具有相同的特性。</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>拷贝构造函数必须<strong>是当前类的引用</strong><br><strong>拷贝构造函数是const 引用</strong></p><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> x<span class="token punctuation">;</span>  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 普通构造函数</span>  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 拷贝构造函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyClass <span class="token class-name">obj1</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用普通构造函数创建对象</span>MyClass <span class="token class-name">obj2</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用拷贝构造函数创建对象</span></code></pre><p>在创建对象 obj1 时，使用了普通构造函数，将参数值 42 赋值给成员变量 x；在创建对象 obj2 时，使用了拷贝构造函数，将对象 obj1 的值复制到新对象 obj2 中。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝（shallow copy）是指将<strong>对象的所有成员变量直接复制到另一个对象中，包括指针类型成员变量所指向的内存地址</strong>。因此，如果两个对象共用同一块内存地址，那么<strong>它们之间的关系就会非常紧密，任何一方的修改都会影响到另一方。</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> other<span class="token punctuation">.</span>str<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyString <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyString <span class="token function">str2</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 浅拷贝</span>str1<span class="token punctuation">.</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str1<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Hello"</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str2<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Hello"</span></code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝（deep copy）是指将对象的所有成员变量复制到另一个对象中，并<strong>为指针类型成员变量分配新的内存空间，将原来指向的内存数据复制到新的内存空间中。</strong>因此，深拷贝可以避免共用内存带来的问题。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//分配新的内存空间</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> other<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyString <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyString <span class="token function">str2</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 深拷贝</span>str1<span class="token punctuation">.</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str1<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Hello"</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str2<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "hello"</span></code></pre><h2 id="数据结构-容器"><a href="#数据结构-容器" class="headerlink" title="数据结构(容器)"></a>数据结构(容器)</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>内存空间连续的一段地址，无法改变大小</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;array></span> </span><span class="token comment" spellcheck="true">//头文件</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">></span> myarray<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>myarray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    myarray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//赋值</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> myarray<span class="token punctuation">.</span>begin<span class="token punctuation">;</span>it<span class="token operator">!=</span>myarray<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//遍历</span>cout<span class="token operator">&lt;&lt;</span>myarray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取特定数值</span></code></pre><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>动态数组</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;vector></span> </span><span class="token comment" spellcheck="true">// 头文件</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myvector<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加元素</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> myvector<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> isEmpty <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myvector<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在末尾插入五个3</span>myvector<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除末尾元素</span>myvector<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回第一个元素</span>iterator it <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取迭代首地址</span></code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;list></span></span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mylist</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>num<span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//使用数组创建list</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> mylist<span class="token punctuation">.</span>begin<span class="token punctuation">;</span>it<span class="token operator">!=</span>mylist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//遍历</span><span class="token keyword">auto</span> it <span class="token operator">=</span> mylist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mylist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入</span><span class="token punctuation">}</span></code></pre><p>都大差不差</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Link<span class="token punctuation">{</span>    <span class="token keyword">char</span> elem<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//代表数据域</span>    <span class="token keyword">struct</span> Link <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//代表指针域，指向直接后继元素</span><span class="token punctuation">}</span>link<span class="token punctuation">;</span></code></pre><p>双向链表</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//C++双向链表模板</span><span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> ListNode    <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>next<span class="token punctuation">,</span><span class="token operator">*</span>prev<span class="token punctuation">;</span>        <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//复制val->x,next->nullptr,prev->nullptr</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//头节点尾节点都为空，表示为空链表</span>    ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span><span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实现反转链表</p><pre class=" language-cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> nex <span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            nex <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//提前该语句</span>            cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>            cur<span class="token operator">=</span>nex<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// nex = cur->next;//当cur为空指针时该语句会报错，运行超时，需要将该语句提前</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>deque:前后两端都可以进行数据的插入和删除，至此数据的快速随机访问</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;deque></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> D<span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//赋值</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>D<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span>        <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在索引为1的地方插入10</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>D<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span>        <span class="token punctuation">}</span>    D<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在头部插入</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>D<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span>        <span class="token punctuation">}</span>    D<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//头部弹出</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>输出<br> 1 2 3<br> 1 10 2 3<br> -1 1 10 2 3 </p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>后入先出LIFO<br>动态实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> SqStack_dynamic<span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> base<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈底 </span>    <span class="token keyword">int</span><span class="token operator">*</span> top<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶 </span><span class="token punctuation">}</span>SqStack_dynamic<span class="token punctuation">;</span></code></pre><p>静态实现</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> SqStack_static<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶 </span><span class="token punctuation">}</span>SqStack_static<span class="token punctuation">;</span></code></pre><p>STL中的栈</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> S<span class="token punctuation">;</span>    S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> my_map<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//三种插入的方式</span>    my_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//插入pair对</span>    my_map<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"insert second"</span><span class="token punctuation">;</span>    my_map<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ten"</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> my_map<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>my_map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//it->first得到第一个的值，it->second得到第二个的值</span>    <span class="token comment" spellcheck="true">//map的删除</span>    my_map<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除2</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> my_map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    my_map<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//删除找到的10</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set也是一种关联性容器，它同map一样，底层使用红黑树实现，插入删除操作时仅仅移动指针即可，不涉及内存的移动和拷贝，所以效率比较高。从中文名就可以明显地看出，<strong>在set中不会存在重复的元素</strong>，若是保存相同的元素，将直接视为无效。</p><p>unordered_set常用：<br><strong>insert</strong>:插入指定元素<br><strong>erase</strong>: 删除指定元素<br><strong>find</strong>:查找指定元素<br><strong>size</strong>,获取容器中元素的数量<br><strong>empty</strong>:判断是否为空<br><strong>swap</strong>:交换</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> us<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入元素（去重）</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历容器方式一（范围for）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> us<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1 4 3 2</span>    <span class="token comment" spellcheck="true">//删除元素方式一</span>    us<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除元素方式二</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator pos <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查找值为1的元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历容器方式二（迭代器遍历）</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        it<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//4 2</span>    <span class="token comment" spellcheck="true">//容器中值为2的元素个数</span>    cout <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span>    <span class="token comment" spellcheck="true">//容器大小</span>    cout <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span>    <span class="token comment" spellcheck="true">//清空容器</span>    us<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//容器判空</span>    cout <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span>    <span class="token comment" spellcheck="true">//交换两个容器的数据</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> us<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//11 22 33 44</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101--链表</title>
      <link href="/2023/04/03/leetcode101-lian-biao/"/>
      <url>/2023/04/03/leetcode101-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/submissions/">206.反转链表</a></h2><p><img src="/img/posts/Leetcode/leetcode206.jpg"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化判断头和头的下一个是否为空，若空，直接返回</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//新建一个cur用来记录现在的</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            ListNode pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>，<span class="token comment" spellcheck="true">//每次新建一个pre，存放head的下一个，然后把pre指向cur，实现翻转</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="21-合并有序链表"><a href="#21-合并有序链表" class="headerlink" title="21.合并有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21.合并有序链表</a></h2><p><img src="/img/posts/Leetcode/leetcode21.jpg"></p><blockquote><p>动态规划＋递归<br> 先判断l1.val和l2.val，确定现在是l1还是l2，若是l1, 要确定下一个merge(l1.next,l2)，返回了l1</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode list1<span class="token punctuation">,</span> ListNode list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            list1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> list2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            list2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></h2><p><img src="/img/posts/Leetcode/leetcode24.jpg"></p><blockquote><p>逆向思维–递归<br> 拆分任务–每两个互相交换，也就是每两个都要实现head.next指向swap(next.next),next.next指向head<br> 确定终止条件 – head==null||next==null</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// head的下一个是next之后的节点继续交换</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p><img src="/img/posts/Leetcode/leetcode24.jpg"></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>很巧妙的方法，<strong>把指针A和B同时连续遍历A、B两个链表</strong><br>pointerA -&gt; AB<br>pointerB -&gt; BA<br>假设A到交点需要a步，B到交点需要b步，交点到终点需要b步：<br>pointerA从起点到第二次走到交点：a+c+b<br>pointerB从起点到第二次走到交点：b+c+a<br>第二次就相遇</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode pointerA <span class="token operator">=</span> headA<span class="token punctuation">;</span>        ListNode pointerB <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pointerA<span class="token operator">!=</span>pointerB<span class="token punctuation">)</span><span class="token punctuation">{</span>            pointerA <span class="token operator">=</span> pointerA <span class="token operator">==</span> null<span class="token operator">?</span> headB<span class="token operator">:</span>pointerA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pointerB <span class="token operator">=</span> pointerB <span class="token operator">==</span> null<span class="token operator">?</span> headA<span class="token operator">:</span>pointerB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pointerA<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234.回文链表</a></h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br>可以将链表复制到<strong>Arraylist</strong>中国，直接通过下标比较</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>head<span class="token operator">!=</span>null<span class="token punctuation">;</span>head<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>            array<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">--</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">!=</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础概念</title>
      <link href="/2023/04/02/shu-ju-ku-ji-chu-gai-nian/"/>
      <url>/2023/04/02/shu-ju-ku-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><strong>键</strong></p><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。比如一张学生信息表，学生表中含有学号或者身份证号的任意组合都称为此表的超键。如：（学号），（学号，姓名），（身份证号，性别）等；</p><p>1.候选键（candidate key）：一个或者多个属性的组合，能够唯一确定实体的一个实例。不含多余属性的超键称为候选键；</p><p>2.主键（primary key）:从候选键中，选中用来作为唯一标识的属性或者属性组，被称为主键。（员工的编号可以作为主键）</p><p>3.可选键（alternative key）：候选键中，没有选中的其他键，可以称之为可选键。（员工电子邮件</p><p>学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）</p><p>超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！</p><p>候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！</p><p>主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了！</p><p>外键：宿舍号就是学生信息表的外键</p><p><strong>范式</strong></p><p>第一范式（1NF）<br>在关系模型中，对于添加一个规范的要求，所有的域都是原子性的，即数据库的每一个项都是不可分割的原子数据项，而不能是集合、数组、记录等非原子的数据项。<br>实现某个属性有多个值时，必须拆分为不同的属性，第一范式无重复的域。</p><p>第二范式（2NF）<br>第二范式就是在第一范式的基础上完全依赖于主键。消除了部份依赖。（<br>数据库表中的每个实例或记录必须可以被唯一的区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一表示。<br>例如，学生号可以实现每一个学生的区分，学生号就是候选键。找不到候选键，就要增加额外属性实现区分。</p><p>第三范式（3NF）<br>：1. 满足第二范式 2. R中的非主属性对主键有传递性的依赖（表中的非主属性之间不能functionally determined by另一个非主属性）<br>General说法（这个比较好记）:1. 满足第二范式 2. R中的所有非主属性都是fully functionally dependent on R上的每个key 3. R中的所有非主属性都是non-transitively dependent onR上的每个key<br>例如，班级表，班级编号class_Id，年级信息等；那么在学生表中，列出班级编号后就不再显示年级信息等。</p><p>巴斯-科德范式（BCNF）<br>在3NF的基础上，任何主属性不能对主属性子集依赖，即在3NF基础上消除对主码子集的依赖。<br>BCNF没有加入新的设计规范，只是对第二范式和第二范式的设计规范要求更强，因此被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，是数据库冗余度更小。</p><p><strong>依赖关系</strong><br>部分依赖<br>通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p><p>完全依赖<br>通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB。</p><p>传递依赖</p><p>传递的依赖：（transitive dependency）<br>通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么说C传递依赖于A。<br>严格传递依赖：我们称C对属性A严格传递依赖当他满足： A-&gt;B, B-&gt;C, B-/-&gt;A, C-/-&gt;B<br>只有两个属性的时候属性，不能说transitive dependency</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -MySQL -数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC与mysql锁机制</title>
      <link href="/2023/04/01/jdbc-yu-mysql-suo-ji-zhi/"/>
      <url>/2023/04/01/jdbc-yu-mysql-suo-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p>ACID，即原子性、一致性、隔离性和持久性。</p><ul><li><p>原子性：要么全部提交（commit后写日志），要么全部失败（回滚事务）。保证十五的原子性要求在发生异常是，对事务所有执行过的操作进行回滚，回滚是通过<strong>回滚日志</strong>实现。回滚日志种记录了所有操作的逆操作，因此回滚就是将该事务回滚日志种的所有操作再执行一遍。</p></li><li><p>隔离性：该会话事务内部的SQL操作及操作的数据库对象<strong>与并发的其它会话事务是隔离的</strong>。<strong>事务的隔离级别是由数据库</strong>提供的,数据库隔离级别在服务器端保证客户端用户一定不会发生哪些并发冲突。方法有：隐式锁、多版本（MVCC）等。应用场景是数据库多并发控制</p></li><li><p>一致性：是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束（触发器等）。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性，这就是“一致”的意思。应用场景是：但用户场景</p></li><li><p>持久性：事务一旦提交，对数据库的改变是永久的，被提交后就<strong>无法回滚</strong>。事务的持久性也是事务日志保证的</p></li></ul><h3 id="并发冲突"><a href="#并发冲突" class="headerlink" title="并发冲突"></a>并发冲突</h3><h4 id="读不一致"><a href="#读不一致" class="headerlink" title="读不一致"></a>读不一致</h4><p>读不一致性本质上是读写操作的不一致性</p><p><strong>脏读</strong>：一个事务读取了另一个事务<strong>未提交</strong>的数据。当事务A查询事物B修改后但是未提交的数据时，事物B有可能会因为某些情况进行回滚，此时事物A读到的数据就是错的，这是的数据也称之为脏数据。它是对一条记录而言的。脏读本质上是读写操作的冲突，<strong>解决办法是写完之后再读。</strong></p><p><strong>不可重复读</strong>：一个事务<strong>两次读取同一个数据</strong>，两次读取的<strong>数据不一致</strong>。当事务A查询第一次是，事物B虽然修改了数据但是没有提交，此时事物A查询的还是之前未修改的值，但是当事物B提交后，事物A第二次查询，此时查询到的值是事物B修改后的值，这次查询的值不一样，即读取的数据不一致。它是对一条记录而言的。不可重复读本质上是读写操作的冲突，<strong>解决办法是读完再写。</strong></p><p><strong>幻读</strong>：一个事务<strong>两次读取一个范围的记录，两次读取的记录数不一致。</strong>假设事务A第一次查询一段范围的rows中的某数据时，此时有5列。但是之后又另外一个事物B增加了一列，当事物A再次进行相同的查询时，发现有6列，这就是所谓的幻读。<strong>它是对多条记录而言的</strong>。幻读本质上是读写操作的冲突，解决办法是<strong>读完再插入/删除。</strong></p><h4 id="写不一致"><a href="#写不一致" class="headerlink" title="写不一致"></a>写不一致</h4><p>写不一致性本质上是写写操作的不一致性<br>出现<strong>丢失修改</strong>（一个事务的更新覆盖了另一个事务的更新）。事务A和事务B需要对同一个row的元素进行修改。A和B同时读到该row的的数据，分别修改，后提交的事务B覆盖了事务A的更新。更新丢失本质上是写写操作的冲突，解决办法是<strong>一个一个地写。</strong><br>防止丢失修改的并发控制类型常见的有三种方法：</p><ol><li>加锁（保守式并发控制）- 在从获取记录直到记录在数据库中更新的这段时间内，该行对用户不可用。</li><li>开放式并发控制（原始值） - 只有当实际更新数据时，该行才对其他用户不可用。更新将在数据库中检查该行并确定是否进行了任何更改。如果试图更新已更改的记录，则将导致并发冲突。</li><li>最后的更新生效 - 只有当实际更新数据时，该行才对其他用户不可用。但是，不会将更新与初始记录进行比较；而只是写出记录，这可能就改写了自上次刷新记录后其他用户所进行的更改。</li></ol><h3 id="为什么要MySQL锁"><a href="#为什么要MySQL锁" class="headerlink" title="为什么要MySQL锁"></a>为什么要MySQL锁</h3><p>要控制数据库中的事务并发性需要使用MySQL中的锁，注意Synchronized这种只能用于控制Java代码块的并发访问，但不能控制数据库的并发访问</p><p>MySQL 提供了多种锁机制，包括<strong>共享锁（Shared Lock）和排他锁（Exclusive Lock）</strong>等。其中，<strong>共享锁用于防止其他事务对资源进行写操作，而排他锁则用于防止其他事务对资源进行读写操作。</strong></p><p>在 JDBC 中，可以通过以下方式来使用 MySQL 锁机制：</p><ol><li><p>通过设置 SQL 语句的 Isolation Level 属性来指定事务的隔离级别，从而控制并发访问。</p></li><li><p>在 SQL 语句中使用 Lock In Share Mode（共享锁）或 For Update（排他锁）等关键字来控制锁机制。</p></li></ol><h3 id="多用户场景下并发控制的手段"><a href="#多用户场景下并发控制的手段" class="headerlink" title="多用户场景下并发控制的手段"></a>多用户场景下并发控制的手段</h3><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><blockquote><p>使用<strong>隔离级别</strong>:一个会话事务对数据库的存取与并发的另一个会话事务的隔离程度。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 并发一致性就越好, 但并发性越弱。</p></blockquote><p>数据库中，事务隔离级别（Transaction Isolation Level）指的是多个事务同时执行时，各自之间的隔离程度。数据库系统提供了四种事务隔离级别，分别为：</p><p>1.读未提交（RU）<br>具有Read uncommitted隔离级别的事务，<strong>允许读取未被其他事务提交的变更</strong>，可能出现脏读、不可重复读、幻读，以及丢失修改。选择Read uncommitted的原因是，在只读的历史数据库中，可以提高效率。<br>2. 读已提交（RC）<br>具有Read committed隔离级别的事务，确保只允许读取已经被其他事务提交的变更。<br>当隔离级别设置为Read committed时，避免了脏读，但是可能出现不可重复读、幻读，丢失修改。大多数数据库的默认隔离级别是Read committed，比如Sql Server , Oracle。<br>3. 可重复读（RR）<br>具有Repeatable read隔离级别的事务，可以确保多次从一个记录中读取相同的值，在这个事务持续期间，禁止其他事务对这条记录进行更新。隔离级别设置为Repeatable read时，可以避免脏读、不可重复读。但是可能出现幻读。MySQL的默认隔离级别就是Repeatable read。<br>4.串行化（S）<br>具有Serializable隔离级别的事务，<strong>可以确保从一个表中读取相同的行数，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，</strong>但性能十分低。<br><strong>Serializable是最高的事务隔离级别，提供了最高程度的隔离性，</strong>同时代价也花费最高，性能很低，这个隔离级别通常会降低并发性，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读和丢失修改。如果事务隔离级别设置为SERIALIZABLE，具有SERIALIZABLE隔离级别的事务开始之后，不会看到数据库中其它会话事务作出的任何修改，直到提交SERIALIZABLE事务为止</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>使用锁的原则：在满足完整性约束、业务需求，解决多事务并发冲突，保证数据正确性的前提下，尽可能<strong>减少阻塞和避免死锁</strong>，提高事务的并发性，保证程序的并发质量</p><p><strong>避免阻塞</strong>的手段：</p><ol><li>总原则是<strong>缩小锁粒度，尽可能减少共享数据；锁的模式尽可能弱，尽可能减少锁的互斥；互斥锁的持续时间尽可能短；</strong></li><li>尽可能减少共享数据，提高会话的并发性。锁的粒度尽可能小（行锁—&gt;表锁，加锁的范围逐渐大），封锁的粒度越大，并发性就越小，同时系统的开销也就越小；相反，封锁的粒度越小，并发就越高，系统开销也就越大。</li><li>尽可能减少锁的互斥，提高会话的并发性。锁的模式尽可能弱（不加锁—&gt;加S锁—&gt;加X锁，加锁的类逐渐加强）</li><li>在并发比较高的系统中，不要加显式锁，特别是在事务里加显式锁。例如，select…for update句。</li><li>尽可能减少阻塞。这里有两种方案：1.减少锁的持续时间，事务内部访问某对象的时机。一般多事要经常访问的表的引用放在事务的末尾，以便将控制锁的持续时间减至最短。2. 尽可能缩短事（事务本身要短），以便将长期锁减至最少，改善并发性。</li><li>进行事务的分解，分解的原则是事务业务是最小原子操作。对于数据量很大的操作，在保证数据一性/原子性的条件下，可以将其分成几组提交事务，这样可以避免长时间地占用资源。<br>7.在表中添加索引。查询会扫描更少的索引记录，并且因此也可以设置更少的锁定。</li><li>尽量按照主键/索引去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外计算工作。比如，用select…where…order by rand();这样的语句，由于类似这样的语句用不到引，因此将导致整个表的数据都被锁住。</li><li>优化SQL和表设计，减少同时占用太多资源的情况。比如，减少连接的表，将复杂SQL分解为多个简的SQL。</li></ol><p><strong>避免死锁</strong>：调整访问共享资源的SQL顺序，对于多个会话的事务内部要按相同的固定顺序访问共享资源（多个表对象，多条记录），避免出现死锁</p><h5 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h5><p>在商业数据库中，通过多版本，select不需要加锁，也不会读到脏数据，不存在读写依赖，写的排它锁不会阻塞读，加大了并发性。这属于<strong>乐观控制模型</strong></p><h3 id="MySQL锁的种类"><a href="#MySQL锁的种类" class="headerlink" title="MySQL锁的种类"></a>MySQL锁的种类</h3><p><img src="/img/posts/MySQL/mysql_lock.jpg" alt="OSI"></p><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>就是一次性会锁住多少<br>表锁会锁住一整个表<br>行锁是锁定行（容易发生死锁）<br>页锁–MySQL特有，介于表锁和行锁之间</p><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="共享锁（读锁）"><a href="#共享锁（读锁）" class="headerlink" title="共享锁（读锁）"></a>共享锁（读锁）</h5><p>是读取操作（SELECT）时创建的锁。其他用户可以并发读取数据，但在读锁未释放前，也就是查询事务结束前，任何事务都不能对数据进行修改（获取数据上的写锁），直到已释放所有读锁。</p><p>  如果事务A对数据B加上读锁后，则其他事务只能对数据B上加读锁，不能加写锁。获得读锁的事务只能读数据，不能修改数据。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> … <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE MODE</span><span class="token punctuation">;</span></code></pre><h5 id="排他锁（写锁）"><a href="#排他锁（写锁）" class="headerlink" title="排他锁（写锁）"></a>排他锁（写锁）</h5><p>如果事务A对数据B加上写锁后，则其他事务不能再对数据B加任何类型的锁。获得写锁的事务既能读数据，又能修改数据。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> … <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向锁属于表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。InnoDB 中的两个表锁：</p><blockquote><p>意向共享锁（IS）：表示事务<strong>准备</strong>给数据行加入共享锁，就是说一个数据行加共享锁前必须先取得该表的IS锁；<br>意向排他锁（IX）：类似上面，表示事务<strong>准备</strong>给数据行加排他锁，说明事务在一个数据行加排他锁前必须先取得该的IX锁。</p></blockquote><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p><strong>悲观锁</strong>：认为数据出现冲突的可能性更大，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。共享锁和排他锁都是悲观锁的实现</p><p><strong>乐观锁</strong>：更新数据库时认为操作不会导致冲突，在操作数据时不加锁，而在进行更新后再去判断是否有冲突了。</p><ul><li>通过添加版本号进行实现：<br>  先查询出那条记录，获取出version字段。<br>  如果要对那条记录进行更新操作，则先判断version的值是否与刚刚查询出来时的version的等。<br>  如果相等，则说明这段期间没有其他程序对其进作，则可以执行更新，将version字段的值加1。<br>  如果version值与刚刚获取出来的version的值不相则说明这段期 间已经有其他程序对其进行操作了，进行更新操作</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="使用锁机制来实现对账户余额的更新操作"><a href="#使用锁机制来实现对账户余额的更新操作" class="headerlink" title="使用锁机制来实现对账户余额的更新操作"></a>使用锁机制来实现对账户余额的更新操作</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 连接数据库</span>Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 关闭自动提交</span>conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置事务隔离级别</span>conn<span class="token punctuation">.</span><span class="token function">setTransactionIsolation</span><span class="token punctuation">(</span>Connection<span class="token punctuation">.</span>TRANSACTION_REPEATABLE_READ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查询账户余额</span>    PreparedStatement pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token string">"select balance from account where id = ? for update"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> accountId<span class="token punctuation">)</span><span class="token punctuation">;</span>    ResultSet rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> balance <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新账户余额</span>    PreparedStatement pstmt2 <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token string">"update account set balance = ? where id = ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt2<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> balance <span class="token operator">-</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt2<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> accountId<span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt2<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提交事务</span>    conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 回滚事务</span>    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关闭数据库连接</span>    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a>获取共享锁</h4><p>使用了FOR SHARE语句来获取共享锁。在多个事务同时访问该表时，只有其中一个事务可以获取共享锁，并且其他事务只能读取该行数据，不能修改该行数据。需要注意的是，获取共享锁的事务需要先获取到行级锁，否则会出现死锁等问题。</p><pre class=" language-java"><code class="language-java">Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM my_table WHERE id = ? FOR SHARE"</span><span class="token punctuation">;</span>PreparedStatement pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>ResultSet rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 处理查询结果</span>conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="获取排他锁"><a href="#获取排他锁" class="headerlink" title="获取排他锁"></a>获取排他锁</h4><p>使用了FOR UPDATE语句来获取排他锁。在多个事务同时访问该表时，只有其中一个事务可以获取排他锁，并且其他事务不能读取或修改该行数据。需要注意的是，获取排他锁的事务需要先获取到行级锁，并且需要在事务结束前释放锁，否则会出现死锁等问题。</p><pre class=" language-java"><code class="language-java">Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM my_table WHERE id = ? FOR UPDATE"</span><span class="token punctuation">;</span>PreparedStatement pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>ResultSet rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 处理查询结果</span>conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-搜索算法</title>
      <link href="/2023/03/26/leetcode101-sou-suo-suan-fa/"/>
      <url>/2023/03/26/leetcode101-sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>DFS:深度优先搜索 (DFS)：DFS是通过<strong>递归</strong>搜索来实现的，它沿着树的深度搜索，直到找到目标节点或到达末端。<br>步骤，从初始节点-&gt;判断是否满足进入下一个节点的条件-&gt;进入下一个节点-&gt;进行遍历操作-&gt;在该节点继续dfs</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node n <span class="token operator">:</span> node<span class="token punctuation">.</span>adjacent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>visited <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>而广度有限BFS:是一种图形搜索算法，它在图中沿着宽度遍历，先找到所有与起点节点相邻的节点，然后再找到与它们相邻的节点，以此类推。广度优先中常使用<strong>队列</strong>存储</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node element <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">visit</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node n <span class="token operator">:</span> element<span class="token punctuation">.</span>adjacent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>visited <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                n<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="695-岛屿问题"><a href="#695-岛屿问题" class="headerlink" title="695.岛屿问题"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695.岛屿问题</a></h2><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿&nbsp;是由一些相邻的&nbsp;1&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设&nbsp;grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0</p><p><img src="/img/posts/Leetcode/leetcode695.jpg" alt="示例"></p><p>用dfs</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//可以看图理解，在加上记住这个模板。</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义一个表示岛屿的面积</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这两个for循环是来遍历整张二维格上的所有陆地的。</span>        <span class="token comment" spellcheck="true">//i 表示行，j表示列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//陆地的格</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//取出最大的面积</span>                    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>              <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回最大的陆地面积</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当超出岛屿边界（上下左右）的时候，就直接退出，特别要加上当遍历到海洋的时候也要退出，</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> i<span class="token operator">>=</span>grid<span class="token punctuation">.</span>length <span class="token operator">||</span> j<span class="token operator">>=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//定义一个变量表示岛屿的面积，就是包含几个陆地</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将陆地改为海洋，防止重复陆地重复遍历。</span>        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历上方元素，每遍历一次陆地就加一</span>        sum <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历下方元素</span>        sum <span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历右边元素</span>        sum <span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历左边元素</span>        sum <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/">547.省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p><img src="/img/posts/Leetcode/leetcode547.jpg" alt="示例"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> isConnected<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> province<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>isConnected<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//利用province来记录</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// province[0] = 1;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>isConnected<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>province<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 只有当province为0的时候才会进入新的一个省份，需要重新进行dfs</span>                province<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>isConnected<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>isConnected<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> province<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        province<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> province<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token function">dfs</span><span class="token punctuation">(</span>isConnected<span class="token punctuation">,</span> j<span class="token punctuation">,</span> province<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> province<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> province<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    province<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> province<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每次dfs将province[k]设成现在省份的index</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k <span class="token punctuation">,</span>province<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习4-图神经网络</title>
      <link href="/2023/03/21/ji-qi-xue-xi-4-tu-shen-jing-wang-luo/"/>
      <url>/2023/03/21/ji-qi-xue-xi-4-tu-shen-jing-wang-luo/</url>
      
        <content type="html"><![CDATA[<p>图神经网络是一种深度学习方法，用于处理图形数据结构。图形数据结构中的节点表示实体，边表示实体之间的关系。GNNs可以学习这些实体及其关系的复杂模式，用于各种任务，如节点分类、链接预测和图分类。</p><h2 id="图神经网络的组合优化"><a href="#图神经网络的组合优化" class="headerlink" title="图神经网络的组合优化"></a><a href="https://github.com/amazon-science/co-with-gnns-example">图神经网络的组合优化</a></h2><h3 id="什么是组织优化问题？"><a href="#什么是组织优化问题？" class="headerlink" title="什么是组织优化问题？"></a>什么是组织优化问题？</h3><p>同时面对许多决策，每一个决策只有yes/no两种取值，视为一个0-1变量。那么解空间就是全部0-1变量的所有组合。<br>每种不同的决策组合都会得到一个<strong>目标函数值</strong>（例如成本或收益），这个目标函数就是优化的对象</p><p>组合优化问题的两个相关例子是最大切割（maximum cut）与最大独立集（maximum independent set）。给定一个图，这两个问题可以简单理解为对每个节点进行一次二分类：<br><strong>最大切割</strong>：把这个图的节点分为两堆，使得这两堆节点之间的边数最多。两堆节点的标签分别是0和1。<br><strong>最大独立集</strong>：在这个图中找出尽可能多的节点，使得这些节点之间互相没有边相连。找出的节点标签为1，其余为0。</p><h3 id="用QUBO求解最大切割和最大独立集问题"><a href="#用QUBO求解最大切割和最大独立集问题" class="headerlink" title="用QUBO求解最大切割和最大独立集问题"></a>用QUBO求解最大切割和最大独立集问题</h3><p><a href="https://blog.csdn.net/econe_wei/article/details/103555430">最大切割与最大独立集问题的目标函数可以在QUBO（二次无约束二进制优化）</a></p><p>在说明什么是QUBO之前，需要先说明量子退火。量子退火法是模拟退火算法的量子实现，量子退火法都必须把问题映射成一个叫【哈密顿算符(Hamiltonian) 】的能量表达式。一般用H表示，然后求出让H值最小的变量组合。这个表达式是个二次多项式，里面的变量只能取0或1如：</p><p>$$ H = x_1^2 - x_2^2 + 2 $$</p><p>也就是x1和x2都只能取值0或1，我们要算出来，让H最小的x1和x2的值。因为x1和x2的取值组合和对应的H值，如下表所示：</p><p><img src="/img/posts/MachineLearning/gnn_qubo_table.jpg"></p><p>从上面的表格可以看出，(x1, x2) = (0, 1)的时候，H=2，是最小值。使用量子退火解决法，可以解决所有可以转变成二次多项式的，变量取值只能是0或1的问题。</p><p>上面的例子只有两个变量，所以很容易算出(x1, x2)的最优解，但是当有成千上万个x变量时，普通计算机就要花很久来计算，而量子退火机可以在数分钟内得出结果（计算时间依赖问题规模而定）</p><p><strong>QUBO</strong>就是将这个哈密顿算符表达式通过矩阵形式表示的中间矩阵，如该哈密顿算符的表达就是：<br><img src="/img/posts/MachineLearning/gnn_qubo_matrix.jpg" alt="矩阵形式"><br>中间的矩阵就是QUBO</p><h3 id="GNN是什么"><a href="#GNN是什么" class="headerlink" title="GNN是什么"></a>GNN是什么</h3><p>图神经网络的一般输入是一个图，它由节点集、边集、邻接矩阵等基本特征组成。对于节点集中的每一个节点，都可以用一个固定形状的张量来表示其特征，用邻接矩阵表征节点之间的关系，最简单的图神经网络认为边只代表邻接关系而没有节点那样的高维特征。</p><blockquote><p>作用：利用图的信息，<strong>进行节点或边的分类、节点或边的特征预测</strong>等。训练与预测的基本框架等与其他神经网络没有区别，只是处理的数据结构不同。</p></blockquote><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>在本研究中，提出了一个高度可扩展的基于 GNN 的求解器，以（大约）解决具有数百万个变量的组合优化问题</p><p>方法： 把组合优化问题<strong>转化为图上的最大切割或者最大独立集</strong>等QUBO问题，进一步转化为一个<strong>图节点二分类</strong>问题。然后用<strong>图神经网络处理节点间的邻接信息</strong>，把QUBO的<strong>目标函数松弛</strong>，用<strong>连续的分类概率</strong>代替离散的0-1变量，作为神经网络的loss函数，训练这个图神经网络（输出节点类别概率）。最后用阈值分割得到每个节点/变量的0-1值。</p><p>demo用d-regular方法生成了一个随机图，<br><img src="/img/posts/MachineLearning/gnn_org.jpg" alt="随机种子生成的随机图"><br>参数是n=100, d=3, seed=1，代表100节点，平均度3。共训练了13092轮，patience=100意味着最后100轮loss没有提升，达到耐心上限早停（提前停止）了<br><img src="/img/posts/MachineLearning/gnn_train_result.jpg" alt="训练结果"><br>这一部分见./utils.py下的run_gnn_training()函数。最佳的loss值是-40.85710144042969，也就是MIS问题松弛的QUBO目标函数的最好解。GNN找到的独立集节点数是41个，违背最大独立集限制条件的节点数为0。花费131.4s,其中 model training took 131.357s。<br><img src="/img/posts/MachineLearning/gnn_vis_result.jpg" alt="最终结果"></p><p>使用networkx的MIS求解器求解得到的独立集节点数是39个，违背最大独立集限制条件的节点数为0。<br><img src="/img/posts/MachineLearning/gnn_classical_optim.jpg" alt="MIS求解结果"></p><blockquote><p>结果:GNN求解器求解得到的最大独立集结果，好于networkx的MIS求解器求解得到的最大独立集。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 图神经网络 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-动态规划</title>
      <link href="/2023/03/20/leetcode101-dong-tai-gui-hua/"/>
      <url>/2023/03/20/leetcode101-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<p>动态规划（Dynamic Programming，简称 DP）是一种优化技巧，用于解决具有重叠子问题和最优子结构的问题。<br>它<strong>将问题分解为更小的子问题</strong>，将子问题的解存储在表中，然后<strong>使用这些子问题的解</strong>来构建<strong>原问题的解</strong>。</p><p>在动态规划中，有两种常见的方法：<strong>自顶向下</strong>（Top-down，也称为记忆化搜索）和<strong>自底向上</strong>（Bottom-up，也称为递推式方法）。</p><p>在斐波那契数列中的动态规划如下：</p><p>F(0) = 0<br>F(1) = 1<br>F(n) = F(n-1) + F(n-2)，当 n &gt; 1 时</p><p>自顶而下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FibonacciTopDown</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">fibTopDown</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fibTopDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memo<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            memo<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token function">fibTopDown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibTopDown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> memo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自底而上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FibonacciBottomUp</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">fibBottomUp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fibBottomUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70.爬楼梯</a></h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢</p><blockquote><p>  输入：n = 2<br>    输出：2<br>    解释：有两种方法可以爬到楼顶。<br>    1. 1 阶 + 1 阶<br>    2. 2 阶</p></blockquote><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>dp最简单的方式，可以通过计算已知量，求解未知量</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="可以用递归，但会超时"><a href="#可以用递归，但会超时" class="headerlink" title="可以用递归，但会超时"></a>可以用递归，但会超时</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">climbStairsReverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">climbStairsReverse</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">climbStairsReverse</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><blockquote><p>示例 1：<br>    输入：[1,2,3,1]<br>    输出：4<br>    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p>该题的dp函数是 <strong>dp[n] = max(dp[n-1], dp[n-2]+num[n])</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对dp的初始化要注意上下界</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>max_index<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> max_index <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> max_index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// if (dp[len-1]==0) dp[len-1] = Math.max(dp[max_index-2] + nums[len-1], dp[max_index-1]);</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然这样解答成功，但代码略有冗余，可以进行优化如下（直接遍历，而不需要使用下标）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> curr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次循环，计算“偷到当前房子为止的最大金额”</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> prev <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> curr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a><a href="https://leetcode.cn/problems/arithmetic-slices/">413.等差数列划分</a></h3><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的子数组个数。</p><p>子数组是数组中的一个连续序列。</p><blockquote><p>  示例：<br>    输入：nums = [1,2,3,4]<br>    输出：3<br>    解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum_combin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_diff <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pre_diff <span class="token operator">=</span> cur_diff<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur_diff <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_diff <span class="token operator">==</span> pre_diff<span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                sum_combin <span class="token operator">+=</span> <span class="token function">getSum</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                pre_diff <span class="token operator">=</span> cur_diff<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        sum_combin <span class="token operator">+=</span> <span class="token function">getSum</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum_combin<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token operator">*</span>count<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h2><h3 id="60-最短路径和"><a href="#60-最短路径和" class="headerlink" title="60.最短路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">60.最短路径和</a></h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><img src="/img/posts/Leetcode/leetcode64.jpg" alt="示例"></p><blockquote><p>示例<br>    输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>    输出：7<br>    解释：因为路径 1→3→1→1→1 的总和最小 </p></blockquote><p>类Dijkstra，由于要求最短路径，只能接受从上或从左路径输入</p><p><strong>dp[a][b] = min(dp[a-1][b], dp[a][b-1]) + num[a][b]</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a><a href="https://leetcode.cn/problems/01-matrix/">542.01矩阵</a></h3><p>给定一个由 0 和 1 组成的矩阵 mat&nbsp;，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 </p><p><img src="/img/posts/Leetcode/leetcode542.jpg" alt="示例"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="/img/posts/Leetcode/leetcode542_formula.jpg" alt="dp公式"></p><p>第一步，先把dp[][]数组填满，原矩阵为0的地方，dp矩阵也为0，其余的为10001<br>第二步，从左上角开始迭代，对比</p><ol><li>自身和<strong>右侧元素+1</strong></li><li>自身和<strong>下方元素+1</strong></li></ol><p><img src="/img/posts/Leetcode/leetcode542_step1.jpg" alt="左上角开始迭代"></p><p>第三步，从右下角开始迭代，对比</p><ol><li>自身和<strong>左侧元素+1</strong></li><li>自身和<strong>上方元素+1</strong></li></ol><p><img src="/img/posts/Leetcode/leetcode542_step2.jpg" alt="右下角开始迭代"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution542</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mat<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> mat<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// initiate</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">?</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token number">10001</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// From left-top, compare left and top with self</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                   <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token punctuation">}</span>                               <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//From right-bottom, compare right and bottom with self</span>        <span class="token comment" spellcheck="true">// be careful about index, it is m-1 and n-1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221.最大正方形</a></h3><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p><img src="/img/posts/Leetcode/leetcode221.jpg" alt="示例"></p><p>可以观察到，当一个元素是1时，他的dp数组的值取决于<strong>左侧，左上，上方dp数组值的最小值</strong> </p><blockquote><p>当matrix[i][j] = 1时，dp[i][j] = 该元素min（左上，左侧，上方）+ 1</p></blockquote><p>我们可以先初始化dp数组的第一行与第一列，然后按照dp函数迭代<br><img src="/img/posts/Leetcode/leetcode221_step1.jpg"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第一列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">returnNum</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化第一行</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">returnNum</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当matrix[i][j] = 1时，dp[i][j] = 该元素min（左上，左侧，上方）+ 1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">returnNum</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getMin</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dp表达式</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token operator">*</span>max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> min_ab <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> min_ac <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min_ac<span class="token punctuation">,</span> min_ab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">returnNum</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">==</span><span class="token string">'0'</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h2><h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><blockquote><p>示例<br>    输入：n = 12<br>    输出：3<br>    解释：12 = 4 + 4 + 4</p></blockquote><blockquote><p>示例<br>    输入：n = 13<br>    输出：2<br>    解释：13 = 4 + 9</p></blockquote><p>转移方程: <strong>f(n) = 1 + min(f(n - j*j))</strong> (j小于n开方)</p><p>仍然是用<strong>数组来存每个状态</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 状态初态</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token operator">?</span><span class="token number">1</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token operator">:</span>min<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转移方程</span>            <span class="token punctuation">}</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">91.解码方法</a></h3><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为&nbsp; (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><blockquote><p>示例<br>    输入：s = “12”<br>    输出：2<br>    解释：它可以解码为 “AB”（1 2）或者 “L”（12）。</p></blockquote><p>分两种情况</p><blockquote><p>第一种情况是我们使用了一个字符，<strong>f[n] += f[n-1]</strong></p></blockquote><blockquote><p>第二种情况使用两个字符, <strong>f[n] += f[n-2]</strong></p></blockquote><p><img src="/img/posts/Leetcode/leetcode91_step1.jpg" alt="以三个字符为例"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isVaild</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">isVaild</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> num <span class="token operator">&lt;</span> <span class="token number">27</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">></span> <span class="token number">9</span><span class="token operator">?</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><blockquote><p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>    输出: true<br>    解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。注意，你可以重复使用字典中的单词。</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>此时用到异或之前的状态<br><strong>dp[i]=dp[i] ∣∣ dp[i−word.length()]</strong><br>比如 s = applepenapple, 当识别到 str[i-word.length, i]可以构成一个wordDict中的单词时，如果dp[i] = true，需要满足：<br>dp[i-word.length] = true</p><p>但不能粗暴的写成dp[i] = dp[i-strLen]==true?true:false;<br>因为如果wordDict时[apple,pen,le]，当识别到apple中的le时，会进行dp[i-word.length]的判断，但此时l并不满足条件，所以dp[i]会变成false，显然不对</p><p>我们需要找到一个只要dp[i]=true了，就不会再改变的方式<br>所以采用<strong>异或</strong>，<strong>dp[i] |= dp[i-strLen]</strong></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>String str<span class="token operator">:</span> wordDict<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> strLen <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>strLen<span class="token punctuation">)</span><span class="token punctuation">{</span>                    String substr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">-</span>strLen<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>substr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">// dp[i] = dp[i-strLen]==true?true:false;</span>                          dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>strLen<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// dp[i] = false;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>回文问题可以用dp来判定，假设boolean dp[1][3]记录了从1-&gt;3的子字符串是否为回文串，那么判断dp[0][4]是否为回文串可以根据</p><blockquote><p>dp[0][4] = (s.charAt(0)==s.charAt(4) &amp;&amp; dp[1][3])?true:false;</p></blockquote><p>整理为通用公式<strong>dp[start][end] = (s[start]==s[end] &amp;&amp; dp[start+1][end-1])</strong></p><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>right<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>left<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span><span class="token number">2</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>                        max <span class="token operator">=</span> right<span class="token operator">-</span>left<span class="token punctuation">;</span>                        start <span class="token operator">=</span> left<span class="token punctuation">;</span>                        end <span class="token operator">=</span> right<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>该题中判断回文的起始状态要分三种情况 <strong>dabac</strong>, <strong>dabbc</strong>, <strong>dbbac</strong>,也就是中心扩散，中心右扩散和中心左扩散<br>所以在判断条件处需要或一个(right-left&lt;=2),也就是任意满足一种扩散条件都可以</p><p>java类中substring的用法：s.substring(0,2)只包含s[0]和s[1]，所以如果要返回s[0-2],需要写作s.substring(0,3)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-贪心算法</title>
      <link href="/2023/03/09/leetcode101-tan-xin-suan-fa/"/>
      <url>/2023/03/09/leetcode101-tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h2><p>贪心算法是一种求解最优化问题的算法，它的核心思想是通过每一步选择局部最优解来达到全局最优解。</p><p>举一个简单的例子：假设你有一个背包，可以容纳重量为W的物品，现在有n个物品，每个物品的重量为wi，价值为vi。你想要在背包中装入尽可能多的价值，但是不能超过背包的容量。这个问题可以使用贪心算法来解决。</p><p>情景解释：<br>对于每个物品，我们可以计算其单位重量的价值，也就是vi/wi，然后按照这个值从大到小排序。然后我们依次将物品放入背包中，直到背包装满或者所有物品都放入为止。每次选择的物品都是当前剩余物品中单位重量价值最大的物品，这样可以保证我们在背包容量固定的情况下，放入的物品总价值最大。</p><p>具体实如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">knapsack</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> wt<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>val<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算每个物品的单位重量价值</span>    unit_val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>wt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> wt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 按照单位重量价值从大到小排序</span>    unit_val<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 初始化当前背包重量和价值</span>    curr_wt<span class="token punctuation">,</span> curr_val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 依次将物品放入背包中</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> curr_wt <span class="token operator">+</span> unit_val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> W<span class="token punctuation">:</span>            curr_wt <span class="token operator">+=</span> unit_val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            curr_val <span class="token operator">+=</span> unit_val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 如果背包已经装满了，则跳出循环</span>            <span class="token keyword">break</span>    <span class="token keyword">return</span> curr_val</code></pre><p>在这个代码中，我们首先计算每个物品的<strong>单位重量价值</strong>，并按照这个值从大到小<strong>排序</strong>。然后我们依次将物品放入背包中，直到背包装满或者所有物品都放入为止。<strong>每次选择的物品都是当前剩余物品中单位重量价值最大的物品</strong>。最后返回背包中物品的总价值。</p><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值&nbsp;g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>&nbsp;</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span></code></pre><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy">135. 分发糖果</a></h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>思路：因为若是ratings= [1,3,5,2,1], candy = [1,2,3,2,1], 因为rating[2] = 5&gt;rating[1]=3，所以ratings[2]=3</strong><br><strong>注意，该题需要左遍历一遍，再右遍历一遍</strong></p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scoreArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        scoreArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> child <span class="token operator">&lt;</span> ratings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> child<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> ratings<span class="token punctuation">[</span>child<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> scoreArr<span class="token punctuation">[</span>child <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        score <span class="token operator">=</span> scoreArr<span class="token punctuation">[</span>child <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        child <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>child <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> child<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> ratings<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">></span>scoreArr<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">?</span> scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">:</span><span class="token punctuation">(</span>scoreArr<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                score <span class="token operator">+=</span> scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> score<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals">435.无重叠区间</a></h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p>示例 1:</p><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p><p>输入: intervals = [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p><p>输入: intervals = [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><h3 id="解法一：按end快排"><a href="#解法一：按end快排" class="headerlink" title="解法一：按end快排"></a>解法一：按end快排</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">:</span> intervals<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>                end <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// System.out.println("i:"+i+" "+j);</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> pivot <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> i<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// System.out.println("j:"+i+" "+j);</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp_a <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp_b <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp_a<span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp_b<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解法二：直接调用Arrays-sort-不自己写快排"><a href="#解法二：直接调用Arrays-sort-不自己写快排" class="headerlink" title="解法二：直接调用Arrays.sort,不自己写快排"></a>解法二：直接调用Arrays.sort,不自己写快排</h3><p>由于此时是比较每个数组的第1位元素，也就是a[1]和b[1]</p><p>因此直接将解法一中的</p><pre class=" language-java"><code class="language-java"><span class="token function">QuickSort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>换为</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// QuickSort(intervals, 0, intervals.length-1);</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">:</span> intervals<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>                end <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode--双指针</title>
      <link href="/2023/02/11/leetcode-shuang-zhi-zhen/"/>
      <url>/2023/02/11/leetcode-shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="一些Java中指针的基本概念"><a href="#一些Java中指针的基本概念" class="headerlink" title="一些Java中指针的基本概念"></a>一些Java中指针的基本概念</h2><p>java“指针”就是对象的引用，是存放在堆中的，因为Java中对象是存放在堆中。我们知道java中的内存分为堆内存（heap）和栈内存（stack）。堆就是用来存放对象的，而栈则是存放一些数据基本类型的值，如int,float,double,char…….</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>JVM只有一个堆区，在虚拟机启动时创建，被所有线程共享，堆区不放基本类型（成员变量除外）和对象的引用，只存储对象本身（包括class对象和异常对象）和数组，堆是GC所管理的主要区域（对不需要的对象进行标记，而后进行清除）<br>堆是用来存放程序动态生成的数据。（<strong>new 出来的对象的实例存储在堆中</strong>，但是<strong>仅仅</strong>存储的是成员<strong>变量</strong>，也就是平时所说的实例变量，<strong>成员变量的值</strong>则存储在常量池中。成员方法是此类所实现实例共享的，并不是每一次new 都会创建成员方法。成员方法被存储在方法区，并不是存储在第一个创建的对象中，因为那样的话，第一个对象被回收，后面创建的对象也就没有方法引用了。静态变量也存储在方法区中。局部变量在栈内存中，JVM为每一个类分配一个栈帧，然后引用类型的局部变量指向堆内存中的地址），堆是内存中共享的区域，要考虑线程安全的问题。</p><h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>用来存放基本数据类型和引用数据类型的实例的（也就是实例对象的在堆中的首地址，Person p = new Person; p存贮在堆栈中,值为@23651dff。还有就是堆栈是线程独享的。每一个线程都有自己的线程栈。</p><h3 id="x3D-x3D-与equal"><a href="#x3D-x3D-与equal" class="headerlink" title="==与equal"></a>==与equal</h3><ul><li><p>‘==’比较的是地址</p></li><li><p>equals比较的是内容</p></li></ul><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h2><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">题目</a>:给你一个下标从 1 开始的整数数组&nbsp;numbers ，该数组已按 非递减顺序排列&nbsp; ，请你从数组中找出满足相加之和等于目标数&nbsp;target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。<br>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。<br>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。</p><p><img src="/img/posts/Leetcode/leetcode167.jpg" alt="Leetcode167图示"></p><h3 id="暴力解决法"><a href="#暴力解决法" class="headerlink" title="暴力解决法"></a>暴力解决法</h3><p>虽然不太聪明，但很暴力</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>直接用index1和index2， 如果</p><ol><li>number[index1]+number[index2]&lt;target，index2右移</li><li>number[index1]+number[index2]&gt;target, index1右移， 且index2归位，index2=index1+1</li><li>number[index1]+number[index2]=target, 返回该值</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> index_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>index_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> index_1 <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token operator">+</span>numbers<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token operator">&amp;&amp;</span>index_2 <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>                index_2<span class="token operator">++</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index_1<span class="token operator">++</span><span class="token punctuation">;</span>                index_2<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                index_1<span class="token operator">++</span><span class="token punctuation">;</span>                index_2 <span class="token operator">=</span> index_1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> results <span class="token operator">=</span> <span class="token punctuation">{</span>index_1<span class="token punctuation">,</span>index_2<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> results<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="双指针法（推荐）"><a href="#双指针法（推荐）" class="headerlink" title="双指针法（推荐）"></a>双指针法（推荐）</h3><p>注意该数组是一个有序的递增数组，所以可以用该方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="剑指offer18：-删除链表中的节点"><a href="#剑指offer18：-删除链表中的节点" class="headerlink" title="剑指offer18： 删除链表中的节点"></a>剑指offer18： 删除链表中的节点</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/509cy5/">题目</a><br>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><h3 id="单指针法"><a href="#单指针法" class="headerlink" title="单指针法"></a>单指针法</h3><p>构造一个虚拟链表 cur 以 0 开始，并让该链表指向头指针 cur.next = head; 假设 head 为 <strong>1-&gt;2-&gt;3-&gt;4</strong><br>此时 cur = 0-&gt;1-&gt;2-&gt;3-&gt;4</p><p>若要删除数字3，需要利用<strong>cur.next.val</strong>来判断是否与val相等, 当cur.next.val = 3时，此时cur = 2-&gt;3-&gt;4<br>删除3要求，cur-&gt;next = cur-&gt;next-&gt;next<br>cur = 2-&gt;4, 同时head中的3也被删去了</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> ListNode <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> ListNode <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>cur <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="88-合并两个数组"><a href="#88-合并两个数组" class="headerlink" title="88.合并两个数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88.合并两个数组</a></h2><p>给你两个按 非递减顺序 排列的整数数组&nbsp;nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n </p><blockquote><p>示例：<br> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br> 输出：[1,2,2,3,5,6]<br> 解释：需要合并 [1,2,3] 和 [2,5,6] 。<br> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p></blockquote><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>虽然有点笨，但有用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> index_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token punctuation">;</span>                index_1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>                index_2<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>index_1 <span class="token operator">>=</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_2<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>index_2 <span class="token operator">>=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_1<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_1<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_2<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// System.out.println(nums1[j]);</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="尾部遍历法"><a href="#尾部遍历法" class="headerlink" title="尾部遍历法"></a>尾部遍历法</h3><p>从数组后面往前填，直接将nums2填入nums1，然后对nums1进行排序<br>要记得活用**Arrays.sort()**方法哇</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums1<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="142-环形链表-https-leetcode-cn-problems-linked-list-cycle-ii-submissions"><a href="#142-环形链表-https-leetcode-cn-problems-linked-list-cycle-ii-submissions" class="headerlink" title="(142.环形链表)[https://leetcode.cn/problems/linked-list-cycle-ii/submissions/]"></a>(142.环形链表)[<a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/]">https://leetcode.cn/problems/linked-list-cycle-ii/submissions/]</a></h2><p><img src="/img/posts/Leetcode/leetcode547.jpg"></p><p>假设从头节点走到入环节点需要a步， 每个环中有b个元素（也就是b步走完一个环）<br>核心在于确定当快慢指针相遇时的条件：</p><ol><li>当第一次slow和fast相遇：此时 <strong>fast=2 slow</strong><br> 但由于fast比slow多走了nb<br> 可以得出 **fast = 2 nb ** <strong>slow = nb</strong><br>但关键在于确定从从头节点走到入环点，由于从头节点走到入环点 = a， 走完这个环 = b，所以从此时slow再走a步就可以到达入环的节点，因为此时slow已经走了nb步了</li><li>所以此时将fast放到head，从head走到入环点需要a步，而在环中的slow要再度走到入环点也需要a步，当fast和slow相遇的时候就是入环点了</li></ol><p><img src="/img/posts/Leetcode/leetcode547_explanation.jpg" alt="图解"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>                        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>        fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">{</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> fast<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习笔记1--概述</title>
      <link href="/2022/10/05/ji-suan-ji-wang-luo-fu-xi-bi-ji-1/"/>
      <url>/2022/10/05/ji-suan-ji-wang-luo-fu-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p>复习计算机网络相关知识</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol><li>速率<br>网络技术中的速率指的是<strong>数据的传送速率</strong>，也称为<strong>数据率</strong>或<strong>比特率</strong>。单位是bit/s。<br>一般提到网络的速率指的是额定速率（标定速率），而非实际运行的速率。</li><li>带宽<br>贷款用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示再单位时间内网络中<strong>某信道</strong>所能通过的<strong>最高数据率</strong>。单位是bit/s</li><li>吞吐量<br>在单位时间内通过某个网络（或信道、接口）的<strong>实际数据量</strong>。吞吐量收网络带宽与网络额定速率的限制。接入网络主机的实际吞吐量取决于<strong>互联网的具体情况</strong>。</li><li>时延<br>数据（一个报文、分组甚至比特）从网络的一端到另一端所需的时间。<br>总时延 = 发送时延+传播时延+处理时延+排队时延<br>主要影响是<strong>发送时延</strong>和<strong>传播时延</strong><br>传播时延是比特在链路上传播的时延。</li><li>时延带宽积<br>时延带宽积 = 传播时延 x 带宽<br>等同在任何特定时间该网络线路上的<strong>最大数据量</strong>——已发送但尚未确认的数据。<br>链路像一个空心管道，时延是管道长，带宽是管道切面面积</li><li>往返时间RTT<br>大部分情况下，互联网上的信息不是单方传输而是双向交互的。</li></ol><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>协议</strong>: 网络协议是为进行网络中的数据交换而建立的规则。这些规则明确规定了数据的格式以及预期有关的同步问题。<br>协议主要由一下三个要素组成：语法（数据和控制信息的结构或者格式）、语义（需要发出何种控制信息）、同步（时间实现顺序的详细说明）。</p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="/img/posts/ComputerNetwork/OSI.jpg" alt="OSI"><br><img src="/img/posts/ComputerNetwork/TCP_IP.jpg" alt="TCP/IP"><br><img src="/img/posts/ComputerNetwork/OSI_TCPIP.jpg" alt="OSI与TCP/IP的对比"><br>OSI有七层<strong>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</strong><br>TCP/IP：<strong>网络接口层，网络层，传输层，应用层</strong>，TCP/IP的网络接口处覆盖率 OSI中的物理层和数据链路层</p><p><strong>网络层</strong></p><p>提供<strong>主机和主机</strong>之间的逻辑通信</p><p>协议有ARP协议、OSPF/RIP路由寻址协议、DHCP协议、ICMP协议、IGMP组播协议、IP协议、CIDR协议</p><p>设备有路由器（作用：转发分组）</p><p><strong>传输层</strong></p><p>提供端到端的可靠报文传递，负责将数据传送至对应端口，提供<strong>进程和进程</strong>之间的逻辑通信</p><p>协议有TCP UDP协议</p><p><strong>会话层</strong></p><p>负责建立、管理、终止进程之间的会话</p><p><strong>表示层</strong></p><p>对上层数据或者信息进行变换，以保证一个主机应用层信息可以被另一个主机应用层所理解，包括数据加密、格式转换、压缩等</p><p><strong>应用层</strong></p><p>为操作系统或者网络应用程序提供访问网络的接口 协议有HTTP FTP SMTP DNS协议</p><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>实现数据包的路由和转发，IP协议为每个数据包分配一个唯一的IP地址，以便数据包在网络中进行传输</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>用于网络设备之间传递错误信息和控制信息，例如ping命令就是通过ICMP协议实现的。</p><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>地址解析协议，将IP地址转为MAC地址</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>是开放式最短路径优先协议，用于实现路由协议，控制数据包在网络中的传输路径，以提高网络的可靠性和稳定性。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>用于实现可靠的数据传输和流量控制，确保数据包能够按照正确的顺序到达目的地。</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>用于实现不可靠的数据传输，适合实时数据传输，如视频和语音等。</p><h3 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h3><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>边界网关协议，用于控制Internet中的路由信息，管理自治系统之间的连接和数据流向</p><h4 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h4><p>多标签交换，用于在数据包传输过程中标记和识别数据包，提高网络的传输效率和可靠性。</p><h4 id="ISIS"><a href="#ISIS" class="headerlink" title="ISIS"></a>ISIS</h4><p>中间系统到中间系统，用于实现网络中的路由协议，控制数据包在网络中的传输路径，以提高网络的可靠性和稳定性。</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>路由信息协议，用于实现路由协议，控制数据包在网络中的传输路径，是一种基于距离向量算法的路由协议。</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP是面对<strong>连接的</strong>传输层协议，提供可靠的数据传世。TCP用<strong>检验和、标号、流量控制、拥塞控制、超时重传</strong>等机制保证TCP连接是可靠的，UDP则不保证可靠交付，只保证尽力交付。TCP的数据传输以<strong>字节流</strong>的形式，UDP的数据传输是以<strong>报文段</strong>的形式</p><p>UDP是<strong>无连接的</strong>的传输协议，提供不可靠的数据传输，通过UDP数据报进行数据传世不能保证数据可靠性。但UDP穿的较快，适用于对实时性要求较高的场景</p><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><p><strong>分段</strong> 将报文段分成适合转发的长度</p><p><strong>标号</strong> 按照序号判断中间的转发是否有缺失</p><p><strong>流量控制</strong> 根据双方的接收发送能力，动态地调整发送方发送窗口的大小，取发送窗口=min(拥塞窗口，接收窗口) （与数据链路层收不下的话返回一个信号告诉发送方自己收不下的流量控制机制不同）</p><p><strong>检验和</strong> TCP首部有检验和字段，目的是检验首部+数据部分的数据是否正确，是不是被人篡改或半路出现差错。</p><p><strong>超时重传</strong> 发出报文段之后启动定时器，如果重传时间RTT内没有收到确认的话，就重传该数据报，也可以采用冗余确认机制（三次接收到同一个ack=k的确认序号，就重传第k个报文段）（快重传中采用的也是冗余重传）</p><p>主要涉及的协议有两种（跟数据链路层的超时重传机制相同）：</p><p><strong>停止等待协议</strong> 每发送一个报文段就停止，直到收到确认才继续发送，否则超时重传<br><strong>滑动窗口协议</strong><br>后退N帧协议 GBN： 发送窗口&gt;1，接收窗口=1，即接收方必须按照顺序去接收数据，如果启用了超时重传机制的话，就会重传所有当前已经发送但是没有被确认的报文段<br>选择重传协议 SR： 发送窗口&gt;1，接收窗口&gt;1，即接收方无需按照顺序去接收数据，会按照任意顺序接收所有处于接收窗口内的数据。按照如果启用超时重传机制的话只需要重新发送没有收到确认的数据即可。<br><strong>拥塞避免 分为两种：①慢开始，拥塞避免 ②快重传、快恢复</strong></p><p><strong>检验和</strong>是TCP和UCP中都有的 要注意检验的是首部和数据字段的有效性</p><p>1.添上伪首部<br>2.首部检验和字段置为0<br>3.伪首部+首部+data部分用二进制反码求和，并将结果填入到检验和字段<br>4.去掉伪首部发送<br>5.发送方接受到该数据之后，首先添上伪首部<br>6.接着计算伪首部加首部加数据部分的二进制反码求和<br>7.如果全为1则无差错，去掉伪首部交给网络层，否则丢弃。</p><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><blockquote><p>三次握手（用于建立连接） 1. 客户端-&gt;服务器发送一个SYN，请求建立连接 2. 服务器接收到SYN后向客户端发送SYN+ACK，同意建立连接 3. 客户端接收到服务器的SYN+ACK后，向服务器发送一个ACK表示确认收到服务器的SYN+ACK。连接建立</p></blockquote><blockquote><p>四次挥手（用于断开连接） 1.客户端发送FIN报文给服务器端，并进入到FIN-WAIT1阶段，该FIN报文包括首部字段控制位FIN=1，序列号seq=u，告诉服务器我已完成我的数据传输工作，你这边如果还有数据可以继续传送(<strong>发送断开连接的请求</strong>) 2. 服务器收到该FIN报文之后进入close-wait阶段，并返回一个ACK给客户端，该确认报文包括首部控制位ACK=1，seq=v，ack=u+1。客户端收到该确认报文后进入fin-wait2状态，关闭从客户端到服务器端的数据传送。服务器端仍可向客户端传送数据。 3. 服务器接着发送一个FIN给客户端,该报文结构包括FIN=1,ACK=1,序列号为w，确认号为u+1，并进入Last-ACK状态 4. 客户端接收到后发送一个ACK,该确认报文包括首部控制位ACK=1，序列号为u+1，确认号为w+1，并进入time-wait阶段，等待2MSL后确认服务器端收到ACK报文正常断开连接后，客户端关闭。服务器端收到该确认报文，进入closed状态。 至此连接断开</p></blockquote><p><strong>等待2MSL的原因</strong> 确认服务器端是否正常收到了客户端最后发出的确认报文，如果服务器端没有收到的话，过1MSL（报文在网络中的最大存活时间）会重新再发送一次FIN报文给客户端，如果过了2MSL还没有收到新发的FIN报文的话，证明服务器端已经收到确认报文并正常关闭连接，客户端也可以关闭连接啦</p><h3 id="为什么三次握手？为什么四次挥手？"><a href="#为什么三次握手？为什么四次挥手？" class="headerlink" title="为什么三次握手？为什么四次挥手？"></a>为什么三次握手？为什么四次挥手？</h3><p><strong>三次握手的原因</strong></p><p><strong>确保双方间的连接正常建立</strong>，如果只有两次握手的话可能会出现一些异常情况，比如：①客户端的SYN连接请求失效(或者发去时间太久,导致了超时重传的发生)，但是服务器端接收到了该SYN报文，如果不经过第三次握手的话服务器端就会错误地开启一个连接；③如果只有两次握手地话，服务器端返回给客户端的确认报文丢失，会导致客户端因为没有收到确认所以关闭了该连接，但服务器端此时已做好了连接准备，造成资源的浪费</p><p><strong>四次挥手的原因</strong></p><p>因为建立连接时双方都处于closed状态，而释放连接时一方收到FIN报文但有<strong>可能还有数据要继续传输</strong>，不能马上释放连接，所以先返回一个确认报文，<strong>发送完数据后再断开连接</strong></p><h2 id="SYN洪泛攻击如何解决？"><a href="#SYN洪泛攻击如何解决？" class="headerlink" title="SYN洪泛攻击如何解决？"></a>SYN洪泛攻击如何解决？</h2><p><strong>SYN洪范攻击</strong>攻击者伪装成客户端发送TCP的SYN报文, 当服务器返回ACK确认报文之后, 攻击者不再进行确认, 即不回复确认的确认报文, 这个连接就处于一个挂起的状态, 服务器收不到确认报文的话, 会启用超时重传机制, 重复发送ACK给攻击者</p><p>这样的话,如果攻击者开启大量这种TCP连接, 导致服务器端有很多个挂起的连接, 并且需要重复发送很多ACK给攻击者, 这样就会消耗服务器的内存 可能导致最后服务器死机, 无法正常工作</p><p>解决方法</p><p><strong>降低SYN timeout时间</strong> 使得服务器在没收到确认报文后尽快释放半连接的占用<br><strong>采用SYN cookie设置</strong> 给每一个请求连接的ip地址分配一个cookie,短时间内如果连续收到某个IP的重复的SYN报文,就认定收到了攻击,以后会自动丢弃该ip地址传送过来的包</p><h2 id="TCP拥塞控制的原理"><a href="#TCP拥塞控制的原理" class="headerlink" title="TCP拥塞控制的原理"></a>TCP拥塞控制的原理</h2><ol><li>慢开始，在开始传播数据时，TCP会以指数级别增加传输速率，直到发现网络拥塞</li><li>拥塞避免：一旦发现网络拥塞，TCP会以线性级别的速度降低传输速率，以避免网络拥塞进一步加剧。</li><li>快重传和快恢复：当发现数据包丢失时，TCP会进行快速重传，避免等待超时后再进行重传。</li></ol><h2 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h2><p>在传输过程中，出现<strong>多个数据包合在一起</strong>（粘包），或<strong>一个数据包被拆分成多个数据包</strong>（拆包）传输</p><p>粘包/拆包都可能导致数据传输的混乱，解决方案：</p><ol><li>定长包处理：将<strong>数据按照固定长度</strong>进行分割，每个数据包长度相同，接收方按照固定长度介绍数据，避免了粘包和拆包问题<br>2.分隔符处理：将数据包<strong>按照特定的分隔符</strong>进行分割，每个数据包的长度不同，<strong>接收方</strong>根据<strong>分隔符来判断数据包的边界</strong>，避免了粘包和拆包问题。</li><li>增加<strong>消息头</strong>处理：在<strong>每个数据包的头部</strong>增加<strong>一个固定长度的消息头</strong>，用于描述<strong>数据包的长度、类型等信息</strong>，接收方根据消息头来接收数据，避免了粘包和拆包问题。</li></ol><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><p>HTTP：明文传输，不使用SSL/TLS协议加密。用于传输一些不敏感的信息</p><p>HTTPS：使用SSL/TLS加密传输，保证数据的安全性和可靠性</p><h3 id="HTTP中的长连接和短连接"><a href="#HTTP中的长连接和短连接" class="headerlink" title="HTTP中的长连接和短连接"></a>HTTP中的长连接和短连接</h3><p>长连接和短连接是指客户端和服务器之间TCP连接持续的师姐</p><ul><li><p>短连接：每次请求和响应都会建立一个新的TCP连接，完成后客户端立即关闭连接，同时服务器也<strong>立即</strong>释放连接。短连接节省资源，但建立连接的开销较大，对于频繁请求会有较大的延迟，不适合长时间通信。</p></li><li><p>长连接：客户端和服务器建立一个TCP连接后，可以重复使用该链接进行多次请求和响应，直到客户端/服务器发送终止连接的请求/响应。长连接可以减少建立连接的开销和延迟，适合长时间通信，但会占用一定的资源和带宽。</p></li></ul><p>在HTTP/1.1之前，HTTP协议默认使用短连接。在HTTP/1.1中，HTTP协议默认使用长连接，但客户端和服务器可以通过在请求头或响应头中添加”Connection: close”字段来关闭连接。</p><h2 id="http协议的发展历程（1-0-1-1-2-0-3-0）"><a href="#http协议的发展历程（1-0-1-1-2-0-3-0）" class="headerlink" title="http协议的发展历程（1.0 1.1 2.0 3.0）"></a>http协议的发展历程（1.0 1.1 2.0 3.0）</h2><p><strong>http1.0和http 1.1的主要区别是什么？</strong></p><p>1.<strong>连接</strong> HTTP1.0默认使用短连接，每次请求不同的资源都需要重新建立一次连接；HTTP1.1起默认使用长连接，默认开启keep-alive，即同一个TCP连接可以发送和接收多个http请求/响应，这种长连接由流水线方式和非流水线方式，流水线方式是指客户在收到http响应报文之前就能够接着发送新的请求报文，非流水线方式是指客户在收到http响应报文后才能接着发送下一个请求</p><p>2.<strong>状态码</strong> HTTP1.1新增24个状态码，409表示请求的资源与资源当前状态发生冲突，410Gone指的是服务器上某个资源被永久删除</p><p>3.<strong>带宽优化及网络连接使用</strong> ——http1.1支持断点续传，HTTP1.0中不支持只显示对象的一部分（只能显示全部）、且不支持断点续传功能，浪费带宽；HTTP1.1在请求头中引入了range头域，允许只请求资源的某个部分，返回码是206（partial content）</p><p><strong>http2.0的改进</strong></p><p>1.<strong>头部压缩</strong> 减少冗余头信息，用了首部表来跟踪、存储之前的键值对，相同的数据就无需再每次重复请求和响应了</p><p>2.<strong>多路复用</strong> 实现由一个tcp连接并发请求。http1.1多个请求的响应之间会被阻塞</p><p>3.<strong>服务器推送</strong>：可以主动将资源推送给客户端缓存中</p><p>4.<strong>二进制格式</strong>：采用二进制而非文本格式，将所有传输的信息分割为更小的消息和帧（二进制帧）</p><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>域名解析：浏览器根据URL中的域名，向本地DNS服务器发送域名解析的请求<br>本地DNs解析：本地DNS服务器收到请求后，1.在DNS缓存中查找是否有对应的IP，若有，直接返回。 2. 若没有本地DNs服务器向互联网上的root 服务器发送请求<br>根DNS解析：根服务器收到请求后，转发给顶级域名服务器<br>顶级域名服务器解析：转发给对应的刺激域名服务器<br>次级域名服务器：收到请求后，在自己的DNS缓存中查找对应的IP，若有，返回；否则向下一级域名发送请求直到找到。</p><h2 id="输入URL到显示网页发生了什么"><a href="#输入URL到显示网页发生了什么" class="headerlink" title="输入URL到显示网页发生了什么"></a>输入URL到显示网页发生了什么</h2><p><strong>浏览器解析URL对应的IP地址</strong><br>​ DNS解析过程，浏览器缓存—&gt;操作系统缓存—&gt;本地DNS—&gt;根据转发模式选择迭代还是递归查询</p><p><strong>浏览器向服务器发送一个HTTP请求报文</strong><br>​ 传输层上建立TCP连接，网络层用到了IP协议(负责在网络层传输数据），还会用到RIP或者OSPF进行路由选择，然后用ARP协议解析IP地址对应的MAC地址，使得数据能够在数据链路层上进行传输（不应该是最后到物理层传输吗）。</p><p>​ HTTP请求方法有哪些（post/get/head/put/delete）</p><p><strong>服务器请求处理并返回一个HTTP响应报文</strong><br>​ HTTP响应报文的结构，状态码</p><p><strong>服务器返回一个HTML响应，浏览器收到HTML响应并渲染界面</strong></p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>注意存放在请求行和请求体的不是方法 而是请求/提交的数据啊喂 post和get方法都是在请求行中啦</p><p>1.get数据明文存放在http请求行的url之后，post则是将提交的数据放在http请求报文的请求体中</p><p>2.受浏览器对url长度的限制，get传送数据量应不超过2KB。post传送数据量则一般无此限制</p><p>3.get只接受acsii字符，post没有限制，get只支持url编码，post没有限制</p><p>4.get不能改变服务器的数据，一般用于从服务器获取数据，是幂等的；post可以改变服务器的数据，不是幂等的。</p><p>5.get请求可以被浏览器主动缓存，下一次若传输数据相同，则优先返回缓存中的内容，以加快显示速度。post请求不会，除非手动设置一下</p><p>6.get请求参数会被完整地保存在浏览器历史记录中，post请求参数则不会保留</p><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p><strong>1xx 表示正在处理</strong></p><p>100 continue 一切正常 可以继续发送（据说是http报文中如果有post方法的话 会先把请求行发送过去，然后返回100，然后再发送请求头部和请求体给服务器端）<br><strong>2xx 成功 表示请求已经正常处理</strong></p><p>200 OK 一切正常返回数据<br>204 No content 请求正常处理，但是没有数据返回<br>206 指定范围返回（http1.1以上支持的断点续传功能相关）<br><strong>3xx 重定向 浏览器需要一些额外的操作才能完成请求</strong></p><p>301 永久性重定向<br>302 暂时性重定向（跟http劫持有关，运营商可以通过DNS劫持和http劫持两种，返回一个302，然后让用户跳转到处理好的携带广告的页面）<br>303 暂时性重定向 但是服务器端明确说明希望浏览器用get方法来请求资源<br>304 浏览器附带了请求的条件，服务器端允许访问，但是不满足请求条件<br><strong>4xx 客户端错误</strong></p><p>400 客户端的请求有语法错误<br>403 forbidden 客户端申请访问的资源被禁止访问<br>404 Not found 客户端申请访问的资源不存在<br>405 Method not allowed 客户端请求方法被禁止<br><strong>5xx 服务器端错误</strong></p><p>500 服务器在请求处理时内部出错<br>501 服务器不具备完成请求的功能，如无法识别请求方法<br>502 服务器作为网关或代理，从上游服务器获得无效响应<br>503 Bad Gateway 服务器处于停机维护/超负荷状态<br>504 Gateway timeout服务器作为网关或代理，没有及时从上游服务器获得响应</p><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><p>首先它们都是用于给无连接的http提供身份认证的功能</p><p>cookie是服务器在<strong>本机</strong>存放的小段文本，并随每一个请求发送至同一服务器。cookie分为<strong>会话cookie</strong>（不设置过期时间，关闭浏览器窗口cookie即失效，保存在内存中）和<strong>持久cookie</strong>（设置过期时间，关闭再打开浏览器cookie仍存在，直至达到过期时间）。类似于检查通行证（即请求报文中附带的cookie）来确定用户身份</p><p>session则一般是利用session id实现的（session id是浏览器第一次发送请求时服务器自动生成的唯一标识，并返回给浏览器），cookie中携带该session id，客户端根据该session id将session检索出来。类似于在<strong>服务器</strong>上建立一个客户档案，客户来访时需要查询客户档案</p><p>1.cookie是存放在客户端，用于记录用户信息的，比如自动填充用户名和密码；session是存放在服务器端的，用于记录用户的状态，比如购物车的实现。</p><p>2.cookie不太安全，可以分析存放在本地的cookie进行cookie欺骗，（也可以用加密算法加密后进行存放），session存放于服务器的内存中，所以安全性高</p><p>3.单个cookie保存数据不能超过4k，session没有对存储数据量的限制</p><p>禁掉cookie的话session仍然可以使用，但是需要使用其他方法获取session id，比如在url后面或者以表单的形式提交给服务器端</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码适用于指定IP地址的网络部分和主机部分组成<br>子网掩码也由32位二进制数表示，它的作用是将IP地址分为网络部分和主机部分，<strong>用于确定网络中的设备是否属于同一子网</strong>。通常，子网掩码与IP地址一起使用，可以将一个大的IP地址空间划分为多个子网，从而更有效地管理网络中的设备。</p><p>例如，假设一个公司拥有一个IP地址段为192.168.1.0/24的网络。这个IP地址段中包含的IP地址范围为192.168.1.1~192.168.1.254，其中，/24表示子网掩码为255.255.255.0。这个IP地址段中的每个IP地址的前三个数（即192.168.1）都是网络部分，最后一个数则是主机部分。子网掩码中为1的位表示网络部分，为0的位表示主机部分。在这个例子中，子网掩码中前24位都是1，表示网络部分，后8位都是0，表示主机部分。这样，我们可以将这个IP地址段划分为256个子网，每个子网最多包含254个IP地址。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡是一种常用的网络技术，用于<strong>将网络流量分配到多个服务器</strong>上，以实现更高的性能。<br>负载均衡的实际应用非常广泛，包括以下几个方面：</p><p>网站和应用服务器的负载均衡：负载均衡可以将网络流量分配到多个Web服务器和应用服务器上，以提高网站和应用程序的性能、可靠性和可扩展性。<br>数据库服务器的负载均衡：负载均衡可以将数据库流量分配到多个数据库服务器上，以提高数据库的性能、可靠性和可扩展性。<br>文件服务器的负载均衡：负载均衡可以将文件流量分配到多个文件服务器上，以提高文件共享的性能和可靠性。<br>DNS服务器的负载均衡：负载均衡可以将DNS查询流量分配到多个DNS服务器上，以提高DNS服务的性能和可靠性。</p><h2 id="防火墙是什么"><a href="#防火墙是什么" class="headerlink" title="防火墙是什么"></a>防火墙是什么</h2><p>防火墙是指一种网络安全设备，用于对网络流量进行监控和过滤，保护网络免受恶意攻击和威胁。防火墙可以通过过滤规则来控制网络流量的进出，对恶意流量进行拦截和阻止，从而保护网络的安全性和稳定性。</p><h2 id="IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址"><a href="#IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址" class="headerlink" title="IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址"></a>IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址</h2><p>MAC地址是网络中<strong>每个设备都有的唯一网络标识</strong>，全世界唯一。</p><p>IP地址只是<strong>逻辑上</strong>的标识，任何人都能随意修改，因此不能具体标识一个用户，但MAC地址固化在网卡里，防止被盗用。</p><p>但是如果只用MAC地址的话，因为MAC地址无序杂乱，没有明显规则，难以查找。但是IP是分层的，类似通讯地址，可以根据其网络号找到子网再定义主机，逐级查找，每个设备需要存储的信息较少</p><p>MAC地址与IP地址的区别：</p><p>①<strong>长度不同</strong>，IP地址一般为32位（IPv6 128位），MAC地址则是48位</p><p>②<strong>分配依据不同</strong>，IP地址分配基于网络拓扑，能够根据需要改动设备的IP地址，但是MAC地址的分配是基于制造商，在网卡中烧录好，一般不轻易改变</p><p>③<strong>寻址协议层不同</strong>，IP地址应用于<strong>网络层</strong>，MAC地址应用于<strong>数据链路层</strong>（数据链路层基于MAC地址转发数据帧，数据链路层的交换机根据其MAC地址记录表中的MAC地址及其对应的端口，将其发送到MAC地址对应的端口，否则广播；网络层则根据IP地址转发报文，路由器根据路由表转发到对应端口，否则发送默认路由）</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>作用：<strong>实现IP地址到MAC地址的映射</strong>（由IP地址获得MAC地址）</p><p>流程：根据主机A路由表的内容查找B的IP地址，再从A的ARP高速缓存中寻找是否有B的MAC地址，如果没有则广播ARP请求帧（构成为Aip+Bip+A_MAC+全1）至该局域网内所有的主机。如果主机发现该请求帧中的IP地址与自己的相同则返回一个单播ARP帧（构成为Bip+B_MAC)返回给主机A，并且AB均更新自己的ARP高速缓存。</p><h2 id="客户端故障检测方法？"><a href="#客户端故障检测方法？" class="headerlink" title="客户端故障检测方法？"></a>客户端故障检测方法？</h2><p>客户端故障检测方法—-<strong>保活计时器</strong></p><p>目的:在长连接的情况下,检测没有响应的连接并且将其断开(即客户端出现了故障), 防止占用过多的连接资源</p><p>客户端打开服务器的连接传送数据后,就保持沉默了,此时有可能客户端出了故障.</p><p>解决方法就是使用保活计时器, 每当服务器收到客户端的信息的话,该计时器就复位, 如果两个小时之内还没有收到客户信息,就发送探测报文段,如果发送了10个探测报文段还没有响应的话, 就认为客户端出了故障,终止该连接</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习学习笔记1</title>
      <link href="/2022/08/31/qiang-hua-xue-xi-xue-xi-bi-ji-1/"/>
      <url>/2022/08/31/qiang-hua-xue-xi-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p><strong>强化学习（reinforcement learning)是在与环境的互动中为了达成一个目标而进行的学习</strong><br>强化学习基本元素 <strong>Agent</strong>，<strong>Environment</strong>,<strong>goal</strong><br>强化学习主要元素 <strong>state</strong>,<strong>action</strong>,<strong>reward</strong><br>强化学习核心元素 <strong>policy</strong>,<strong>value</strong><br>强化学习学习的是一个好的价值函数，而一个好的价值函数决定了一个好的策略 </p><p><strong>试错</strong>与<strong>延时奖励</strong>是强化学习中主要特点。</p><p>价值是将来能够获得的所有奖励之和的期望值。</p><p>由于随机性，不能一直做贪婪选择。可以再大多数情况下做出贪婪的选择，再一定几率下做出随机的选择。 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路4-HQL的应用1-建表与show语句</title>
      <link href="/2022/08/22/hive-xue-xi-zhi-lu-4-hql-de-ying-yong-1-jian-biao-yu-show-yu-ju/"/>
      <url>/2022/08/22/hive-xue-xi-zhi-lu-4-hql-de-ying-yong-1-jian-biao-yu-show-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>SQL中DDL(Data Defeinition Language)语言，主要是Create，ALter，DROP。DDL并不涉及表内部操作。</p><h2 id="Hive中的数据库"><a href="#Hive中的数据库" class="headerlink" title="Hive中的数据库"></a>Hive中的数据库</h2><p>在默认情况下，Hive的默认数据库default ,位于HDFS的/user/hive/warehouse目录下<br>用户自己创建的数据库位于/user/hive/warehouse/databse_name.db下</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>create databse用于创建新的数据库<br>COMMENT: 数据库的注释说明语句<br>LOCATION: 指定数据库再HDFS存储位置，默认为/user/hive/warehouse/dbname.db<br>With DBPROPERTIES: 用于指定一些数据库的属性配置</p><pre class=" language-SQL"><code class="language-SQL">CREATE (DATABASE|SCHEMA)[IF NOT EXISTS]database_name[COMMENT database_comment][LOCATION hdfs_path][WITH DBPROPERTIES(property_name=property_value,...)];</code></pre><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>use database 进行切换</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>要求数据库下没有标，为空时才可以删除</p><pre class=" language-SQL"><code class="language-SQL">DROP (DATABSE|SCHEMA)[IF EXSITS]database_name;</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>同理SQL</p><p>[可选内容]</p><pre class=" language-SQL"><code class="language-SQL">CREATE TABLE[IF NOT EXSITS][db_name.]table_name(col_name datatype [COMMENT col_comment],...)[COMMENT table_comment][ROW FORMAT DELIMITED...];</code></pre><p>最低限度</p><pre class=" language-SQL"><code class="language-SQL">CREATE TABLE table_name (col_name datatype,...);</code></pre><p>例</p><pre class=" language-SQL"><code class="language-SQL">create table test.t_archar(    id int comment "ID编号",    name string,    hp_max int,    mp_max int,    attack_max int,    defense_max int,    attack_range string,    role_main string,    role_assist string)row format delimitedfields terminated by "\t";</code></pre><h3 id="show语法"><a href="#show语法" class="headerlink" title="show语法"></a>show语法</h3><p>用于查看schemas，tables和databases</p><p>show tables;<br>show databases;<br>show schemas;<br>show tables in database1; // 此处表示展示database1中的表<br>show tables in schema1; // 此处表示展示schema1中的表</p><p>查看元数据类型<br>desc formatted table1;</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路3-Hive客户端的使用</title>
      <link href="/2022/08/21/hive-xue-xi-zhi-lu-3-hive-ke-hu-duan-de-shi-yong/"/>
      <url>/2022/08/21/hive-xue-xi-zhi-lu-3-hive-ke-hu-duan-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>推荐使用第二代客户端$HIVE_Home/bin/beeline，是一个JDBC客户端<br>官方强烈推荐的Hive命令行工具，和第一代客户端相比，性能安全性提高</p><p><img src="/img/posts/DataRepos/hive%E5%AE%A2%E6%88%B7%E7%AB%AF1&amp;2.jpg" alt="Hive客户端与服务的关系"><br>图源：<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=62&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">https://www.bilibili.com/video/BV1CU4y1N7Sh?p=62&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad</a></p><h2 id="HiveServer2服务"><a href="#HiveServer2服务" class="headerlink" title="HiveServer2服务"></a>HiveServer2服务</h2><p>在远程模式下，启动HiveServer2必须先启动mtastore服务<br>Beeline客户端只能通过HiveServer2服务访问Hive问bin/hive是通过一代服务(metastore)访问的</p><pre class=" language-shell"><code class="language-shell">nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service metastore &nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service hiveserver2 &</code></pre><h3 id="其他机器连接一代客户端-metastore"><a href="#其他机器连接一代客户端-metastore" class="headerlink" title="其他机器连接一代客户端(metastore)"></a>其他机器连接一代客户端(metastore)</h3><p>将客户端拷贝到其他机器上，此处以node3为例</p><pre class=" language-shell"><code class="language-shell">scp -r /export/server/apache-hive-3.1.2-bin root@node3:/export/server/</code></pre><p>再在node3的finalshell中输入</p><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive</code></pre><p>但此时连接的是metastore， 是第一代客户端<br>进入hive&gt;<br>可以用show dtabases; show tables;分别查看数据库和表</p><p>ctrl+c退出hive</p><h3 id="其他机器连接二代客户端-HiveServer2"><a href="#其他机器连接二代客户端-HiveServer2" class="headerlink" title="其他机器连接二代客户端(HiveServer2)"></a>其他机器连接二代客户端(HiveServer2)</h3><p>将beeline客户端连接到hive服务器</p><p>在node3的finalshell中输入</p><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/beeline</code></pre><ul><li><p>进入beeline</p></li><li><p>输入 beeline&gt; ! connect jdbc:hive2://node1:10000<br>  连接到hive服务<br>  输入用户名：root<br>  密码直接回车</p></li><li><p>连接成功<br>  可以直接输入 show databases;<br>          show tables;<br>  进行基本查询</p></li></ul><h2 id="Hive可视化客户端"><a href="#Hive可视化客户端" class="headerlink" title="Hive可视化客户端"></a>Hive可视化客户端</h2><p><strong>DataGrip</strong>,Dbeaver, Squirrel SQL client等</p><h3 id="DataGrip的使用"><a href="#DataGrip的使用" class="headerlink" title="DataGrip的使用"></a>DataGrip的使用</h3><ul><li><p>创建项目</p></li><li><p>attach directory to project<br>  这样之后写的sql文件都存在这个目录下</p></li><li><p>关联数据库<br>  选择右边栏database-&gt; 点击+号 -&gt; data source -&gt; Apache Hive</p><p>  点开后，左边选择栏再选择Hive，配置Hive启动jar，配置好后，点击上方localhost，更改host为node1，user名为root，之后测试connection，，显示ok后，点击apply</p></li></ul><h3 id="测试是否连接成功"><a href="#测试是否连接成功" class="headerlink" title="测试是否连接成功"></a>测试是否连接成功</h3><ul><li><p>在node1机器的finalshell中输入jps<br>runjar在运行</p></li><li><p>在datagrip中右侧的hive连接，此处是node1_hive，点击后按住（Fn+f4)或直接(f4)，进入命令行输入模式，输入show databases;选中后点击左上方绿色按钮进行运行。</p></li></ul><p>成功后和说明环境配置成功。</p><h3 id="正式写sql文件"><a href="#正式写sql文件" class="headerlink" title="正式写sql文件"></a>正式写sql文件</h3><p>将结构化语句映射到表中</p><ul><li><p>新建文件“1.create_table.sql”</p></li><li><p>写建表语句</p></li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> test<span class="token punctuation">.</span>t_archar<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name string<span class="token punctuation">,</span>    hp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    mp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_max <span class="token keyword">int</span><span class="token punctuation">,</span>    defense_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_range string<span class="token punctuation">,</span>    role_main string<span class="token punctuation">,</span>    role_assist string<span class="token punctuation">)</span></code></pre><ul><li>指定字段之间的分隔符</li></ul><p>若不用分隔符，只有create table，会采用默认分隔符’\001’<br>\001是打不出来的，在vim编辑器的输入模式下是^A<br>用空格(\t)表示分隔符</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">row</span> format delimited<span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">"\t"</span></code></pre><p>完整语句</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> test<span class="token punctuation">.</span>t_archar<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name string<span class="token punctuation">,</span>    hp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    mp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_max <span class="token keyword">int</span><span class="token punctuation">,</span>    defense_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_range string<span class="token punctuation">,</span>    role_main string<span class="token punctuation">,</span>    role_assist string<span class="token punctuation">)</span><span class="token keyword">row</span> format delimited<span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">"\t"</span><span class="token punctuation">;</span></code></pre><ul><li>切换到对应的schema</li></ul><p><img src="/img/posts/DataRepos/Datagrip_switchSchema.jpg" alt="切换"></p><h3 id="上传原数据"><a href="#上传原数据" class="headerlink" title="上传原数据"></a>上传原数据</h3><ol><li>暴力上传</li></ol><p>进入node1:9870， browse file-&gt; user-&gt;hive -&gt;warehouse -&gt;test.db -&gt;upload</p><p>之后进入datagrip用select 语句进行查看</p><ol start="2"><li>通过将本地文件再finalshell中</li></ol><pre class=" language-shell"><code class="language-shell">hadoop fs -put 1.txt /user/hive/warehouse/test.db/t_1/</code></pre><p>此处是将1.txt的淑君放到test数据库下的t_1表中</p><p>然后再beeline/datagrip中用select语句可以查看</p><ol start="3"><li>用load加载（推荐）<br>load命令是一个纯复制纯移动的树，hive不会对数据做任何形式的改变<br>语句格式如下</li></ol><pre class=" language-SQL"><code class="language-SQL">LOAD DATA[LOCAL] INOATH 'filepath' [OVERWRITE] INTO TABLE tablename;</code></pre><ul><li>Local的本地–如果是对Hiveserver2服务器所在的机器使用此命令，local本地文件系统指的是Hiveserver2服务所在机器的本地linux文件系统，而非Hive客户端所在的本地文件系统。<br>也就是node1上的本地文件系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路2--安装部署</title>
      <link href="/2022/08/19/hive-xue-xi-zhi-lu-2-an-zhuang-bu-shu/"/>
      <url>/2022/08/19/hive-xue-xi-zhi-lu-2-an-zhuang-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=60&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">https://www.bilibili.com/video/BV1CU4y1N7Sh?p=60&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad</a> </p><p>在Linux环境下，保证Hadoop集群健康可用<br>在启动Hive之前必须先启动Hadoop集群，<strong>需等待HDFS安全模式关闭之后再运行Hive</strong></p><pre class=" language-shell"><code class="language-shell">start-dfs.shstart-yarn.sh</code></pre><p>Hive不是分布式安装运行的软件，其分布式特效主要借助于Hadoop完成，包括分布式存储，分布式计算</p><h2 id="Hadoop与Hive"><a href="#Hadoop与Hive" class="headerlink" title="Hadoop与Hive"></a>Hadoop与Hive</h2><p>需要在Hadoop中添加相关配置属性，以满足Hive在Hadoop上运行<br>修改Hadoop中core-site.xml,并且Hadoop集群同步配置文件重启生效</p><!--整合Hive代理设置 --><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.proxyuser.root.hosts<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.proxyuser.root.groups<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><ol><li>卸载Centos7自带的mariadb</li></ol><pre class=" language-shell"><code class="language-shell">rpm -qa|grep mariadb# 结果mariadb-libs-5.5.64-1.el7.x86_64rpm -e mariadb-libs-5.5.64-1.el7.x86_64 --nodeps# 进行删除rpm -qa|grep mariadb                            # 再次查询，无结果</code></pre><ol start="2"><li>安装mysql</li></ol><pre class=" language-shell"><code class="language-shell"># 创建目录mkdir /export/software/mysql# 选择finalShell，找到/export。software/mysql 拖拽文件上传mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar#到上述文件夹下  解压tar xvf mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar#执行安装依赖yum -y install libaio# 进行mysql的安装rpm -ivh mysql-community-common-5.7.29-1.el7.x86_64.rpm    mysql-community-libs-5.7.29-1.el7.x86_64.rpm    mysql-community-client-5.7.29-1.el7.x86_64.rpm      mysql-community-server-5.7.29-1.el7.x86_64.rpm warning: mysql-community-common-5.7.29-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:mysql-community-common-5.7.29-1.e################################# [ 25%]   2:mysql-community-libs-5.7.29-1.el7################################# [ 50%]   3:mysql-community-client-5.7.29-1.e################################# [ 75%]   4:mysql-community-server-5.7.29-1.e################                  ( 49%)</code></pre><ol start="3"><li>mysql初始化设置</li></ol><pre class=" language-shell"><code class="language-shell">#初始化mysqld --initialize#更改所属组chown mysql:mysql /var/lib/mysql -R#启动mysqlsystemctl start mysqld.service#查看生成的临时root密码cat  /var/log/mysqld.log[Note] A temporary password is generated for root@localhost: o+TU+KDOm004</code></pre><ol start="4"><li>修改root密码 授权远程访问 设置开机自启动</li></ol><pre class=" language-shell"><code class="language-shell"># 登录mysqlmysql -u root -p# Enter password:     #这里输入在日志中生成的临时密码# Welcome to the MySQL monitor.  Commands end with ; or \g.# Your MySQL connection id is 3# Server version: 5.7.29Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql> #更新root密码  设置为hadoopmysql> alter user user() identified by "hadoop";Query OK, 0 rows affected (0.00 sec)#授权mysql> use mysql;mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'hadoop' WITH GRANT OPTION;mysql> FLUSH PRIVILEGES; # ctrl+D 结束 退出mysql#mysql的启动和关闭 状态查看 （这几个命令必须记住）systemctl stop mysqldsystemctl status mysqldsystemctl start mysqld#建议设置为开机自启动服务systemctl enable  mysqld    #Created symlink from /etc/systemd/system/multi-user.target.wants/mysqld.service to /usr/lib/systemd/system/mysqld.service.#查看是否已经设置自启动成功systemctl list-unit-files | grep mysqld# mysqld.service enabled </code></pre><h2 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h2><ul><li><p>上传安装包 解压</p><pre class=" language-shell"><code class="language-shell">tar zxvf apache-hive-3.1.2-bin.tar.gz</code></pre></li><li><p>解决Hive与Hadoop之间guava版本差异</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.3.0/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</code></pre></li><li><p>修改配置文件</p><ul><li><p>hive-env.sh</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/confmv hive-env.sh.template hive-env.shvim hive-env.sh## 大G小o 跳转到最后一行export HADOOP_HOME=/export/server/hadoop-3.3.0export HIVE_CONF_DIR=/export/server/apache-hive-3.1.2-bin/confexport HIVE_AUX_JARS_PATH=/export/server/apache-hive-3.1.2-bin/lib# Esc(退出输入模式)+shift+zz 快速保存</code></pre></li></ul></li><li><p>hive-site.xml</p><pre class=" language-shell"><code class="language-shell">vim hive-site.xml</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 存储元数据mysql相关配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionURL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>jdbc:mysql://node1:3306/hive3?createDatabaseIfNotExist=true<span class="token entity" title="&amp;">&amp;amp;</span>useSSL=false<span class="token entity" title="&amp;">&amp;amp;</span>useUnicode=true<span class="token entity" title="&amp;">&amp;amp;</span>characterEncoding=UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionDriverName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>com.mysql.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionUserName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionPassword<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- H2S运行绑定host --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.server2.thrift.bind.host<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>node1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 远程模式部署metastore metastore地址 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.metastore.uris<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>thrift://node1:9083<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 关闭元数据存储授权  --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.metastore.event.db.notification.api.auth<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre></li><li><p>上传mysql jdbc驱动到hive安装包lib下</p><pre class=" language-shell"><code class="language-shell">mysql-connector-java-5.1.32.jar</code></pre></li><li><p>初始化元数据</p></li></ul><p>检验安装是否正确</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/bin/schematool -initSchema -dbType mysql -verbos#初始化成功会在mysql中创建74张表</code></pre><ul><li><p>在hdfs创建hive存储目录（如存在则不用操作）</p><pre class=" language-shell"><code class="language-shell">hadoop fs -mkdir /tmphadoop fs -mkdir -p /user/hive/warehousehadoop fs -chmod g+w /tmphadoop fs -chmod g+w /user/hive/warehouse</code></pre><h2 id="metastore启动"><a href="#metastore启动" class="headerlink" title="metastore启动"></a>metastore启动</h2><h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><p>进程会一直占据终端，ctrl+c结束进程</p><ul><li>启动前台</li></ul><pre class=" language-shell"><code class="language-shell">/export/server/appache-hive-3.1.2-bin/bin/hive --service metastore</code></pre><ul><li>前台启动开启debug日志</li></ul><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive --service metastore --hiveconf hive.root.logger=DEBUG,console </code></pre><h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><ul><li>把程序当成一个进程</li></ul><pre class=" language-shell"><code class="language-shell">nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service metastore &</code></pre><p>回车后再按一次回车，就成功启动在后台了</p><p>之后通过jps 查看进程</p><p>使用kill -9杀死进程</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路1--基本概念</title>
      <link href="/2022/08/19/hive-xue-xi-zhi-lu-1-ji-ben-gai-nian/"/>
      <url>/2022/08/19/hive-xue-xi-zhi-lu-1-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive的优点"><a href="#Hive的优点" class="headerlink" title="Hive的优点"></a>Hive的优点</h2><p>1.接口操作采用类SQL语法，提供快速开发的能力，简单且容易上手<br>2.擅长存储分析海量数据，与Hadoop相似<br>3.避免直接写MapReduce，减少开发人员学习成本</p><p>Hive利用HDFS存储数据，利用MapResuce查询分析数据</p><h2 id="Hive功能的实现"><a href="#Hive功能的实现" class="headerlink" title="Hive功能的实现"></a>Hive功能的实现</h2><ol><li><p>Hive能将结构化文件映射成一张表，Hive并不承担存储数据功能，存储数据是由HDFS实现(将元数据信息描述清楚，转化成一个表)</p></li><li><p>用户写完sql后，Hive对sql进行校验，并且更具元数据信息解读sql背后的含义，最后将执行计划转换成MApReduce程序来具体执行</p></li></ol><p>有点类JDBC？<br>Hive是基于Hadoop的数仓工具 <img src="/%5Cimg%5Cposts%5CDataRepos%5CHive1.jpg" alt="Hive工作原理"></p><h2 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h2><p><img src="/%5Cimg%5Cposts%5CDataRepos%5CHive2.jpg" alt="Hive架构"></p><p>用户接口：包括CLI。JDBC/ODBC，WebGUI</p><p>元数据(metadata)存储 mysql/derby Hive中的元数据(描述数据的数据)包括表明，列的分区及属性，表的属性（是否为外部表等），表的数据所在的目录等</p><p>Driver驱动程序：包括语法解析器，计划编译器，优化器，执行器</p><p>执行引擎：MapReduce/Tez/Spark，Hive并不直接处理数据，而是通过执行引擎处理数据</p><p>Hadoop Yarn</p><p>HDFS/HBase</p><h2 id="Hive与元数据"><a href="#Hive与元数据" class="headerlink" title="Hive与元数据"></a>Hive与元数据</h2><p>Hive的安装模式与元数据服务(metastore)有关</p><p>metasore服务器配置有三种模式内嵌模式、本地模式、<strong>远程模式</strong></p><p><img src="/%5Cimg%5Cposts%5CDataRepos%5CHive3.jpg" alt="metastore"></p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓基本概念</title>
      <link href="/2022/08/19/shu-cang-ji-ben-gai-nian/"/>
      <url>/2022/08/19/shu-cang-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>数据仓库是构建面向分析的集成化数据环境，是一个用于存储、<strong>分析</strong>、报告的环境</p><h2 id="联机事务处理系统-OLTP"><a href="#联机事务处理系统-OLTP" class="headerlink" title="联机事务处理系统(OLTP)"></a>联机事务处理系统(OLTP)</h2><p>特征：前台接收的用户数据可以立即传送到后台进行处理，并在很短的时间内给出处理结果<br>关系型数据库是典型的OLTP应用，如MySQL，Oracle</p><p>数据库可以开展分析，但没必要。数据库一般读取压力明显大于写入的压力，如果直接再OLTP进行各种分析，会导致数据库读取压力倍增。</p><p><img src="/img/posts/DataRepos/01.jpg" alt="数仓例子"></p><h2 id="数仓主要特征"><a href="#数仓主要特征" class="headerlink" title="数仓主要特征"></a>数仓主要特征</h2><h3 id="Subject-Oriented"><a href="#Subject-Oriented" class="headerlink" title="Subject-Oriented"></a>Subject-Oriented</h3><p>主题是一个抽象概念，是较高层次上的<strong>数据综合</strong>、归类、并进行分析利用的抽象。再抽象层次上对数据进行完整、一致和准确的描述</p><h3 id="Non-Volatile"><a href="#Non-Volatile" class="headerlink" title="Non-Volatile"></a>Non-Volatile</h3><p>非易变性。数仓是分析数据的平台，而不是创造数据的平台。<br>书擦干的数据反应的是一段长时间内的历史数据的内容<br>数仓一般有<strong>大量的查询</strong>操作，但修改和删除很少</p><h3 id="Integrated"><a href="#Integrated" class="headerlink" title="Integrated"></a>Integrated</h3><p>主题相关的数据通常会分布在多个操作系统中，彼此分散、独立、异构。需要集成到数仓主题之下。</p><p>要统一源数据中的矛盾：包括字段的同名异义、单位不同、格式不同等</p><p>ETL：抽取、转换、加载</p><h3 id="Time-Variant"><a href="#Time-Variant" class="headerlink" title="Time-Variant"></a>Time-Variant</h3><p>时变性。数仓的数据需要随着时间更新，以适应决策的需要。</p><h2 id="数仓主流语言-SQL"><a href="#数仓主流语言-SQL" class="headerlink" title="数仓主流语言-SQL"></a>数仓主流语言-SQL</h2><p>结构化数据（行与列）–二维表结构来逻辑表达和实现的数据，严格遵循数据格式和长度规范</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop中Yarn的概述</title>
      <link href="/2022/08/19/hadoop-zhong-yarn-de-gai-shu/"/>
      <url>/2022/08/19/hadoop-zhong-yarn-de-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>学习参考<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=49&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">Hadoop入门</a></p><h2 id="Yarn的简介"><a href="#Yarn的简介" class="headerlink" title="Yarn的简介"></a>Yarn的简介</h2><p>Hdfsd大数据存储系统中的资源管理器主要为MapReduce与Yarn，是一个通用的<strong>资源管理系统</strong>和<strong>调度</strong>平台，可为上层应用提供统一的资源管理和调度，为集群再利用率，资源统一管理和数据共享等方面带来了巨大好处</p><p><strong>资源管理系统</strong>: 管理集群的硬件资源，包括内存，CPU等<br><strong>调度平台</strong>： 多个程序同时申请资源，如何进行合理的分配与调度<br>Yarn作为一个通用平台，说明它不仅仅支持MR（MapReuce）程序，理论上支持各种计算程序（Spark，HBase，Storm…）</p><p>可以把Yarn理解为一个分布式的操作系统平台，HDFS是应用最广泛的大数存储系统，Yarn功不可没</p><h2 id="Yarn中的组件"><a href="#Yarn中的组件" class="headerlink" title="Yarn中的组件"></a>Yarn中的组件</h2><p>主要是三大组件</p><p>集群物理层面：   ResourceManager<br>                NodeManager<br>APP层面：       ApplicationMaster</p><h3 id="ResourceManager-RM"><a href="#ResourceManager-RM" class="headerlink" title="ResourceManager(RM)"></a>ResourceManager(RM)</h3><p>Yarn集群中的著角色，决定系统中所有应用程序之间的资源分配器的<strong>最终</strong>权限，接收用户的作业提交，并通过NM分配，管理机器上的计算资源</p><h3 id="NodeManager-NM"><a href="#NodeManager-NM" class="headerlink" title="NodeManager(NM)"></a>NodeManager(NM)</h3><p>Yarn中的从角色，一个机器上一个，负责管理本机器上的计算资源使用情况<br>根据RM命令，启动Container容器，监视容器的资源使用情况，并且向RM著角色汇报资源使用情况</p><h3 id="ApplicationMaster-AM"><a href="#ApplicationMaster-AM" class="headerlink" title="ApplicationMaster(AM)"></a>ApplicationMaster(AM)</h3><p>用户提交的每个应用程序均包含一个AM<br>应用程序中的“老大”，负责程序内部个资源的申请，监督程序的执行情况<br>AM程序是应用程序内部启动的第一个程序</p><h2 id="Yarn程序提交流程"><a href="#Yarn程序提交流程" class="headerlink" title="Yarn程序提交流程"></a>Yarn程序提交流程</h2><p>核心交互流程主要有四步：<br>MR作业提交  Client -&gt; RM<br>资源的申请  MRAppMaster -&gt; RM<br>MR作业状态汇报 Container(Map | Reduce Task) -&gt; Container (MRAppMaster)<br>节点的状态汇报(Yarn集群内布)  NM -&gt;RM </p><h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>当用户向YARN中提交一个应用程序后，YARN将分为了两个阶段运行该应用程序<br>第一个阶段：客户端申请资源启动运行被刺程序的AppMaster<br>第二个阶段有AppMaster更具本次程序内部具体具体情况为她申请资源，并健康它的整个运行过程，知道运行完成</p><p><img src="/img/posts/Yarn/Yarn%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.jpg" alt="Yarn程序提交流程"></p><p>第一步:用户通过客户端向Yarn中的ResourceManager提交应用程序（如Hadoop，jar提交MR程序）</p><p>第二步：RM为该应用程序分配第一个container，并于对应的NM同学，要求它再这个container中启动该应用的AM</p><p>第三步：AM启动成功后，向RM注册并保持同学，这样用户可以直接通过RM查看应用程序的运行状态</p><p>第四步：AM为本次程序内部的各个Task向RM申请资源</p><p>第五步：一旦<strong>AM</strong>申请到资源，便于对应的NM通信，要求他启动任务</p><p>第六版：NM为任务设置好运行环境之后，将任务启动命令写入到一个脚本之中，并通过运行该脚本启动任务</p><p>第七步：各个人物通过某个<a href="https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE/5019569?fr=aladdin">RPC协议</a>向AM汇报自己的状态和进度，以让AM随时掌握各个人物的运行状态，可以再任务失败时重新启动任务。<br>在应用程序运行过沉重，用户可随时通过RPC向AM查询应用程序当前运行状态</p><p>第八步：应用程序运行完成后，AM向RM注销并关闭自己</p><h2 id="Yarn的资源调度器Scheduler"><a href="#Yarn的资源调度器Scheduler" class="headerlink" title="Yarn的资源调度器Scheduler"></a>Yarn的资源调度器Scheduler</h2><p>在Yarn中，负责给应用分配资源的是schduler，是RM的内部核心组件之一。Schduler完全用于调度作业，无法跟踪应用程序的状态。Yarn提供了多种调度器和可配置的策略供选择，可在yarn-sit.xml中的yarn.resourcemanager.schduler.class进行配置</p><h3 id="FIFO-Schduler"><a href="#FIFO-Schduler" class="headerlink" title="FIFO Schduler"></a>FIFO Schduler</h3><p>先入先出，拥有一个控制全局的队列Queue<br>不适合共享集群</p><h3 id="Capacity-Scheduler"><a href="#Capacity-Scheduler" class="headerlink" title="Capacity Scheduler"></a>Capacity Scheduler</h3><p>Apache版本一般默认Capacity Scheduler<br><strong>允许多个组织共享集群资源</strong>，每个组织都可以获得一部分集群计算能力。通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源，整个集群可以通过设置多个队列给多个组织提供服务。</p><p>Capacity 可以理解为一个个的资源队列，这个资源队列是用户自行分配。<br>再在队列内部进行垂直划分，使得一个组织内部分多个成员共享这个队列资源。<br><strong>在一个队列内部，资源调度是FIFO的</strong></p><p><img src="/img/posts/Yarn/Scheduler_task_div.jpg" alt="文件划分"></p><h3 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h3><p>提供了yarn应用程序中共享大型资源的方式</p><hr><p>例如：<br>用户A、B都有自己的队列 -&gt; A启动一个作业，而B还没有，此时A分配了集群中所有可用的资源 -&gt; B在A仍在运行时启动了一个作业，一段时间后，A、B各自作业都使用了一半的资源 -&gt; 若B此时再开启第二个作业，它将于B的另一个作业共享资源。A的一个作业仍占有1/2的资源，而B的两个作业各自占有1/4的资源</p><hr><p>Fair Scheduler支持资源抢占、基于用户的映射</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode部分汇总</title>
      <link href="/2022/08/02/leetcode-bu-fen-hui-zong/"/>
      <url>/2022/08/02/leetcode-bu-fen-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><hr><h2 id="96-不同的二叉搜索树-DP"><a href="#96-不同的二叉搜索树-DP" class="headerlink" title="96. 不同的二叉搜索树:DP"></a>96. 不同的二叉搜索树:DP</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP、卡特兰公式</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                 dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="95-不同的二叉搜索树2-DFS"><a href="#95-不同的二叉搜索树2-DFS" class="headerlink" title="95.不同的二叉搜索树2:DFS"></a>95.不同的二叉搜索树2:DFS</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br>（不只返回数字）</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>DFS</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h2 id="516-最长回文子序列-DP"><a href="#516-最长回文子序列-DP" class="headerlink" title="516. 最长回文子序列:DP"></a>516. 最长回文子序列:DP</h2><p>给定一个字符串s，找到其中最长的回文子序列（的长度）。<br>注意：子序列可以不连续的，可以跳过某些单词，子串是必须连续的</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>DP</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"></code></pre><h2 id="714-买卖股票的最佳时机含手续费-DP"><a href="#714-买卖股票的最佳时机含手续费-DP" class="headerlink" title="714. 买卖股票的最佳时机含手续费:DP"></a>714. 买卖股票的最佳时机含手续费:DP</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">,</span> <span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hold <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cash <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cash<span class="token punctuation">,</span> hold <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee<span class="token punctuation">)</span><span class="token punctuation">;</span>            hold <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">,</span> cash <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cash<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="139-单词拆分-DP-x2F-BST"><a href="#139-单词拆分-DP-x2F-BST" class="headerlink" title="139. 单词拆分:DP/BST"></a>139. 单词拆分:DP/BST</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><pre class=" language-java"><code class="language-java">Javapublic <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="516-最长回文子序列-DP-1"><a href="#516-最长回文子序列-DP-1" class="headerlink" title="516. 最长回文子序列:DP"></a>516. 最长回文子序列:DP</h2><h3 id="DP-步骤版"><a href="#DP-步骤版" class="headerlink" title="DP 步骤版"></a>DP 步骤版</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq2nd</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="300-最长上升子序列-DP、二分法插入"><a href="#300-最长上升子序列-DP、二分法插入" class="headerlink" title="300.最长上升子序列:DP、二分法插入"></a>300.最长上升子序列:DP、二分法插入</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这个数组实际上的长度，就是最后所求</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end<span class="token operator">++</span><span class="token punctuation">;</span>                tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用二分搜索法来做这件事情，二分法实现nlogn的时间复杂度</span>                <span class="token comment" spellcheck="true">// 修改目前tail中比target小的最大数为target</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>                <span class="token keyword">int</span> target <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">+</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//int mid = left + (right - left) / 2;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 只要比目标值要小，要找的位置就至少是当前位置 + 1</span>                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">assert</span> tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 大于目标值，不能盲目向前走，因为向前走很可能，值会变得比目标值小</span>                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                tail<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="494-目标和-DP-背包问题"><a href="#494-目标和-DP-背包问题" class="headerlink" title="494. 目标和:DP+背包问题"></a>494. 目标和:DP+背包问题</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/**     * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合     * 所以题目可以转化为     * sum(P) - sum(N) = target      * => sum(nums) + sum(P) - sum(N) = target + sum(nums)     * => 2 * sum(P) = target + sum(nums)      * => sum(P) = (target + sum(nums)) / 2     * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> S <span class="token operator">||</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>w <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">;</span> j <span class="token operator">>=</span> num<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="638-大礼包-DP"><a href="#638-大礼包-DP" class="headerlink" title="638. 大礼包:DP"></a>638. 大礼包:DP</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shoppingOffers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> price<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> special<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> needs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//统计不使用大礼包的总价</span>        <span class="token keyword">int</span> noSpecial <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>needs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            noSpecial <span class="token operator">+=</span> price<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> noSpecial<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历每一个大礼包</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sp <span class="token operator">:</span> special<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当前大礼包超过购买数量，跳过</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span>needs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用当前大礼包后，还有多少剩下的</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> newNeeds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Integer i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    newNeeds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//剩下的购买数量递归调用本方法，获取最低价格</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">shoppingOffers</span><span class="token punctuation">(</span>price<span class="token punctuation">,</span>special<span class="token punctuation">,</span>newNeeds<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//使用当前大礼包和不使用相比，选价格最低的</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>left <span class="token operator">+</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> special<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> needs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>needs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>special<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="651-4键键盘-DP-贪心算法"><a href="#651-4键键盘-DP-贪心算法" class="headerlink" title="651. 4键键盘:DP+贪心算法"></a>651. 4键键盘:DP+贪心算法</h2><p>复制粘贴还是直接输入，得到最长字符串</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxA</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token operator">></span>b <span class="token operator">?</span> a<span class="token operator">:</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="983-最低票价-DP"><a href="#983-最低票价-DP" class="headerlink" title="983. 最低票价:DP"></a>983. 最低票价:DP</h2><p>买火车票：1天、7天、30天</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> days<span class="token punctuation">,</span> costs<span class="token punctuation">;</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> durations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mincostTickets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> days<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>days <span class="token operator">=</span> days<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>costs <span class="token operator">=</span> costs<span class="token punctuation">;</span>        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>days<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> days<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> days<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> days<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> days<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> durations<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">dp</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目-DFS"><a href="#323-无向图中连通分量的数目-DFS" class="headerlink" title="323. 无向图中连通分量的数目:DFS"></a>323. 无向图中连通分量的数目:DFS</h2><pre class=" language-c++"><code class="language-c++">class Solution {public:    int countComponents(int n, vector<vector<int>>& edges) {        vector<int>a(n, 0);        vector<vector<int>>arr(n, a);        for (auto it : edges) {            arr[it[0]][it[1]] = 1;            arr[it[1]][it[0]] = 1;        }        int res = 0;        vector<int>mark(n, 0);        for (int i = 0; i < n; i++) {            if (mark[i] == 0) {                DFS(arr, mark, i);                res++;            }        }        return res;            }private:    void DFS(vector<vector<int>>&arr, vector<int>& mark,int b) {            mark[b] = 1;            for (int i = 0; i < arr.size(); i++) {                if (arr[i][b] == 1&&mark[i] == 0) {                    DFS(arr, mark,i);                }            }            mark[b] = 2;    }};</code></pre><h2 id="529-扫雷游戏-BFS-x2F-DFS"><a href="#529-扫雷游戏-BFS-x2F-DFS" class="headerlink" title="529. 扫雷游戏:BFS/DFS"></a>529. 扫雷游戏:BFS/DFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateBoard</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> click<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token function">visit</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>click<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>click<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>      <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> board<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span>                   count<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">else</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span><span class="token punctuation">)</span>                       <span class="token function">visit</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>       <span class="token punctuation">}</span>              <span class="token keyword">return</span> board<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="127-单词接龙：BFS"><a href="#127-单词接龙：BFS" class="headerlink" title="127. 单词接龙：BFS"></a>127. 单词接龙：BFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javafx<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Pair<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Since all words are of same length.</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> beginWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dictionary to hold combination of words that can be formed,</span>    <span class="token comment" spellcheck="true">// from any given word. By changing one letter at a time.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span> allComboDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        word <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Key is the generic word</span>            <span class="token comment" spellcheck="true">// Value is a list of words which have the same intermediate generic word.</span>            String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> transformations <span class="token operator">=</span>                allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            transformations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            allComboDict<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> transformations<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Queue for BFS</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Visited to make sure we don't repeat processing same word.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String word <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> level <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Intermediate words for current word</span>        String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Next states are all the words which share the same intermediate state.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String adjacentWord <span class="token operator">:</span> allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// If at any point if we find what we are looking for</span>          <span class="token comment" spellcheck="true">// i.e. the end word - we can return with the answer.</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>adjacentWord<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// Otherwise, add it to the BFS Queue. Also mark it visited</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双向广度优先搜索</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javafx<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Pair<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> L<span class="token punctuation">;</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span> allComboDict<span class="token punctuation">;</span>  <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dictionary to hold combination of words that can be formed,</span>    <span class="token comment" spellcheck="true">// from any given word. By changing one letter at a time.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>      Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q<span class="token punctuation">,</span>      HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visited<span class="token punctuation">,</span>      HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> othersVisited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String word <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Intermediate words for current word</span>      String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Next states are all the words which share the same intermediate state.</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>String adjacentWord <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If at any point if we find what we are looking for</span>        <span class="token comment" spellcheck="true">// i.e. the end word - we can return with the answer.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>othersVisited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> level <span class="token operator">+</span> othersVisited<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Save the level as the value of the dictionary, to save number of hops.</span>          visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wordList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Since all words are of same length.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>L <span class="token operator">=</span> beginWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        word <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Key is the generic word</span>            <span class="token comment" spellcheck="true">// Value is a list of words which have the same intermediate generic word.</span>            String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> transformations <span class="token operator">=</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            transformations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> transformations<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Queues for birdirectional BFS</span>    <span class="token comment" spellcheck="true">// BFS starting from beginWord</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q_begin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// BFS starting from endWord</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q_end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q_begin<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q_end<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>endWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Visited to make sure we don't repeat processing same word.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visitedBegin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visitedEnd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedBegin<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedEnd<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>endWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q_begin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Q_end<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// One hop from begin word</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>Q_begin<span class="token punctuation">,</span> visitedBegin<span class="token punctuation">,</span> visitedEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// One hop from end word</span>      ans <span class="token operator">=</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>Q_end<span class="token punctuation">,</span> visitedEnd<span class="token punctuation">,</span> visitedBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="139-单词拆分：BFS-x2F-DP"><a href="#139-单词拆分：BFS-x2F-DP" class="headerlink" title="139. 单词拆分：BFS/DP"></a>139. 单词拆分：BFS/DP</h2><p>BFS</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>DP</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="279-完全平方数-BST"><a href="#279-完全平方数-BST" class="headerlink" title="279. 完全平方数:BST"></a>279. 完全平方数:BST</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token keyword">int</span> step<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">=</span> step<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将问题转化成图论</span>    <span class="token comment" spellcheck="true">// 该算法在往队列里面添加节点的时候会 add 很多重复的节点，导致超时，</span>    <span class="token comment" spellcheck="true">// 优化办法是，加入 visited 数组，检查要 add 的数据是否已经出现过了，防止数据重复出现，从而影响图的遍历</span>    <span class="token comment" spellcheck="true">// 同时优化：num - i * i 表达式，只让他计算一次</span>    <span class="token comment" spellcheck="true">// 同时在循环体里面判断退出或返回的条件，而不是在循环体外</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 其实一个真正的图的 BSF 是一定会加上 visited 数组来过滤元素的</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">int</span> step <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>step<span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> a <span class="token operator">=</span> num <span class="token operator">-</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 若 a 已经计算到 0 了，就不必再往下执行了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    visited<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="515-在每个树行中找最大值-BFS"><a href="#515-在每个树行中找最大值-BFS" class="headerlink" title="515. 在每个树行中找最大值:BFS"></a>515. 在每个树行中找最大值:BFS</h2><p>在二叉树的每一行中找到最大的值。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">largestValues</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> rlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> rlist<span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> nodeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            rlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rlist<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="994-腐烂的橘子-BFS"><a href="#994-腐烂的橘子-BFS" class="headerlink" title="994. 腐烂的橘子:BFS"></a>994. 腐烂的橘子:BFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">orangesRotting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> R <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">,</span> C <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// queue : all starting cells with rotten oranges</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> depth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> C<span class="token punctuation">;</span> <span class="token operator">++</span>c<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> code <span class="token operator">=</span> r <span class="token operator">*</span> C <span class="token operator">+</span> c<span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>                    depth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> code <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> code <span class="token operator">/</span> C<span class="token punctuation">,</span> c <span class="token operator">=</span> code <span class="token operator">%</span> C<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nr <span class="token operator">=</span> r <span class="token operator">+</span> dr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nc <span class="token operator">=</span> c <span class="token operator">+</span> dc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nr <span class="token operator">&amp;&amp;</span> nr <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> nc <span class="token operator">&amp;&amp;</span> nc <span class="token operator">&lt;</span> C <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    grid<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> ncode <span class="token operator">=</span> nr <span class="token operator">*</span> C <span class="token operator">+</span> nc<span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ncode<span class="token punctuation">)</span><span class="token punctuation">;</span>                    depth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ncode<span class="token punctuation">,</span> depth<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans <span class="token operator">=</span> depth<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ncode<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row<span class="token operator">:</span> grid<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span> row<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a>646. 最长数对链</h2><p>按end排序 然后每次选择能放的end最小的一个数对加入当前的数对链</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLongestChain</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pairs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pairs<span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>tmp <span class="token operator">=</span> pairs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> pairs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>                 res<span class="token operator">++</span><span class="token punctuation">;</span>                 tmp <span class="token operator">=</span> pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="547-省份数量：无向图最小连通数：并查集-x2F-DFS"><a href="#547-省份数量：无向图最小连通数：并查集-x2F-DFS" class="headerlink" title="547.省份数量：无向图最小连通数：并查集/DFS"></a>547.省份数量：无向图最小连通数：并查集/DFS</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//无向图最小连通数</span><span class="token comment" spellcheck="true">// //并查集</span><span class="token comment" spellcheck="true">// class Solution {</span><span class="token comment" spellcheck="true">//     public int findCircleNum(int[][] M) {</span><span class="token comment" spellcheck="true">//         int s = M.length;</span><span class="token comment" spellcheck="true">//         UnionFind uf = new UnionFind(s);</span><span class="token comment" spellcheck="true">//         for(int i = 0;i&lt;s-1;i++)</span><span class="token comment" spellcheck="true">//             for(int j = i+1;j&lt;s;j++)</span><span class="token comment" spellcheck="true">//                 if(M[i][j] == 1) </span><span class="token comment" spellcheck="true">//                     uf.union(i,j);</span><span class="token comment" spellcheck="true">//         return uf.getSetCount();</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">// }</span>    <span class="token comment" spellcheck="true">//     public class UnionFind {</span><span class="token comment" spellcheck="true">// private int[] id; // 表示当前下标是父亲是谁，如in[3] = 1, 3的父亲是1。</span><span class="token comment" spellcheck="true">// private int[] size; </span><span class="token comment" spellcheck="true">// private int setCount; //连通个数</span><span class="token comment" spellcheck="true">// private int maxSetSize; //最大的size</span>        <span class="token comment" spellcheck="true">//         //初始化</span><span class="token comment" spellcheck="true">// public UnionFind(int n) {</span><span class="token comment" spellcheck="true">// id = new int[n];</span><span class="token comment" spellcheck="true">// size = new int[n];</span><span class="token comment" spellcheck="true">//             //父节点以及size的初始化</span><span class="token comment" spellcheck="true">// for (int i = 0; i &lt; n; i++) {</span><span class="token comment" spellcheck="true">// id[i] = i; // self-loop</span><span class="token comment" spellcheck="true">// size[i] = 1;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// setCount = n;</span><span class="token comment" spellcheck="true">// maxSetSize = 1;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// // O(logN)</span><span class="token comment" spellcheck="true">// public void union(int i, int j) {</span><span class="token comment" spellcheck="true">// int ri = root(i);</span><span class="token comment" spellcheck="true">// int rj = root(j);</span><span class="token comment" spellcheck="true">// if (ri == rj)</span><span class="token comment" spellcheck="true">// return;</span><span class="token comment" spellcheck="true">//             //将个数小的合并到个数大的集合中</span><span class="token comment" spellcheck="true">// if (size[ri] >= size[rj]) {</span><span class="token comment" spellcheck="true">// id[rj] = id[ri];</span><span class="token comment" spellcheck="true">// size[ri] += size[rj];</span><span class="token comment" spellcheck="true">// maxSetSize = Math.max(maxSetSize, size[ri]);</span><span class="token comment" spellcheck="true">// } else {</span><span class="token comment" spellcheck="true">// id[ri] = id[rj];</span><span class="token comment" spellcheck="true">// size[rj] += size[ri];</span><span class="token comment" spellcheck="true">// maxSetSize = Math.max(maxSetSize, size[rj]);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// setCount--;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// // O(logN)</span><span class="token comment" spellcheck="true">// public boolean find(int i, int j) {</span><span class="token comment" spellcheck="true">// return root(i) == root(j);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// public int getMaxSetSize() {</span><span class="token comment" spellcheck="true">// return maxSetSize;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// public int getSetCount() {</span><span class="token comment" spellcheck="true">// return setCount;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// private int root(int i) { // 不停向上寻找父节点</span><span class="token comment" spellcheck="true">// while (id[i] != i) { // keep checking for the self-loop</span><span class="token comment" spellcheck="true">// id[i] = id[id[i]]; // set grand-parent as parent (path compression)</span><span class="token comment" spellcheck="true">// i = id[i]; // go up to parent</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// return i;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">//DFS</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> N <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>i<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> si<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>si<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目-dfs"><a href="#323-无向图中连通分量的数目-dfs" class="headerlink" title="323. 无向图中连通分量的数目:dfs"></a>323. 无向图中连通分量的数目:dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countComponents</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> mark<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> map<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="934-最短的桥-dfs-x2F-bfs"><a href="#934-最短的桥-dfs-x2F-bfs" class="headerlink" title="934. 最短的桥:dfs/bfs"></a>934. 最短的桥:dfs/bfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//dfs寻找第一个岛屿，bfs寻找最断桥</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shortestBridge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix <span class="token operator">=</span> A<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//让A变成一个全局变量</span>        queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//控制dfs只寻找一个岛屿</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>found<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>found<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    found <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//cur[1]表示当前步数</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span>n<span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">%</span>n<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dir<span class="token operator">:</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> x <span class="token operator">=</span> i <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> y <span class="token operator">=</span> j <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">>=</span> n <span class="token operator">||</span> y <span class="token operator">>=</span> n <span class="token operator">||</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cur<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>x<span class="token operator">*</span>n<span class="token operator">+</span>y<span class="token punctuation">,</span>cur<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dir<span class="token operator">:</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> i<span class="token operator">+</span>dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> j<span class="token operator">+</span>dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>x<span class="token operator">>=</span>n<span class="token operator">||</span> y<span class="token operator">>=</span>n<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>n<span class="token operator">*</span>x<span class="token operator">+</span>y<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="207-课程表-有向图是否有环：拓扑排序-x2F-dfs"><a href="#207-课程表-有向图是否有环：拓扑排序-x2F-dfs" class="headerlink" title="207. 课程表:有向图是否有环：拓扑排序/dfs"></a>207. 课程表:有向图是否有环：拓扑排序/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*拓扑排序    *每一次都输出入度为0的结点，并移除它、修改它指向的结点的入度    *依次得到的结点序列就是拓扑排序的结点序列    *如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。    *拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面    *并且可以完成所有活动。拓扑排序的结果不唯一。    *拓扑排序还可以用于检测一个有向图是否有环    *拓扑排序实际上应用的是贪心算法    */</span>    <span class="token comment" spellcheck="true">// public boolean canFinish(int numCourses, int[][] prerequisites) {</span>    <span class="token comment" spellcheck="true">//     if (numCourses &lt;= 0) </span>    <span class="token comment" spellcheck="true">//         return false;</span>    <span class="token comment" spellcheck="true">//     int plen = prerequisites.length;</span>    <span class="token comment" spellcheck="true">//     if (plen == 0) </span>    <span class="token comment" spellcheck="true">//         return true;</span>    <span class="token comment" spellcheck="true">//     int[] inDegree = new int[numCourses]; //保存入度</span>    <span class="token comment" spellcheck="true">//     for (int[] p : prerequisites) </span>    <span class="token comment" spellcheck="true">//         inDegree[p[0]]++;</span>    <span class="token comment" spellcheck="true">//     LinkedList&lt;Integer> queue = new LinkedList&lt;>(); //保存入度为0的队列</span>    <span class="token comment" spellcheck="true">//     // 首先加入入度为 0 的结点</span>    <span class="token comment" spellcheck="true">//     for (int i = 0; i &lt; numCourses; i++) {</span>    <span class="token comment" spellcheck="true">//         if (inDegree[i] == 0) {</span>    <span class="token comment" spellcheck="true">//             queue.addLast(i);</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     // 拓扑排序的结果</span>    <span class="token comment" spellcheck="true">//     List&lt;Integer> res = new ArrayList&lt;>();</span>    <span class="token comment" spellcheck="true">//     while (!queue.isEmpty()) {</span>    <span class="token comment" spellcheck="true">//         Integer num = queue.removeFirst();</span>    <span class="token comment" spellcheck="true">//         res.add(num);</span>    <span class="token comment" spellcheck="true">//         // 把邻边全部遍历一下</span>    <span class="token comment" spellcheck="true">//         for (int[] p : prerequisites) {</span>    <span class="token comment" spellcheck="true">//             if (p[1] == num) {</span>    <span class="token comment" spellcheck="true">//                 inDegree[p[0]]--;</span>    <span class="token comment" spellcheck="true">//                 if (inDegree[p[0]] == 0) {</span>    <span class="token comment" spellcheck="true">//                     queue.addLast(p[0]);</span>    <span class="token comment" spellcheck="true">//                 }</span>    <span class="token comment" spellcheck="true">//             }</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return res.size() == numCourses;</span>    <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">/*深度优先遍历    *其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完    */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canFinish</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numCourses <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> prerequisites<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化有向图</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 有向图的 key 是前驱结点，value 是后继结点的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            graph<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span>        <span class="token comment" spellcheck="true">// 所有课程任务可以完成，应该返回 true</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span>    <span class="token comment" spellcheck="true">//return true 表示图中存在环，false 表示访问过了，不用再访问了</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果访问过了，就不用再访问了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从正在访问中，到正在访问中，表示遇到了环</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表示在访问的过程中没有遇到环，这个节点访问过了</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 走到这里，是因为初始化呢，此时 marked[i] == 0</span>        <span class="token comment" spellcheck="true">// 表示正在访问中</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后继结点的集合</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> successorNodes <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer successor <span class="token operator">:</span> successorNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>successor<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 层层递归返回 true ，表示图中存在环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>        <span class="token comment" spellcheck="true">// 状态设置为 2</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// false 表示图中不存在环</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="210-课程表-II：返回有向图路径：拓扑排序-x2F-dfs"><a href="#210-课程表-II：返回有向图路径：拓扑排序-x2F-dfs" class="headerlink" title="210. 课程表 II：返回有向图路径：拓扑排序/dfs"></a>210. 课程表 II：返回有向图路径：拓扑排序/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//拓扑排序</span><span class="token comment" spellcheck="true">//     public int[] findOrder(int numCourses, int[][] prerequisites) {</span><span class="token comment" spellcheck="true">//         if (numCourses &lt;= 0)</span><span class="token comment" spellcheck="true">//             return new int[0];</span>        <span class="token comment" spellcheck="true">//         // 邻接表表示</span><span class="token comment" spellcheck="true">//         HashSet&lt;Integer>[] graph = new HashSet[numCourses];</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//             graph[i] = new HashSet&lt;>();</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         // 入度表</span><span class="token comment" spellcheck="true">//         int[] inDegree = new int[numCourses];</span>        <span class="token comment" spellcheck="true">//         // 遍历 prerequisites 的时候，把 邻接表 和 入度表 都填上</span><span class="token comment" spellcheck="true">//         for (int[] p : prerequisites) {</span><span class="token comment" spellcheck="true">//             graph[p[1]].add(p[0]);</span><span class="token comment" spellcheck="true">//             inDegree[p[0]]++;</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         LinkedList&lt;Integer> queue = new LinkedList&lt;>();</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//             if (inDegree[i] == 0) {</span><span class="token comment" spellcheck="true">//                 queue.addLast(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         ArrayList&lt;Integer> res = new ArrayList&lt;>();</span><span class="token comment" spellcheck="true">//         while (!queue.isEmpty()) {</span><span class="token comment" spellcheck="true">//             Integer inDegreeNode = queue.removeFirst();</span><span class="token comment" spellcheck="true">//             res.add(inDegreeNode);</span><span class="token comment" spellcheck="true">//             HashSet&lt;Integer> nextCourses = graph[inDegreeNode];</span><span class="token comment" spellcheck="true">//             for (Integer nextCourse : nextCourses) {</span><span class="token comment" spellcheck="true">//                 inDegree[nextCourse]--;</span><span class="token comment" spellcheck="true">//                 // 马上检测该结点的入度是否为 0，如果为 0，马上加入队列</span><span class="token comment" spellcheck="true">//                 if (inDegree[nextCourse] == 0) {</span><span class="token comment" spellcheck="true">//                     queue.addLast(nextCourse);</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         // 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span><span class="token comment" spellcheck="true">//         int resLen = res.size();</span><span class="token comment" spellcheck="true">//         if (resLen == numCourses) {</span><span class="token comment" spellcheck="true">//             int[] ret = new int[numCourses];</span><span class="token comment" spellcheck="true">//             for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//                 ret[i] = res.get(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             //返回的是数组而不是ArrayList</span><span class="token comment" spellcheck="true">//             return ret;</span><span class="token comment" spellcheck="true">//         } else {</span><span class="token comment" spellcheck="true">//             return new int[0];</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">//DFS</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numCourses <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> prerequisites<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没有有向边，则表示不存在课程依赖，任务一定可以完成</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 初始化有向图 </span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 有向图的 key 是前驱结点，value 是后继结点的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            graph<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 使用 Stack 或者 List 记录递归的顺序，这里使用 Stack</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回空数组</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">assert</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> numCourses<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>                        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span>                        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">,</span>                        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从正在访问中，到正在访问中，表示遇到了环</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表示在访问的过程中没有遇到环，这个节点访问过了</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> successorNodes <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer successor <span class="token operator">:</span> successorNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>successor<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 层层递归返回 true ，表示图中存在环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>        <span class="token comment" spellcheck="true">// 状态设置为 2</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//拓扑排序</span><span class="token comment" spellcheck="true">//     private int[] inDegree;</span><span class="token comment" spellcheck="true">//     private boolean[][] graph;</span><span class="token comment" spellcheck="true">//     private boolean[] onQueue;</span><span class="token comment" spellcheck="true">//     private Queue&lt;Integer> queue;</span><span class="token comment" spellcheck="true">//     public int[] findOrder(int numCourses, int[][] prerequisites) {</span><span class="token comment" spellcheck="true">//         inDegree=new int[numCourses];</span><span class="token comment" spellcheck="true">//         graph=new boolean[numCourses][numCourses];</span><span class="token comment" spellcheck="true">//         onQueue=new boolean[numCourses];</span><span class="token comment" spellcheck="true">//         queue=new LinkedList&lt;>();</span><span class="token comment" spellcheck="true">//         //初始化</span><span class="token comment" spellcheck="true">//         for(int i=0;i&lt;prerequisites.length;i++){</span><span class="token comment" spellcheck="true">//             graph[prerequisites[i][1]][prerequisites[i][0]]=true;</span><span class="token comment" spellcheck="true">//             inDegree[prerequisites[i][0]]++;</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         int[] rt=new int[numCourses];</span><span class="token comment" spellcheck="true">//         int count=0;</span><span class="token comment" spellcheck="true">//         findNextInDegreeZero();</span><span class="token comment" spellcheck="true">//         while(!queue.isEmpty()){</span><span class="token comment" spellcheck="true">//             int v =queue.poll();</span><span class="token comment" spellcheck="true">//             rt[count++]=v;</span><span class="token comment" spellcheck="true">//             for(int i=0;i&lt;graph[v].length;i++){</span><span class="token comment" spellcheck="true">//                 if(graph[v][i]){</span><span class="token comment" spellcheck="true">//                     inDegree[i]--;</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             findNextInDegreeZero();</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         if(count==numCourses){</span><span class="token comment" spellcheck="true">//          return rt;   </span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return new int[]{};</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">//     public void findNextInDegreeZero(){</span><span class="token comment" spellcheck="true">//         for(int i=0;i&lt;inDegree.length;i++){</span><span class="token comment" spellcheck="true">//             if(inDegree[i]==0&amp;&amp;!onQueue[i]){</span><span class="token comment" spellcheck="true">//                 onQueue[i]=true;</span><span class="token comment" spellcheck="true">//                 queue.add(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="5-最长回文子串-中心扩展算法-x2F-DP-x2F-Manacher-算法-马拉车"><a href="#5-最长回文子串-中心扩展算法-x2F-DP-x2F-Manacher-算法-马拉车" class="headerlink" title="5. 最长回文子串:中心扩展算法/DP/Manacher 算法(马拉车)"></a>5. 最长回文子串:中心扩展算法/DP/Manacher 算法(马拉车)</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 中心扩展算法</span>    <span class="token comment" spellcheck="true">// 2n-1个中心（偶数+奇数）</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//奇数长度</span>            <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//偶数长度</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> L <span class="token operator">=</span> left<span class="token punctuation">,</span> R <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            L<span class="token operator">--</span><span class="token punctuation">;</span>            R<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// //动态规划</span>    <span class="token comment" spellcheck="true">// public String longestPalindrome(String s) {</span>    <span class="token comment" spellcheck="true">//     int len = s.length();</span>    <span class="token comment" spellcheck="true">//     if(len&lt;=1)</span>    <span class="token comment" spellcheck="true">//         return s;</span>    <span class="token comment" spellcheck="true">//     int longest = 1;</span>    <span class="token comment" spellcheck="true">//     String str = s.substring(0,1);</span>    <span class="token comment" spellcheck="true">//     boolean[][] dp = new boolean[len][len];</span>    <span class="token comment" spellcheck="true">//     for(int r=1;r&lt;len;r++) {</span>    <span class="token comment" spellcheck="true">//         for(int l=0;l&lt;r;l++) {</span>    <span class="token comment" spellcheck="true">//             if(s.charAt(l)==s.charAt(r) &amp;&amp; (r-l&lt;=2 || dp[l+1][r-1])) {</span>    <span class="token comment" spellcheck="true">//                 dp[l][r]=true;</span>    <span class="token comment" spellcheck="true">//                 if(r-l+1>longest) {</span>    <span class="token comment" spellcheck="true">//                     longest = r-l+1;</span>    <span class="token comment" spellcheck="true">//                     str = s.substring(l,r+1);</span>    <span class="token comment" spellcheck="true">//                 }</span>    <span class="token comment" spellcheck="true">//             }</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return str;</span>    <span class="token comment" spellcheck="true">// }</span>    <span class="token comment" spellcheck="true">//     //Manacher 算法(马拉车)</span><span class="token comment" spellcheck="true">//     //本质上还是中心扩散法</span><span class="token comment" spellcheck="true">//     int len;</span><span class="token comment" spellcheck="true">//     //插入字符，使长度始终未奇数，且不改变回文子串</span><span class="token comment" spellcheck="true">//     private String generateSDivided(String s, char divide) {</span><span class="token comment" spellcheck="true">//         if (s.indexOf(divide) != -1) {</span><span class="token comment" spellcheck="true">//             throw new IllegalArgumentException("参数错误，您传递的分割字符，在输入字符串中存在！");</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         StringBuilder sBuilder = new StringBuilder();</span><span class="token comment" spellcheck="true">//         sBuilder.append(divide);</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; len; i++) {</span><span class="token comment" spellcheck="true">//             sBuilder.append(s.charAt(i));</span><span class="token comment" spellcheck="true">//             sBuilder.append(divide);</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return sBuilder.toString();</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">//     public String longestPalindrome(String s) {</span><span class="token comment" spellcheck="true">//         len = s.length();</span><span class="token comment" spellcheck="true">//         if (len == 0) {</span><span class="token comment" spellcheck="true">//             return "";</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         String sDivided = generateSDivided(s, '#');</span><span class="token comment" spellcheck="true">//         int slen = sDivided.length();</span><span class="token comment" spellcheck="true">//         int[] p = new int[slen];</span><span class="token comment" spellcheck="true">//         int mx = 0;</span><span class="token comment" spellcheck="true">//         // id 是由 mx 决定的，所以不用初始化，只要声明就可以了</span><span class="token comment" spellcheck="true">//         int id = 0;</span><span class="token comment" spellcheck="true">//         int longestPalindrome = 1;</span><span class="token comment" spellcheck="true">//         String longestPalindromeStr = s.substring(0, 1);</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; slen; i++) {</span><span class="token comment" spellcheck="true">//             if (i &lt; mx) {</span><span class="token comment" spellcheck="true">//                 // 这一步是 Manacher 算法的关键所在，一定要结合图形来理解</span><span class="token comment" spellcheck="true">//                 // 这一行代码是关键，可以把两种分类讨论的情况合并</span><span class="token comment" spellcheck="true">//                 p[i] = Integer.min(p[2 * id - i], mx - i);</span><span class="token comment" spellcheck="true">//             } else {</span><span class="token comment" spellcheck="true">//                 // 走到这里，只可能是因为 i = mx</span><span class="token comment" spellcheck="true">//                 if (i > mx) {</span><span class="token comment" spellcheck="true">//                     throw new IllegalArgumentException("程序出错！");</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//                 p[i] = 1;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             // 老老实实去匹配，看新的字符</span><span class="token comment" spellcheck="true">//             //以i为中心，进行中心扩散</span><span class="token comment" spellcheck="true">//             while (i - p[i] >= 0 &amp;&amp; i + p[i] &lt; slen &amp;&amp; sDivided.charAt(i - p[i]) == sDivided.charAt(i + p[i])) {z</span><span class="token comment" spellcheck="true">//                 p[i]++;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             // 我们想象 mx 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span><span class="token comment" spellcheck="true">//             // 写到这里，我们发现，如果 mx 的值越大，</span><span class="token comment" spellcheck="true">//             // 进入上面 i &lt; mx 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span><span class="token comment" spellcheck="true">//             if (i + p[i] > mx) {</span>        <span class="token comment" spellcheck="true">//                 id = i;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             if (p[i] - 1 > longestPalindrome) {</span><span class="token comment" spellcheck="true">//                 longestPalindrome = p[i] - 1;</span><span class="token comment" spellcheck="true">//                 longestPalindromeStr = sDivided.substring(i - p[i] + 1, i + p[i]).replace("#", "");</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return longestPalindromeStr;</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//         int n = s.length();</span><span class="token comment" spellcheck="true">//         int[][] dp = new int[n][n];</span>        <span class="token comment" spellcheck="true">//         //00, 11, 22, 33, 44</span><span class="token comment" spellcheck="true">//         for(int i=0; i&lt;n; i++){</span><span class="token comment" spellcheck="true">//             dp[i][i] = 1;//从i到j的最长回文子序列长度</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         //01, 12, 23, 34</span><span class="token comment" spellcheck="true">//         //02,13,24</span><span class="token comment" spellcheck="true">//         //03,14</span><span class="token comment" spellcheck="true">//         //04</span><span class="token comment" spellcheck="true">//         for(int l=2; l&lt;=n; l++){//l是子序列长度</span><span class="token comment" spellcheck="true">//             for(int i=0; i&lt;n-l+1; i++){//i是start</span><span class="token comment" spellcheck="true">//                 int j = i+l-1;//j是end</span><span class="token comment" spellcheck="true">//                 if(l==2 &amp;&amp; s.charAt(j) == s.charAt(i)) dp[i][j] = 2;//长度为2</span><span class="token comment" spellcheck="true">//                 else if (s.charAt(j) == s.charAt(i)) dp[i][j] = 2 + dp[i+1][j-1];</span><span class="token comment" spellcheck="true">//                 else dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return dp[0][n-1];//从0到n-1</span>                <span class="token comment" spellcheck="true">//改进 从后往前（应该和从前往后一样）</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> current<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            current<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    current<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>pre<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    current<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>current<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>current<span class="token punctuation">;</span>            current<span class="token operator">=</span>tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//     //回溯</span><span class="token comment" spellcheck="true">//     public boolean isMatch(String text, String pattern) {</span><span class="token comment" spellcheck="true">//         if (pattern.isEmpty())</span><span class="token comment" spellcheck="true">//             return text.isEmpty();</span><span class="token comment" spellcheck="true">//         boolean first_match = (!text.isEmpty() &amp;&amp;</span><span class="token comment" spellcheck="true">//                                (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));</span><span class="token comment" spellcheck="true">//         if (pattern.length() >= 2 &amp;&amp; pattern.charAt(1) == '*'){</span><span class="token comment" spellcheck="true">//             return (isMatch(text, pattern.substring(2)) ||</span><span class="token comment" spellcheck="true">//                     (first_match &amp;&amp; isMatch(text.substring(1), pattern)));</span><span class="token comment" spellcheck="true">//         } else {</span><span class="token comment" spellcheck="true">//             return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">//动态规划 自顶向下</span>    <span class="token comment" spellcheck="true">//其实只是想回溯的结果记录，即备忘录</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不能用boolean,无法判断是否已保存结果（==null）</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans <span class="token operator">=</span> i <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">boolean</span> first_match <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                                   <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">||</span>                                    pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token operator">||</span>                       first_match <span class="token operator">&amp;&amp;</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                ans <span class="token operator">=</span> first_match <span class="token operator">&amp;&amp;</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//     //动态规划 自底向上</span><span class="token comment" spellcheck="true">//     public boolean isMatch(String text, String pattern) {</span><span class="token comment" spellcheck="true">//         boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];</span><span class="token comment" spellcheck="true">//         dp[text.length()][pattern.length()] = true;</span><span class="token comment" spellcheck="true">//         for (int i = text.length(); i >= 0; i--){</span><span class="token comment" spellcheck="true">//             for (int j = pattern.length() - 1; j >= 0; j--){</span><span class="token comment" spellcheck="true">//                 boolean first_match = (i &lt; text.length() &amp;&amp;</span><span class="token comment" spellcheck="true">//                                        (pattern.charAt(j) == text.charAt(i) ||</span><span class="token comment" spellcheck="true">//                                         pattern.charAt(j) == '.'));</span><span class="token comment" spellcheck="true">//                 if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j+1) == '*'){</span><span class="token comment" spellcheck="true">//                     dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];</span><span class="token comment" spellcheck="true">//                 } else {</span><span class="token comment" spellcheck="true">//                     dp[i][j] = first_match &amp;&amp; dp[i+1][j+1];</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return dp[0][0];</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="44-通配符匹配：双指针-x2F-动态规划"><a href="#44-通配符匹配：双指针-x2F-动态规划" class="headerlink" title="44. 通配符匹配：双指针/动态规划"></a>44. 通配符匹配：双指针/动态规划</h2><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><ul><li>‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符串（包括空字符串）。</li></ul></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//双指针</span>    <span class="token comment" spellcheck="true">// public boolean isMatch(String s, String p) {</span>    <span class="token comment" spellcheck="true">//     int sn = s.length();</span>    <span class="token comment" spellcheck="true">//     int pn = p.length();</span>    <span class="token comment" spellcheck="true">//     int i = 0;</span>    <span class="token comment" spellcheck="true">//     int j = 0;</span>    <span class="token comment" spellcheck="true">//     int start = -1;</span>    <span class="token comment" spellcheck="true">//     int match = 0;</span>    <span class="token comment" spellcheck="true">//     while (i &lt; sn) {</span>    <span class="token comment" spellcheck="true">//         if (j &lt; pn &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {</span>    <span class="token comment" spellcheck="true">//             i++;</span>    <span class="token comment" spellcheck="true">//             j++;</span>    <span class="token comment" spellcheck="true">//         } else if (j &lt; pn &amp;&amp; p.charAt(j) == '*') {</span>    <span class="token comment" spellcheck="true">//             start = j;</span>    <span class="token comment" spellcheck="true">//             match = i;</span>    <span class="token comment" spellcheck="true">//             j++;</span>    <span class="token comment" spellcheck="true">//         } else if (start != -1) { //还没到*匹配结束的位置</span>    <span class="token comment" spellcheck="true">//             j = start + 1;</span>    <span class="token comment" spellcheck="true">//             match++;</span>    <span class="token comment" spellcheck="true">//             i = match;</span>    <span class="token comment" spellcheck="true">//         } else {</span>    <span class="token comment" spellcheck="true">//             return false;</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     while (j &lt; pn) { //i=sn 即i指针已结束，但j指针还没结束</span>    <span class="token comment" spellcheck="true">//         if (p.charAt(j) != '*') return false;</span>    <span class="token comment" spellcheck="true">//         j++;</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return true;</span>    <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">//动态规划</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//*为任意字符或空字符</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目要求-2"><a href="#题目要求-2" class="headerlink" title="题目要求"></a>题目要求</h3><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    bool isHappy(int n) {        unordered_set<int> bobo;        while(!bobo.count(n)){            int sum = 0;            bobo.insert(n);            while(n != 0){                sum = sum + (n%10) * (n%10);                n /= 10;            }            n = sum;        }        return n == 1;    }};//递归class Solution {public:    unordered_set<int> bobo;    bool isHappy(int n) {        int sum = 0;        if(n == 1) return true;        else if(bobo.count(n))  return false;        else{            bobo.insert(n);            while(n != 0){                sum = sum + (n%10) * (n%10);                n /= 10;            }            n = sum;        }        return isHappy(n);    }};</code></pre><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><h3 id="题目要求-3"><a href="#题目要求-3" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断无向图是否有换，以及是否为单连通分量</span>    <span class="token comment" spellcheck="true">//当只有n-1条边，且连通数为1时，符合条件</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只应该有n-1条边</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> par <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> par1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>par2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            par<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//并查集，每个点的父节点是自己</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            par1 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            par2 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不断向上寻找得到par1和par2的祖先节点</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">)</span>                par1 <span class="token operator">=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">while</span><span class="token punctuation">(</span>par2 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">)</span>                par2 <span class="token operator">=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par2<span class="token punctuation">)</span><span class="token punctuation">{</span>                par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span> <span class="token operator">=</span> par1<span class="token punctuation">;</span>                n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="695-岛屿的最大面积-最大的无向连通图-x2F-dfs"><a href="#695-岛屿的最大面积-最大的无向连通图-x2F-dfs" class="headerlink" title="695. 岛屿的最大面积:最大的无向连通图/dfs"></a>695. 岛屿的最大面积:最大的无向连通图/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//最大的无向连通图 模板</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        c <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>c<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//直接返回当前dfs的数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> i<span class="token operator">>=</span>r <span class="token operator">||</span> j<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">>=</span>c <span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//grid[i][j]==0一定要放在最后面，避免下标越界</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="394-字符串解码-栈"><a href="#394-字符串解码-栈" class="headerlink" title="394. 字符串解码:栈"></a>394. 字符串解码:栈</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">decodeString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>String<span class="token operator">></span> strStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String tempStr <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i用来控制指针坐标</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> numStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String nowStr <span class="token operator">=</span> <span class="token function">repeatStr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>numStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   StringBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//将后面不需要重复的字符（遇到下一个]和数字之前的字符）加到builder后面</span>                   <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       m<span class="token operator">++</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                   builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    tempStr <span class="token operator">=</span> null<span class="token punctuation">;</span>                    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//可能是个多位数</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    m<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                numStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//得到下一个字符串</span>                <span class="token keyword">int</span> k <span class="token operator">=</span>  i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>                    k<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">repeatStr</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//两遍哈希</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> i<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一遍哈希</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-无重复字符的最长子串：滑动窗口"><a href="#3-无重复字符的最长子串：滑动窗口" class="headerlink" title="3. 无重复字符的最长子串：滑动窗口"></a>3. 无重复字符的最长子串：滑动窗口</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Character<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化：使用 HashMap</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// current index of character</span>        <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化：假设字符集为 ASCII 128</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// current index of character</span>        <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>index<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="20-有效的括号：栈"><a href="#20-有效的括号：栈" class="headerlink" title="20. 有效的括号：栈"></a>20. 有效的括号：栈</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Hash table that takes care of the mappings.</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span> mappings<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Initialize hash map with mappings. This simply makes the code easier to read.</span>  <span class="token keyword">public</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Initialize a stack to be used in the algorithm.</span>    Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// If the current character is a closing bracket.</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Get the top element of the stack. If the stack is empty, set a dummy value of '#'</span>        <span class="token keyword">char</span> topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'#'</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// If the mapping for this bracket doesn't match the stack's top element, return false.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topElement <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If it was an opening bracket, push to the stack.</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If the stack still contains elements, then it is an invalid expression.</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//大顶堆</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// init heap 'the smallest element first'</span>        PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> heap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> n1 <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// keep k largest elements in the heap</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>          heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>            heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// output</span>        <span class="token keyword">return</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//快速选择（类似快排）</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. move pivot to end</span>    <span class="token function">swap</span><span class="token punctuation">(</span>pivot_index<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> store_index <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. move all smaller elements to the left</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>store_index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        store_index<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3. move pivot to its final place</span>    <span class="token function">swap</span><span class="token punctuation">(</span>store_index<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> store_index<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">quickselect</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k_smallest<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    Returns the k-th smallest element of list within left..right.    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If the list contains only one element,</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// return that element</span>    <span class="token comment" spellcheck="true">// select a random pivot_index</span>    Random random_num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot_index <span class="token operator">=</span> left <span class="token operator">+</span> random_num<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>         pivot_index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> pivot_index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the pivot is on (N - k)th smallest position</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_smallest <span class="token operator">==</span> pivot_index<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>k_smallest<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// go left side</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k_smallest <span class="token operator">&lt;</span> pivot_index<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> pivot_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// go right side</span>    <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span>pivot_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// kth largest is (N - k)th smallest</span>    <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="703-数据流中的第K大元素-最小堆"><a href="#703-数据流中的第K大元素-最小堆" class="headerlink" title="703. 数据流中的第K大元素:最小堆"></a>703. 数据流中的第K大元素:最小堆</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">KthLargest</span> <span class="token punctuation">{</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxHeap<span class="token punctuation">;</span>     <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//维护一个大小为k的最小堆 堆顶即是第k大的元素</span>    <span class="token keyword">public</span> <span class="token function">KthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        length <span class="token operator">=</span> k<span class="token punctuation">;</span>        maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;=</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                maxHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//最小堆</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历map，用最小堆保存频率最大的k个元素</span>        PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">,</span> Integer b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取出最小堆中的元素</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//桶排序法</span><span class="token comment" spellcheck="true">//基于桶排序求解「前 K 个高频元素」</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//桶排序</span>        <span class="token comment" spellcheck="true">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取出现的次数作为下标</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>               list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 倒序遍历数组获取出现顺序从大到小的排列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//官方题解</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// build hash map : character and how often it appears</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      count<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// init heap 'the less frequent element first'</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> heap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">-</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// keep k top frequent elements in the heap</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>        heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// build output list</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> top_k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      top_k<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>top_k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> top_k<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习</title>
      <link href="/2022/05/31/shu-ju-jie-gou-fu-xi/"/>
      <url>/2022/05/31/shu-ju-jie-gou-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul><li><p>线式存储结构： 结构地址空间连接，可随机访问，但顺序存储插入操作需要移动之后的元素，要耗费许多时间。</p></li><li><p>链式存储：不要求逻辑上相邻的元素在物理上相连，元素之间的逻辑关系通过指针表示。</p></li><li><p>顺序存储： 逻辑上相邻物理也相邻</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈： 先入后出，在表的末端（栈顶）进行插入删除，栈的存储结构分为<strong>基于数组的存储表示和顺序存储结构</strong>和<strong>基于链表的链式存储结构</strong><br>    - 顺序栈的内存结构：存放栈中元素的数组、栈顶指针、最大容纳元素个数<br>    - 链式栈的内存结构：栈顶指针  </p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列：先入先出，队尾插入队首删除。<ul><li><p>队列的顺序存储结构利用一个<em>一维数组</em>作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。</p></li><li><p>队列的链式队列由队首指针和队尾指针构成。</p></li><li><p>循环队列元素个数 = （尾 - 头 + 表长） % 表长</p><ol><li>当尾 &gt; 头， 元素个数 = 尾 - 头</li><li>因为是循环队列，可能出现头&gt;尾的情况， 此时元素个数 = 尾 - 头 + 表长<br>  为了得到一个统一的公式–循环队列元素个数 = （尾 - 头 + 表长） % 表长</li></ol></li><li><p>判断循环队列队空、队满的方法：<br>  front表示队头指针（指向队列内首元素）,rear表示队尾指针（指向队列内尾元素的下一个位置）,m表示队列的容量（包括那个留空的位置）</p><p>  <strong>队列内元素个数：(rear - front + m) % m</strong></p><p>  <img src="/img/posts/DataStructure/cycle_queue3.jpg"></p><p>  当队列为空时条件：<strong>rear == front</strong>，当队列满时条件为：<strong>（rear+1）% maxsize == front</strong></p></li></ul></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>hash表的实现主要包括构造哈希和处理哈希冲突两个方面：</p><p>对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。</p><p>对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>保持原图的n个系节点，并且有保持图联通的最少边。简单来说是有钱仅有n个点n-1条边的连通图。</p></li><li><p>最小生成树就是最小权重生成树的简称，即所有边的权值之和最小的生成树。</p></li></ul><p>求解最小生成树的方法有一下两种</p><h5 id="Kruskal算法（克鲁斯卡）"><a href="#Kruskal算法（克鲁斯卡）" class="headerlink" title="Kruskal算法（克鲁斯卡）"></a>Kruskal算法（克鲁斯卡）</h5><p>Kruskal是一种贪心算法</p><ul><li><p>核心思想：每次选择一条最小的边，使这两条边两头连通 </p></li><li><p>将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树。</p></li><li><p>如果两个顶点在同一个集合内，说明已经通过其他边相连，如果将这条边加入生成树，就会形成环，因此不可取</p></li></ul><p>Kruskal算法时间复杂的：O(mlogm),Kruskal算法的简单实现</p><pre class=" language-Java"><code class="language-Java">//Kruskal算法简单实现void Kruskal(V,T){    T = V; //初始化树T，仅含顶点    numS = n; //连通分量数    while(numS > 1) //若连通分量数大于1    {        从E中取出权值最小的边(v,u);        if(v和u属于T中不同的连通分量)        {            T=T∪{(v,u)}; //将此边加入生成树中            numS--; //连通分量数减1        }    }}</code></pre><p><img src="/img/posts/DataStructure/kruskal0.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法汇总</title>
      <link href="/2022/05/01/pai-xu-suan-fa-hui-zong/"/>
      <url>/2022/05/01/pai-xu-suan-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<ul><li>为了方便表示,提前定义swap(num[],i,j)<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>从左到右不断交换相邻的逆序的元素，复杂度为O(N^2)</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isSorted<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            isSorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    isSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    </code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>左侧是以及排好序的涉猎，每次排序都将当前元素插入左侧已经排序的数组中，是的插入之后左侧数组依然有序。</p></li><li><p>以数组[3,4,1,5,2]为例，逆序的对有(3,1),(3,2)(4,1)(4,2)(5,2)，插入排序每次交换逆序元素，因此插入排序交换的次数为逆序的数量插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要交换的次数也少，时间复杂度较低</p></li><li><p>Worst case:数组倒序</p></li><li><p>Best case:数组有序</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 这一步会把左边的都排好序 */</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>时间复杂度：*<em>最坏情况下为O(N</em>N)**，此时待排序列为逆序，或者说接近逆序最好情况下为O(N)，此时待排序列为升序，或者说接近升序。<br>空间复杂度：O(1)</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>插入排序不适用于，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的难以处理大规模数组的问题，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><ul><li><p>先将待排序数组进行与排序，是的待排序数组接近于有序，再对该序列进行一次插入排序</p></li><li><p>eg:<br>  3 2 5 4 1 6(gap = 6)<br>  3 2 5 4 1 6(gap = 6/2 = 3) (3,4)是正序，不需要改变<br>  3 1 5 4 2 6(gap = 3) (2,1)变成（1,2）<br>  3 1 5 4 2 6(gap = 3) (5,6)是正序不需要改变<br>  3/2 = 1,此时用插入排序（若gap = 10，10/2 = 5， 5/2 =2&gt;1,则在以gap = 2进行排序</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 4, 13, 40, ...</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> h <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>时间复杂度平均：O(N^1.3)</strong><br><strong>空间复杂度：O(1)</strong></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>时间复杂度：最坏情况：<strong>O(N^2)</strong><br>            最好情况：O(N^2)<br>空间复杂度：O(1)</p><ul><li>改进：我们可以一次性选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆是一颗完全二叉树</strong>，可以用数组来表示，因为完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。</p><ul><li>大根堆：所有父节点大于子节点<br>  小根堆：所有父节点小于子节点</li></ul><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>maxN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T t <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="堆的上浮与下沉"><a href="#堆的上浮与下沉" class="headerlink" title="堆的上浮与下沉"></a>堆的上浮与下沉</h4><ul><li>一般采用大根堆–当一个节点比父节点大时，需要交换这两个节点。交换后可能还比它的新的父节点大，因此需要不断地进行比较和交换，这就是上浮操作。</li></ul><p>k/2是父节点</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> j<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h4><ul><li><p>插入：将新元素放到数组末尾，然后上浮到合适的位置</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        heap<span class="token punctuation">[</span><span class="token operator">++</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token function">swim</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>删除：从堆顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> T <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        T max <span class="token operator">=</span> heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul><h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>参考<a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/p57uhr/">Leetcode图解算法结构–快速排序</a><br>快速排序算法有两个核心点，分别为 哨兵划分 和 递归 .</p><h4 id="哨兵划分："><a href="#哨兵划分：" class="headerlink" title="哨兵划分："></a>哨兵划分：</h4><p>以数组某个元素（一般选取首元素）为 基准数 ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p><p>如数组 [3,2,5,1,0,4]<br>选取最左元素arr[0] = 3作为 l， 最右元素arr[5] = 4 作为r，假设以arr[0] = 3作为哨兵，那么令 i 从 l 开始向左移动，令 j 从 r 开始向右移动<br>[3,2,5,1,0,4]<br> i         j<br> 此时arr[j]=4&gt;3,所以j左移<br>[3,2,5,1,0,4]<br> i       j<br> 此时arr[j] = 0 &lt; 3, j不动， i开始移动<br>[3,2,5,1,0,4]<br>     i   j<br>此时arr[i] = 5 &lt; 3，所以<strong>此时arr[i]与arr[j]元素交换位置</strong>，原数组变为[3,2,0,1,5,4]， j继续左移<br>[3,2,0,1,5,4]<br>     i j<br> 此时arr[j] = 1 &lt; 3, j不动， i开始移动</p><p>[3,2,0,1,5,4]<br>       ij<br>此时i,j相遇，将该元素与最左元素，也就是<strong>哨兵元素</strong>换位，原数组变为<br>[1,2,0,3,5,4]</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>以哨兵元素作为划分标准，哨兵元素左侧的数组为左子数组，哨兵元素右侧的数组为右子数组。<br>快排后数组[1,2,0,3,5,4],左子数组为[1,2,0] 哨兵：3 右子数组为[5,4]<br>然后对左右子数组重复快排<br>左子数组[1,2,0] -&gt; [1,0,2] -&gt; [0,1,2]<br>右子数组[5,4] -&gt; [4,5]</p><p>[0,1,2] 3 [4,5]</p><p>排序完成</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 分类，其中每次返回的i其实正是哨兵的数字     * @param arr     * @param l     * @param r     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> sentry <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token operator">+</span>r<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义哨兵</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> r<span class="token punctuation">,</span>i <span class="token operator">=</span> l<span class="token punctuation">;</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 递归，多次快排     * @param arr     * @param l     * @param r     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SortInRecurse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">Sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num:"</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SortInRecurse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SortInRecurse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/p5l0js/">算法解析</a><br>归并排序体现了 “分而治之” 的算法思想，具体为：</p><p>「分」： 不断将数组从 中点位置 划分开，将原数组的排序问题转化为子数组的排序问题；<br>「治」： 划分到子数组长度为 1 时，开始向上合并，不断将 左右两个较短排序数组 合并为 一个较长排序数组，直至合并至原数组时完成排序；</p><p><img src="/img/posts/DataStructure/merge_sort.jpg" alt="Merge"></p><p>该算法可以分为划分子数组和合并子数组两步</p><p>如数组[4,2,3,1]<br>先分为[4,2],[3,1]<br>再分为[4][2][3][1]</p><p>合并：对于原数组[4，2，3，1]，构建一个tmp数组，存放每次递归中的<strong>arr子数组</strong>。如第一次<strong>递归tmp[] = [4,2]</strong>,m为原数组中间数 = (r+l)/2 = 0，l为最左侧 = 0，r为最右侧 = 1。<br> 令i = 0, j = m-l+1 = 1, tmp[i] = 4, tmp[j] = 2 , 因为2&lt;4， 令arr[0]2，然后j++, 发现右数组遍历完成，由此原数组 **arr = [2,2,3,1]**<br>在arr[1] = tmp[j], 原数组 **arr[] = [2，4，3，1]**, j++, tmp[j] = 3 &gt; tmp[i] = 2</p><p>[1，3]同理（此时是新一轮为递归）, 此时原数组为[2，4，3，1],tmp[] = [3,1], l = 2, r = 3, m = 2, 重新令i = 0, j = m-l+1 = 1。 tmp[i] = 1 &gt; tmp[j] = 3, 因此arr[2] = tmp[j] = 1，原数组 <strong>arr[] = [2,4,1,1]</strong>,j++,发现j&gt;=r-l, 开始直接将tmp[i]加入数组，此时原数组 <strong>arr[] = [2,4,1,3]</strong>,归并结束 </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// partition</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>r<span class="token operator">+</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// merge</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        注意因为每次递归都会更新一部分的arr        比如原arr[3,1,4,2]        第一次递归对3,1排序， 排完后arr变成[1,3,4,2]        第二次递归需要对4,2排序,所以要求arr的下标从arr[2]也就是4开始,因此int k = l 而不是 0         */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> m<span class="token operator">-</span>l<span class="token punctuation">)</span>  <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// if left approch the end</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> r<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="对链表归并"><a href="#对链表归并" class="headerlink" title="对链表归并"></a>对链表归并</h5><p><a href="https://leetcode.cn/problems/sort-list/">Leetcode148</a><br>148. 排序链表<br>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>如4-&gt;1-&gt;3 返回 1-&gt;3-&gt;4</p><p>注意链表和数组的不同，链表由于没有下标，在划分的时候，用快慢指针，fast每次移动两步，而slow每次移动一步</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> ListNode <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            fast <span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode mid <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode left <span class="token operator">=</span> <span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode right <span class="token operator">=</span>  <span class="token function">sortList</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode res <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">></span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> right<span class="token punctuation">;</span>                right <span class="token operator">=</span> right<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> left<span class="token punctuation">;</span>                left <span class="token operator">=</span> left<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> left <span class="token operator">==</span> null<span class="token operator">?</span> right<span class="token operator">:</span> left<span class="token punctuation">;</span>          <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter使用指北</title>
      <link href="/2022/03/17/jupyter-shi-yong-zhi-bei/"/>
      <url>/2022/03/17/jupyter-shi-yong-zhi-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用pip进行安装，为了避免可能产生的配置错误，这里直接进入conda虚拟环境进行安装</p><pre class=" language-cmd"><code class="language-cmd">    conda activate jupyter    pip install jupyter</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre class=" language-cmd"><code class="language-cmd">    jupyter notebook</code></pre><p>注意使用该命令所在的目录，如果直接在user目录下运行该指令，打开jupyter会出现<br><img src="/img/posts/config/Jupyter_desktop.jpg" alt="C:\Users> jupyter notebook"><br>如果有要直接打开的项目，可cd到指定的目录下在运行jupyter notebook命令</p><h2 id="Kernel-内核配置"><a href="#Kernel-内核配置" class="headerlink" title="Kernel 内核配置"></a>Kernel 内核配置</h2><ul><li><p>查看内核</p><pre class=" language-cmd"><code class="language-cmd">    jupyter kernelspec list</code></pre><p>可以查看指定目录下的kernel.json文件，看python解释器的位置是否正确</p></li><li><p>添加内核(在该虚拟环境下)</p><pre class=" language-cmd"><code class="language-cmd">    python -m ipykernel install --name jupyerEnv --display-name jupyterEnv --prefix=E:\Software\Anaconda\Anaconda\envs\unity\</code></pre><p>  会添加到E:\Software\Anaconda\Anaconda\share\jupyter\kernels\jupyterEnv目录下</p></li><li><p>删除内核</p><pre class=" language-cmd"><code class="language-cmd">    jupyter kernelspec remove jupyterEnv</code></pre></li></ul><h2 id="jupyter与python环境"><a href="#jupyter与python环境" class="headerlink" title="jupyter与python环境"></a>jupyter与python环境</h2><p>一般jupyter会默认使用anaconda默认的python环境，也就是说，在某个虚拟环境中pip的包，在jupyter中不一定能成功地import<br>所有如果要在某个环境下使用jupyter<br>先 conda activate 该环境<br>再在该环境下jupyter notebook</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本知识</title>
      <link href="/2022/03/16/linux-ji-ben-zhi-shi/"/>
      <url>/2022/03/16/linux-ji-ben-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-环境"><a href="#linux-环境" class="headerlink" title="linux 环境"></a>linux 环境</h2><p>Linux内核的源码开源网站(<a href="http://www.kernel.org/">http://www.kernel.org</a>)<br>Linux常用的发行版本： Ubuntu， CentOs， RedHat</p><h2 id="Linux-目录"><a href="#Linux-目录" class="headerlink" title="Linux 目录"></a>Linux 目录</h2><p>~ home目录<br>/ root目录<br>/lib 系统使用的函数库的沐浴露<br>/etc 系统配置文件村对方的目录<br>/bin 二进制文件存放目录</p><h2 id="Linux-指令"><a href="#Linux-指令" class="headerlink" title="Linux 指令"></a>Linux 指令</h2><h3 id="目录指令"><a href="#目录指令" class="headerlink" title="目录指令"></a>目录指令</h3><p>ls 列出目录下的文件 ls -a 显示包括隐藏目录 ls -l 显示文件的详细信息</p><p>mkdir 创建新的目录 /文件 mkdir -p</p><pre class=" language-Linux"><code class="language-Linux">mkdir test/test01.txt -p</code></pre><p>若不存在test文件夹，会创建test文件夹后创建你test01文件</p><p>touch创建空白文件</p><pre class=" language-Linux"><code class="language-Linux">touch 01.txt</code></pre><p>rm 删除 rm -f强制删除 rm -r删除目录及其下面的子文件</p><p>pwd 查询当前位置</p><p>cd 切换目录</p><p>mv 移动文件</p><p>cp 复制文件，若要同时移动该文件下的子文件要用cp -r</p><h3 id="查看文件中内容"><a href="#查看文件中内容" class="headerlink" title="查看文件中内容"></a>查看文件中内容</h3><p>cat 查看文件内容</p><pre class=" language-Linux"><code class="language-Linux">Cat 1.txt</code></pre><p>查看1文件中的内容</p><p>more 查看大文件内容</p><pre class=" language-Linux"><code class="language-Linux">More 1.txt</code></pre><p>当1为大文件时，可以用more查看，more支持分页查看（space切换下一页，b返回上一页）</p><p>tail 查看追加内容， 其中tail -f可以查看实时更新的结果（ctrl+c结束）<br>可以同时开两个窗口，在第一个窗口输入</p><pre class=" language-Linux"><code class="language-Linux">tail 1.txt</code></pre><p>在第二各窗口输入</p><pre class=" language-Linux"><code class="language-Linux">date >> 1.txt</code></pre><p>查看1文件中新追加的内容(当下时间)</p><p>echo 追加新的内容<br>echo a &gt; 1.txt  直接覆盖于<br>Echo a &gt;&gt; 1.txt 将a插入1.txt 文件的末端<br>echo a会直接将结果打印到控制台上</p><p>Date &gt;&gt; 1.txt 将当前时间插入文件中 date本身用于时间chakan</p><p>Cal 查看日历 cal &gt;&gt; 1.txt 将日历添加到1.txt中</p><h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>将一个命令的执行的结果作为内容提交给下一个命令处理， 类似嵌套</p><pre class=" language-Linux"><code class="language-Linux">    ps -ef | grep 1001</code></pre><h3 id="文件与进程交互命令"><a href="#文件与进程交互命令" class="headerlink" title="文件与进程交互命令"></a>文件与进程交互命令</h3><p>grep 搜索<br>tar 解压</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON配置</title>
      <link href="/2022/01/14/json-pei-zhi/"/>
      <url>/2022/01/14/json-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-项目中以来的配置"><a href="#Maven-项目中以来的配置" class="headerlink" title="Maven 项目中以来的配置"></a>Maven 项目中以来的配置</h2><p>在maven项目中的pom.xml<br>该项目有<br><groupid>com.example</groupid>  //一般是公司名<br><artifactid>project</artifactid>  //一般是项目名<br><version>1.0</version>  </p><p>如果要配置依赖，需要在所有依赖外面先加dependencies，如</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>jdk15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>若配置了依赖，maven install时仍然报错，勾选settings-&gt;buid,execution,deployment中buol tolls下的maven下的runner，勾选嘴上的delegate IDE build/run action to Maven</p><p><img src="/img/posts/config/trust_maven.jpg" alt="Delegate IDE build/run action to Maven"></p><p>记得配置maven的setting file和repository</p><h2 id="配置JSON"><a href="#配置JSON" class="headerlink" title="配置JSON"></a>配置JSON</h2><p>在maven项目中的pom文件中先配置相关依赖</p><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后到java程序中</p><pre class=" language-JAVA"><code class="language-JAVA">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协同过滤推荐算法</title>
      <link href="/2021/12/01/xie-tong-guo-lu-tui-jian-suan-fa/"/>
      <url>/2021/12/01/xie-tong-guo-lu-tui-jian-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>协同过滤(collaborative filtering)算法</p><h2 id="基于内容的推荐系统"><a href="#基于内容的推荐系统" class="headerlink" title="基于内容的推荐系统"></a>基于内容的推荐系统</h2><p><img src="/img/posts/MachineLearning/recommend_system0.jpg" alt="4人对于5门电影的打分表，x1,x2表示电影的特征"></p><p>把每个用户的评分看作一个线性回归问题，对用户评分进行预测，不同的用户与不同的参数$\theta$相关</p><h2 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h2><ul><li>特征学习：可以自动学习所要使用的特征</li></ul><p>用户有一定的特征变量，并且已知用户对部分商品的兴趣</p><p>仍然是这个例子</p><p><img src="/img/posts/MachineLearning/recommend_system1.jpg" alt="现在不知道x1，x2的倾向"></p><p>但是已知用户对于romance和action电影的喜爱度，$\theta^{(1)}$是Alice的特征，由此可知她对于romance电影的喜爱度为5，action的喜爱程度为0，$\theta^{(3)}$是Carol的特征，由此可知她对于romance电影的喜爱度为0，action的喜爱程度为5。</p><p><img src="/img/posts/MachineLearning/recommend_system2.jpg" alt="用户特征"></p><p>由此我们得出，需要满足以下条件：<br>$$(\theta^{(1)})x^{(1)} = 5$$<br>$$(\theta^{(2)})x^{(1)} = 5$$<br>$$(\theta^{(3)})x^{(1)} = 0$$<br>$$(\theta^{(4)})x^{(1)} = 0$$</p><p>所以<br>$$ x^{(1)}  =  \begin{bmatrix}1 &amp; 1.0 &amp; 0.0 \end{bmatrix}$$<br>第一项是截距项</p><h3 id="算法推导过程"><a href="#算法推导过程" class="headerlink" title="算法推导过程"></a>算法推导过程</h3><p>如果用户已经给了我们偏好–特征$\theta^{(1)}$,$\theta^{(2)}$…$\theta^{(n)}$对$x^{(i)}$进行学习，我们要做的是求出：</p><p>$$\min \frac{1}{2} \displaystyle \sum_{j:r(i,j)=1}({(\theta^{(j)})}^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)})^2$$</p><p>这一步要做的是选择一个特征$x^{(i)}$，算法根据所有评价过电影的用户计算出一个值来预测某个用户会如何评价这部电影<br>$\frac {\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)}$是一个正则项，防止特征值过大</p><p>为了学习所有电影的所有特征，也就是学习$x^{(1)},x^{(2)}…x^{(n_m)}$\，需要求出<br><img src="/img/posts/MachineLearning/recommend_system_equation.jpg"></p><p>$\displaystyle \sum_{i=1}^{n_m}$是对所有电影求和</p><h3 id="算法作用"><a href="#算法作用" class="headerlink" title="算法作用"></a>算法作用</h3><ul><li><p>可以通过用户喜爱程度$\theta^{(1)},\theta^{(2)}…\theta^{(n_u)}$来预测电影的特征$x^{(1)}…x^{(n_m)}$</p></li><li><p>也可以通过电影特征$x^{(1)}…x^{(n_m)}$来预测用户喜爱程度$\theta^{(1)},\theta^{(2)}…\theta^{(n_u)}$</p></li></ul><p>可以通过先随机地选取一些$\theta$地值来学习出不同电影地特征，在得到电影特征之后，再通过这些特征来预测另外的$\theta$值（用户喜爱程度，再根据这些$\theta$来预测电影特征…如此反复，最终将会收敛到一组合理的电影特征以及合理的对用户地预测</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>将$x^{(1)},x^{(2)}…x^{(n_m)}$,$\theta^{(1)},\theta^{(2)}…\theta{(n_u)}$初始化为一些小地随机出</p></li><li><p>使用梯度下降将代价函数最小化，</p></li></ol><p><img src="/img/posts/MachineLearning/recommend_system3.jpg" alt="括号内的内容是对代价函数地偏导"></p><ol start="3"><li>用一些有参数$\theta$的用户和有特征$x$的电影，来预测用户评分$\theta^Tx$</li></ol><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><p>用户对电影评分可以写成如图所示评分矩阵<br><img src="/img/posts/MachineLearning/recommend_system4.jpg"></p><p>该评分矩阵的实质是$\theta^{(j)}*x^{(i)}$</p><p><img src="/img/posts/MachineLearning/recommend_system5.jpg"></p><p>如果要给用户推荐相似的电影，可以通过两个电影之间的距离来判断，如果电影$x^{(i)}$与$x^{(j)}$非常相近，那么可以把$x^{(j)}$推荐给喜欢$x^{(i)}$的人</p><h2 id="协同过滤算法中的均值归一化"><a href="#协同过滤算法中的均值归一化" class="headerlink" title="协同过滤算法中的均值归一化"></a>协同过滤算法中的均值归一化</h2><p>对于没有看过电影的人，或者那些给所有电影都打分为零分的人，很难推荐电影给他们。可以通过已知用户对于电影的打分，计算出该电影的均分，最后生成均分矩阵<br>$$\mu = \begin {bmatrix} \mu_1 &amp; \mu_2 &amp; …&amp; \mu_n \end {bmatrix} $$</p><p><img src="/img/posts/MachineLearning/recommend_system6.jpg" alt="5个电影的评分矩阵如图，但不知道最后一个人对于每个电影的打分"></p><p><img src="/img/posts/MachineLearning/recommend_system7.jpg" alt="通过计算均值，得到了每个电影的均分矩阵"></p><p><img src="/img/posts/MachineLearning/recommend_system8.jpg" alt="原评分矩阵中的元素减去对应的均值后，德奥新的评分矩阵"></p><p>将均一化后的矩阵作为额数据集进行$\theta^{(j)}$参数的学习，预测函数为：<br>$${(\theta^{(j)})}^T{(X^{(i)})}+\mu_i$$</p><p>对于没有打分的用户5<br>$$\theta^{(5)} = \begin {bmatrix}0 &amp; 0 \end {bmatrix}$$</p><p>最终用户5的打分为 $\mu_i$</p><p><strong>可用于解决用户冷启动问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 协同过滤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python实现的PING功能</title>
      <link href="/2021/11/28/ji-yu-python-shi-xian-de-ping-gong-neng/"/>
      <url>/2021/11/28/ji-yu-python-shi-xian-de-ping-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是PING"><a href="#什么是PING" class="headerlink" title="什么是PING"></a>什么是PING</h2><p>ping通常用于测试网络连通，再命令行输入ping 目标主机地址， 得到回复如下：</p><p><img src="/img/posts/Ping/ping_cmd.jpg" alt="ping"></p><p>其中的数据内容如下：</p><p>bytes值：字节数，也就是数据包大小。</p><p>time值：响应时间，这个时间越小，说明连接速度越快。</p><p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p><p>默认情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255。</p><p>因此一般TTL值：</p><p>100~130ms之间，Windows系统 ；</p><p>240~255ms之间，UNIX/Linux系统。</p><h2 id="ping的步骤"><a href="#ping的步骤" class="headerlink" title="ping的步骤"></a>ping的步骤</h2><p>完整代码见：<a href="https://github.com/ClaireYuj/PING-Traceroute/blob/main/ICMPPing.py">PING</a></p><p>解析主机并，进行多次ping操作，输出结果，判断最终结果并输出四个步骤<br>ping的代码如下</p><pre class=" language-Python"><code class="language-Python">def ping(host, timeout=1):    """    do the ping use doOnePing method in a while loop, and show the details    :param host:    :param timeout:    :return:    """    # 1. Look up hostname, resolving it to an IP address    # 2. Call doOnePing function, approximately every second    # 3. Print out the returned delay    # 4. Continue this process until stopped    try:        destinationAddress = socket.gethostbyname(host)    except Exception as e:        print(e)        print(" Error on extract the hostname")        return    print(" Ping {0} [{1}] with 32 bytes of data:".format(host, destinationAddress))    lost = 0    accept = 0    timesum = 0.0    count = 4    times = []    ttl = 0    for i in range(count):        sequence = i        delay, ttl = doOnePing(destinationAddress, timeout)        if delay < 0:            if delay == -1:                print(" %s The request is overtime ...... can not receive the icmpPacket " % delay)                lost += 1                times.append(delay * 1000)            elif delay == -3:                print("3 The destination is unreachable")            elif delay == -11:                print("11 Overtime")            else:                print("%s failed......." %delay)        else:            delay = delay * 1000            print("reply from {0} : byte=32 seq = {1} time={2:.2f}ms ttl = {3} ".format(destinationAddress, sequence, delay, ttl))            accept += 1            timesum += delay            times.append(delay) # all the time        time.sleep(1)    print('packet: send = {0}，received = {1}，loss= {2} ({3}% loss) \n\    Estimated round trip time: min = {4:.2f}ms，max = {5:.2f}ms，average = {6:.2f}ms'.format(        count, accept, lost, lost / (lost + accept) * 100, min(times),        max(times), sum(times) // (lost + accept)    ))</code></pre><h3 id="进行一次ping"><a href="#进行一次ping" class="headerlink" title="进行一次ping"></a>进行一次ping</h3><p>ping命令共输出四次ping的结果，其中一次ping的结果如下</p><pre class=" language-Python"><code class="language-Python">def doOnePing(destinationAddress, timeout):    """    create the ICMP socket, then call the sendOnePing and receiveOnePing method in sequence    :param destinationAddress:    :param timeout:    :return totalDelay, ttl:    """    # 1. Create ICMP socket    icmpSocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.getprotobyname("icmp"))    dataID = os.getpid() & 0xFFFF    # 2. Call sendOnePing function    icmpPacket, sendtime = sendOnePing(icmpSocket, destinationAddress, dataID)    # 3. Call receiveOnePing function    totalDelay, ttl = receiveOnePing(icmpSocket, destinationAddress, dataID, timeout, sendtime)    # 4. Close ICMP socket    icmpSocket.close()    # 5. Return total network delay    return totalDelay, </code></pre><h3 id="发出ping请求"><a href="#发出ping请求" class="headerlink" title="发出ping请求"></a>发出ping请求</h3><p>每次ping需要发出请求以及接收请求两个步骤</p><pre class=" language-Python"><code class="language-Python">  """    build the icmp header, and pack the checksum in header    record the time to send packet    :param icmpSocket:    :param destinationAddress:    :param ID:    :return icmpPacket, sendTime:    """def sendOnePing(icmpSocket, destinationAddress, ID):      # 1. Build ICMP header    ip = socket.gethostbyname(destinationAddress)    icmpChecksum = 0    icmpHeader = struct.pack(">BBHHH", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1) #htons - trans the byte sequence of host nto network byte order    # 2. Checksum ICMP packet using given function    data = struct.pack(">d", time.time())    icmpChecksum = checksum(icmpHeader + data)    # 3. Insert checksum into packet    # icmpHeader = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1)    icmpHeader = struct.pack(">BBHHH", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1) # B-unsigned char h -short    icmpPacket = icmpHeader + data    # 4. Send packet using socket    icmpSocket.sendto(icmpPacket, (ip, 80))    #  5. Record time of sending    sendTime = time.time()    return icmpPacket, sendTime</code></pre><p>checksum是checksum意思是较验和，就是将一段已有长度的数据按照某种整数类型(通常是16位无符号整数)进行累加(进位部分再继续加到低位)，累加后的结果再取反以用于校验。具有校验合的数据包再次进行校验后结果则为0。</p><pre class=" language-Python"><code class="language-Python">def checksum(string):    csum = 0    countTo = (len(string) // 2) * 2    count = 0    while count < countTo:        thisVal = string[count + 1] * 256 + string[count]        csum = csum + thisVal        csum = csum & 0xffffffff        count = count + 2    if countTo < len(string):        csum = csum + string[len(string) - 1]        csum = csum & 0xffffffff    csum = (csum >> 16) + (csum & 0xffff)    csum = csum + (csum >> 16)    answer = ~csum    answer = answer & 0xffff    answer = answer >> 8 | (answer << 8 & 0xff00)    answer = socket.htons(answer)    return answer</code></pre><h3 id="接收ping请求"><a href="#接收ping请求" class="headerlink" title="接收ping请求"></a>接收ping请求</h3><pre class=" language-Python"><code class="language-Python">"""    wait the socket to receive the reply by select.select, calculate the time to receive the packet    :param icmpSocket:    :param destinationAddress:    :param ID:    :param timeout:    :param startTime:    :return delay, ttl:    """def receiveOnePing(icmpSocket, destinationAddress, ID, timeout, startTime):        # 1. Wait for the socket to receive a reply    while True:        what_ready = select.select([icmpSocket], [], [], timeout)        receivedTime = time.time()        # 2. Once received, record time of receipt, otherwise, handle a timeout        if what_ready[0] == []:            return -1, 0        # 3. Compare the time of receipt to time of sending, producing the total network delay        else:            delay = receivedTime - startTime        # 4. Unpack the packet header for useful information, including the ID        recPacket, addr = icmpSocket.recvfrom(1024)        icmpHeader = recPacket[20: 28]        # ip_type, code, checksum, packet_ID, sequence = struct.unpack("<bbHHh", icmpHeader)        icmpType, icmpCode, icmpChecksum, icmpPacketID, icmpSequence = struct.unpack(">BBHHH", icmpHeader)        ipversion, iptype, iplength, ipid, ipflags, ipttl, ipprotocol, ipchecksum, ipsrc_ip, ipdest_ip = struct.unpack(            "!BBHHHBBHII", recPacket[:20])        # 5. Check that the ID matches between the request and reply        if icmpType == ICMP_ECHO_REPLY and icmpPacketID == ID:            # 6. Return total network delay            return delay, ipttl        elif icmpType == ICMP_UNREACHED:            return -3, 0        elif icmpType == ICMP_OVERTIME:            return -11, 0        else:            return -2, 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Idea的SpringBoot项目搭建</title>
      <link href="/2021/11/17/ji-yu-idea-de-springboot-xiang-mu-da-jian/"/>
      <url>/2021/11/17/ji-yu-idea-de-springboot-xiang-mu-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Spring-Boot-Helper插件"><a href="#安装Spring-Boot-Helper插件" class="headerlink" title="安装Spring Boot Helper插件"></a>安装Spring Boot Helper插件</h2><p>File &gt; Settings &gt; Plugins &gt;</p><p>安装好之后File &gt; new &gt; Spring Initializr &gt; 此时注意到选择初始化服务器的defalut那有一个start.spring.io<br>File &gt; Appearance $ Beahavior &gt; System Settings &gt;HTTP Proxy &gt; 选择 Auto-detect后点击左下角的check connection按钮，输入<a href="http://start.spring.io/">http://start.spring.io</a></p><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>版本选择 2.2.6.RELEASE<br>包的名字记得改</p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p>File &gt; Buil, Execution, Deployment &lt; Build Tools &gt; Maven 配置maven的setting.xml于repository， 在maven的安装路径下conf文件夹中找到settings.xml，再在maven根目录新建repository文件夹，并在 setting.xml 文件中添加（找到repository注释下一行，进行添加）</p><pre class=" language-XML"><code class="language-XML">    <localRepository>        D:\Environment\Maven\apache-maven-3.2.5\store        </localRepository></code></pre><p>此处地址为自己创建的repository的地址</p><p>再找到mirror<br>将原代码更换为</p><pre class=" language-XML"><code class="language-XML">    <mirror>        <id>alimaven</id>        <name>aliyun maven</name>        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>        <mirrorOf>central</mirrorOf>               </mirror> </code></pre><p>再重新生成maven项目，拉开idea右侧maven栏，点击左上角刷新按钮</p><h3 id="报错java-程序包org-springframework-boot不存在"><a href="#报错java-程序包org-springframework-boot不存在" class="headerlink" title="报错java: 程序包org.springframework.boot不存在"></a>报错java: 程序包org.springframework.boot不存在</h3><p>是依赖库仓库出现问题，cd到该项目目录下，mvn idea:idea 重新安装依赖即可</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA输入输出</title>
      <link href="/2021/11/17/java-shu-ru-shu-chu/"/>
      <url>/2021/11/17/java-shu-ru-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-I-x2F-O"><a href="#JAVA-I-x2F-O" class="headerlink" title="JAVA I/O"></a>JAVA I/O</h1><p>在Java程序中要读取外部IO设备中的内容，要求先将数据传输到内存中，这一步需要借助操作系统实现。<br>JDK中提供的IO操作框架，根据流的传输方向和读取单位分为字节流InputStream和outputSteam以及字符流Reader和Writer</p><p>字节流一次<strong>读取一个字节</strong>（1 byte）<br>字符流一次<strong>读取一个字符</strong>（1 char =  2 byte）</p><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><p>头文件</p><pre class=" language-Java"><code class="language-Java">import java.io.FileInputStream;import java.io.FileNotFoundException;</code></pre><h3 id="创建输入流"><a href="#创建输入流" class="headerlink" title="创建输入流"></a>创建输入流</h3><pre class=" language-Java"><code class="language-Java">try{    FileInputStream inputStream = new FileInputStream("test.txt"); }catch(FileNotFoundException e){    e.printStackTrace();}</code></pre><p>在使用完成后，要关闭流进行资源释放，在catch后加入finally</p><pre class=" language-Java"><code class="language-Java">        FileInputStream inputStream = null;        try{            inputStream = new FileInputStream("test.txt");        }catch (FileNotFoundException e){            e.printStackTrace();        }finally {            try{                if(inputStream !=null) inputStream.close();            }catch (IOException e){                e.printStackTrace();            }        }</code></pre><p><strong>但这样过于繁琐，尝试以下面方式进行简化</strong></p><pre class=" language-Java"><code class="language-Java">    try(FileInputStream inputStream  = new FileInputStream("test.txt")){                }catch (FileNotFoundException e){            e.printStackTrace();    }</code></pre><p>将inputStream的初始化放到的括号中且不报错，原因是InputStream这个抽象类使用了Closeable的接口<br>而Closeable接口继承了AutoCloseable，如果一个对象是在try-with-resource(在JDK7中引入，JDK9中改进)代码块中生命的，则AutoCloseable的对象的close()方法会自动执行<br>字节流，字符流等都可以直接使用</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>inputStream.read() 一次读取一个英文字母（读的是ASCII码，需要char转换）</p><p>一次性全部读完</p><pre class=" language-Java"><code class="language-Java">try( FileInputStream inputStream = new FileInputStream("test.txt")){            int tmp;            while((tmp = inputStream.read()) != -1){                System.out.println((char)tmp);            }        }catch (IOException e){            e.printStackTrace();        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口协议</title>
      <link href="/2021/11/11/hua-dong-chuang-kou-xie-yi/"/>
      <url>/2021/11/11/hua-dong-chuang-kou-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><ul><li><p>是<strong>TCP协议</strong>的一种，用于数据传输时的流量控制，避免拥塞的发送。  </p></li><li><p>滑动窗口协议允许发送方在在收到确认之前发送多个数据分组，因此<strong>发送方不必没收到一个分组就停下来等待确认</strong>，因此该协议可以加速数据的传输，提高网络吞吐量。</p></li><li><p>如果多个客户端向服务器发送到大量数据包，但服务器没有足够的接收这么多数据包的能力，那么会导致拥塞的发生。因此我们需要控制发送方的发送速度，控制它不要发送过快。</p></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><p>窗口：允许使用的序列号范围</p><ul><li>窗口尺寸： 若窗口尺寸为n，意味着最多有n个等待确认的消息</li></ul></li><li><p>滑动窗口： 随着协议的运行，窗口在序列号范围内向前移动  </p></li><li><p>滑动窗口协议： GBN，SR</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据传输 </tag>
            
            <tag> 流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode--树相关</title>
      <link href="/2021/10/17/leetcode-shu-xiang-guan/"/>
      <url>/2021/10/17/leetcode-shu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="树的特征"><a href="#树的特征" class="headerlink" title="树的特征"></a>树的特征</h2><p>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一颗树。图的生成树森林是它的所有连通子图的生成树的集合。</p><p>有多个子节点，层层递归（一般是二叉树）<br>二叉树的定义如下</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> val<span class="token punctuation">;</span>     TreeNode left<span class="token punctuation">;</span>     TreeNode right<span class="token punctuation">;</span>     <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="剑指Offer25-树的子结构"><a href="#剑指Offer25-树的子结构" class="headerlink" title="剑指Offer25. 树的子结构"></a>剑指Offer25. 树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br><img src="/img/posts/Leetcode/offer26.jpg"><br>前序遍历，从A树和B树相同的结点开始，B树的左子树 = A树的左子树；A树的右子树 = B树的右子树<br>结束条件==》B树符合A树左子树条件||A树 = null</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>TreeNode A<span class="token punctuation">,</span> TreeNode B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token operator">==</span>null<span class="token operator">||</span>B<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从该节点开始遍历||判断从A的左节点开始遍历，B是不是A的左子树的子结构|| 判断B是不是A的右子树的子结构</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode A<span class="token punctuation">,</span> TreeNode B<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>B <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示在B为null前A与B 的val一直相等</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>A <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> B <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>val <span class="token operator">!=</span> B<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span> B<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">travel</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span> B<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分辨遍历左右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Offer27-二叉树的镜像"><a href="#Offer27-二叉树的镜像" class="headerlink" title="Offer27.二叉树的镜像"></a>Offer27.二叉树的镜像</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">请完成一个函数，输入一个二叉树，该函数输出它的镜像</a><br><img src="/img/posts/Leetcode/offer27.jpg"></p><ul><li>思路： 从根的叶结点开始， 一个一个交换左右子树，一直到为null</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Offer28-对称的二叉树"><a href="#Offer28-对称的二叉树" class="headerlink" title="Offer28.对称的二叉树"></a>Offer28.对称的二叉树</h2><p><img src="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d412v/"><br>依旧是递归，不过考虑到判断对称，要求：<br>左子树的左子树等于右子树的右子树，右子树的左子树=左子树的右子树，依次递归</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        TreeNode left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        TreeNode right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>right<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>right<span class="token punctuation">.</span>val<span class="token operator">==</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode left<span class="token punctuation">,</span> TreeNode right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>null<span class="token operator">&amp;&amp;</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>right<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>left<span class="token punctuation">.</span>val<span class="token operator">!=</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>null<span class="token operator">||</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">travel</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>left<span class="token punctuation">,</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p><img src="/img/posts/Leetcode/leetcode94.jpg" alt="Leetcode94"></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>中序遍历 左-&gt;中-右</p><pre class=" language-jAVA"><code class="language-jAVA">class Solution {    public List<Integer> inorderTraversal(TreeNode root) {        List<Integer> tree = new ArrayList<Integer>();        inOrder(root,tree);        return tree;            }    public void inOrder(TreeNode root,List<Integer> tree){        if(root==null){            return;        }        inOrder(root.left,tree);        tree.add(root.val);        inOrder(root.right,tree);    }}</code></pre><h2 id="Offer22-广度优先算法"><a href="#Offer22-广度优先算法" class="headerlink" title="Offer22. 广度优先算法"></a>Offer22. 广度优先算法</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9ackoe/">从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> Definition <span class="token keyword">for</span> a binary tree node<span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span> <span class="token operator">*</span>     <span class="token keyword">int</span> val<span class="token punctuation">;</span> <span class="token operator">*</span>     TreeNode left<span class="token punctuation">;</span> <span class="token operator">*</span>     TreeNode right<span class="token punctuation">;</span> <span class="token operator">*</span>     <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">*</span> <span class="token punctuation">}</span> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">bfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 广度优先要用queue</span>        <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用来确定int[] arr的大小</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先将root入队列</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode treeNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将根节点出列</span>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 两个if实现了广度有限中将同层次的叶节点加入队列</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="95-不同的二叉搜索树"><a href="#95-不同的二叉搜索树" class="headerlink" title="95.不同的二叉搜索树"></a>95.不同的二叉搜索树</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br>（不只返回数字）</p><h3 id="解法一-DFS-深度优先"><a href="#解法一-DFS-深度优先" class="headerlink" title="解法一:DFS 深度优先"></a>解法一:DFS 深度优先</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h3 id="解法二：DP-动态规划"><a href="#解法二：DP-动态规划" class="headerlink" title="解法二：DP 动态规划"></a>解法二：DP 动态规划</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int numTrees(int n) {        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;                for(int i = 2; i < n + 1; i++)            for(int j = 1; j < i + 1; j++)                 dp[i] += dp[j-1] * dp[i-j];                return dp[n];    }}</code></pre><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    //判断无向图是否有换，以及是否为单连通分量    //当只有n-1条边，且连通数为1时，符合条件    public boolean validTree(int n, int[][] edges) {        if(edges.length+1 != n) //只应该有n-1条边            return false;        int[] par = new int[n];        int par1 = 0,par2 = 0;        for(int i=0;i<n;i++)            par[i]=i; //并查集，每个点的父节点是自己        for(int i=0;i<edges.length;i++){            par1 = edges[i][0];            par2 = edges[i][1];            //不断向上寻找得到par1和par2的祖先节点            while(par1 != par[par1])                par1 = par[par1];             while(par2 != par[par2])                par2 = par[par2];            //par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--            if(par1 != par2){                par[par2] = par1;                n--;            }        }        return n == 1;            }}</code></pre><h2 id="515-在二叉树的每一行中找到最大的值。"><a href="#515-在二叉树的每一行中找到最大的值。" class="headerlink" title="515. 在二叉树的每一行中找到最大的值。"></a>515. 在二叉树的每一行中找到最大的值。</h2><h3 id="解法：BFS-广度优先"><a href="#解法：BFS-广度优先" class="headerlink" title="解法：BFS 广度优先"></a>解法：BFS 广度优先</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List<Integer> largestValues(TreeNode root) {        List<Integer> rlist = new ArrayList<>();        if(root==null) return rlist;                List<TreeNode> nodeList = new LinkedList<>();        nodeList.add(root);        while(!nodeList.isEmpty()){            int size = nodeList.size();            int max = nodeList.get(0).val;            for(int i = 0;i< size;i++){                TreeNode node = nodeList.remove(0);                max = Math.max(node.val,max);                if(node.left!=null) nodeList.add(node.left);                if(node.right!=null) nodeList.add(node.right);            }            rlist.add(max);        }        return rlist;            }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA常见容器</title>
      <link href="/2021/10/14/java-chang-jian-rong-qi/"/>
      <url>/2021/10/14/java-chang-jian-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterable被Collection所继承。它只有一个方法： Iterator<t> iterator() </t></p><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为<strong>“轻量级”</strong>对象，因为创建它的代价小。</p><p>Java中的Iterator功能比较简单，并且只能单向移动：<br>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br>　　(2) 使用next()获得序列中的下一个元素。<br>　　(3) 使用hasNext()检查序列中是否还有元素。<br>　　(4) 使用remove()将迭代器新返回的元素删除。</p><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>一般不会直接实现collection接口，而是实现它的子类</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><em><strong>有序的，可重复的</strong></em><br>List是有序的 collection子接口。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>用户插入的顺序或者指定的位置就是元素插入的位置。它与Set不同，List允许插入重复的值。</p><p>List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法(如下)来获取从列表中指定位置开始的列表迭代器。</p><p>ListIterator <e> listIterator(int index)<br>返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始</e></p><p>List 接口提供了两种搜索指定对象的方法。从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。</p><p>List 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><em><strong>无序的，不可重复的</strong></em></p><p>java的集合和数学的集合一样，集合的无序性，确定性，单一性。所以可以很好的理解，Set是无序、不可重复的。同时，如果有多个null，则不满足单一性了，Set只能有一个null。<br>Set判断两个对象相同不是使用”==”运算符，<strong>而是根据equals方法</strong>。——因为Set的这个制约，在使用Set集合的时候，应该注意两点：<br>为Set集合里的元素的实现类实现一个有效的equals(Object)方法；<br>对Set的构造函数，传入的Collection参数不能包含重复的元素。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><em><strong>有序的，可重复的</strong></em><br>用于模拟“队列”数据结构（FIFO）。新插入的元素放在队尾，队头存放着保存时间最长的元素。</p><p>Queue的子类、子接口<br>1.1） PriorityQueue—— 优先队列（类）<br>其实它并没有按照插入的顺序来存放元素，而是按照队列中某个属性的大小来排列的。故而叫优先队列。</p><p>1.2） Deque——双端队列（接口）<br>1.2.1）ArrayDeque（类）<br>基于数组的双端队列，类似于ArrayList有一个Object[] 数组。<br>1.2.2）LinkedList （类）</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map不是collection的子接口或者实现类，Map是一个接口。</p><p>Map用于保存具有“映射关系”的数据。每个Entry都持有<strong>键-值</strong>两个对象。其中，Value可能重复，但是Key不允许重复（和Set类似）。</p><p>Map可以有多个Value为null，但是只能有一个Key为null</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在hexo的matery主题下显示数学公式</title>
      <link href="/2021/09/29/zai-hexo-de-matery-zhu-ti-xia-xian-shi-shu-xue-gong-shi/"/>
      <url>/2021/09/29/zai-hexo-de-matery-zhu-ti-xia-xian-shi-shu-xue-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>Markdown中激活mathjax插件，并使用数学公式，如矩阵与各种数学符号</p><h2 id="激活mathjax插件"><a href="#激活mathjax插件" class="headerlink" title="激活mathjax插件"></a>激活mathjax插件</h2><p>主题config.yml文件里找到mathjax,改为true<br>由于mathjax的渲染时间较长，故勾选全局mathjax为true后还需要在每篇文章的最上方输入mathjax:true</p><p>此时就可以输入数学公式了，以矩阵为例</p><p>输入</p><pre class=" language-Latex"><code class="language-Latex">$$\begin{bmatrix}                     1&1&0\\                                     1&0&1\\        \end{bmatrix}$$</code></pre><p>以$$\begin开始,以\end{}$$结束<br>但由于matery主题的限制，矩阵不会换行，因此考虑使用markdown it Plus代替Marked渲染器</p><h2 id="利用Katex"><a href="#利用Katex" class="headerlink" title="利用Katex"></a>利用Katex</h2><pre class=" language-shell"><code class="language-shell">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save</code></pre><p>卸载marked，安装markdown-it-plus</p><pre class=" language-shell"><code class="language-shell">npm un hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save</code></pre><p>也可以考虑吧直接用升级版</p><p>再修改hexo的config.yml文件</p><pre class=" language-yml"><code class="language-yml">markdown_it_plus:  render:    html: true    xhtmlOut: false    breaks: true    linkify: true    typographer: true    quotes: '“”‘’'  plugins:  anchors:    level: 2    collisionSuffix: 'v'    permalink: true    permalinkClass: header-anchor    permalinkSide: 'left'    permalinkSymbol: ¶</code></pre><p>就完成了配置<br>可以用</p><pre class=" language-Latex"><code class="language-Latex">$$\begin{bmatrix}                     1&1&0\\                                     1&0&1\\        \end{bmatrix}$$</code></pre><p>再测试一下，此时的matrix会分行了</p><h2 id="Markdown数学公式的使用"><a href="#Markdown数学公式的使用" class="headerlink" title="Markdown数学公式的使用"></a>Markdown数学公式的使用</h2><h3 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{equation}公式\\公式\\\end{equation}$$</code></pre><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p><strong>^</strong>表示上标，**_<strong>表示下标，需要用</strong>{}** </p><pre class=" language-Latex"><code class="language-Latex">$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</code></pre><p>结果<br><img src="/img/posts/Markdown/index.jpg" alt="结果"></p><h3 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{matrix}0&1&1\\1&1&0\\1&0&1\\\end{matrix}$$</code></pre><p><img src="/img/posts/Markdown/matrix0.jpg" alt="矩阵表示"></p><p>在起始、结束标记用下列词替换 matrix</p><ul><li>pmatrix：小括号边框</li><li>bmatrix：中括号边框</li><li>Bmatrix：大括号边框</li><li>vmatrix：单竖线边框</li><li>Vmatrix：双竖线边框</li></ul><p><img src="/img/posts/Markdown/matrix1.jpg" alt="边框矩阵表示"></p><h3 id="方程组表示"><a href="#方程组表示" class="headerlink" title="方程组表示"></a>方程组表示</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{cases}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\\\end{cases}$$</code></pre><p><img src="/img/posts/Markdown/equation0.jpg" alt="方程组表示"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-栈相关</title>
      <link href="/2021/09/09/leetcode-zhan-xiang-guan/"/>
      <url>/2021/09/09/leetcode-zhan-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>栈在JAVA中，可以用LinkedList来表示</p><p>LinkedList<integer> A = new LinkedList<integer>(); </integer></integer></p><ul><li>栈中加入元素<br>  A.add(a);</li><li>栈中移除元素<br>  A.removeLast();</li></ul><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d3i87/">https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d3i87/</a></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )</p><p><img src="/img/posts/Leetcode/offer09.jpg" alt="剑指offer09"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */</span><span class="token keyword">class</span> <span class="token class-name">CQueue</span> <span class="token punctuation">{</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> A<span class="token punctuation">;</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> B<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        B <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">appendTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        A<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>B<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> B<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            B<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> B<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-链表相关</title>
      <link href="/2021/08/28/leetcode-lian-biao-xiang-guan/"/>
      <url>/2021/08/28/leetcode-lian-biao-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9pdjbm/">剑指Offer24.反转链表</a></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>如：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h3 id="解法一，头插：用一个节点暂存"><a href="#解法一，头插：用一个节点暂存" class="headerlink" title="解法一，头插：用一个节点暂存"></a>解法一，头插：用一个节点暂存</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode reve <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode tmp <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp<span class="token punctuation">.</span>next <span class="token operator">=</span> reve<span class="token punctuation">;</span>            reve <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> reve<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListNode <span class="token function">recur</span><span class="token punctuation">(</span>ListNode cur<span class="token punctuation">,</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//递归终止条件，所以最后返回的是cur</span>        ListNode res <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="赋值带随机指针的链表"><a href="#赋值带随机指针的链表" class="headerlink" title="赋值带随机指针的链表"></a>赋值带随机指针的链表</h2><p><img src="/img/posts/Leetcode/leetcode138.jpg" alt="Leetcode138"></p><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9plk45/">解法</a></p><h3 id="解法一：拼接-拆分"><a href="#解法一：拼接-拆分" class="headerlink" title="解法一：拼接+拆分"></a>解法一：拼接+拆分</h3><p>将原链表假设为1-&gt;2-&gt;3复制<br>1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null<br>这样cur-&gt;random-&gt;next = cur-&gt;next-&gt;random<br>比如如果1-&gt;random = 3,那么1-&gt;random = 3, 3-&gt;next = 3 ===&gt;1-&gt;random-&gt;next = 3, 且1-&gt;next = 1, 1-&gt;random = 3 ===&gt; 1-&gt;next-&gt;random = 3, 所以cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*// Definition for a Node.class Node {    int val;    Node next;    Node random;    public Node(int val) {        this.val = val;        this.next = null;        this.random = null;    }}*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Node <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        Node cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        Node p <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//1. 复制节点并拼接</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>             Node copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//复制该节点</span>            copy<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//连接copy节点的next</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> copy<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关联该节点与复制节点</span>            cur <span class="token operator">=</span> copy<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//移动指针</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2.构建random,使得cur->random->next = cur->next->random</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// java中对象传递是引用传递</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>random<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>random <span class="token operator">=</span> cur<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next<span class="token punctuation">;</span>              <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 3. 将random拆出来</span>        cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Node pre <span class="token operator">=</span> head<span class="token punctuation">,</span>res<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/**注意pre和cur节点的顺序， pre要在cur之前，             */</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>             cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                             <span class="token punctuation">}</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维护博客所遇到的问题汇总</title>
      <link href="/2021/08/18/wei-hu-bo-ke-suo-yu-dao-de-wen-ti-hui-zong/"/>
      <url>/2021/08/18/wei-hu-bo-ke-suo-yu-dao-de-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="链接到本地图片"><a href="#链接到本地图片" class="headerlink" title="链接到本地图片"></a>链接到本地图片</h2><p>在source下创建img文件夹，每次引用都是/img…</p><h2 id="上传图片加载不出来，但在本地预览可以显示"><a href="#上传图片加载不出来，但在本地预览可以显示" class="headerlink" title="上传图片加载不出来，但在本地预览可以显示"></a>上传图片加载不出来，但在本地预览可以显示</h2><p>图片格式最好选用jpg而不是png</p><h2 id="无法解析XML和HTML语言"><a href="#无法解析XML和HTML语言" class="headerlink" title="无法解析XML和HTML语言"></a>无法解析XML和HTML语言</h2><p>尚未完全解决，实在不行就不标明那一段是个代码段，直接放代码</p><h2 id="首页博客排序方式"><a href="#首页博客排序方式" class="headerlink" title="首页博客排序方式"></a>首页博客排序方式</h2><p>项目下（不是主题下）_config.yml中index_generate:order_by: (+/-)(title/date)<br>+表示正序排列<br>-表示倒序排列</p><h2 id="ssh相关"><a href="#ssh相关" class="headerlink" title="ssh相关"></a>ssh相关</h2><p>ssh密钥一般存在/user/.ssh/目录下<br>如果没有配置ssh密钥，可以通过</p><pre class=" language-cmd"><code class="language-cmd">cd /.ssh</code></pre><p>创建ssh key</p><pre class=" language-cmd"><code class="language-cmd">ssh-keygen -t rsa -C "邮件地址"</code></pre><p>复制console生成的密钥，把他粘贴到.ssh目录下的 id_rsa.pub</p><p>在github的ssh设置中，添加ssh key，粘贴刚刚复制的内容</p><p>通过</p><pre class=" language-cmd"><code class="language-cmd">ssh -T git@github.com</code></pre><p>检查是否配置成功，如果hexo g -d显示连接有问题，可以进bash查看一下ssh -T <a href="mailto:git@github.com">git@github.com</a></p><p>windows系统可以，连接ssh-agent</p><pre class=" language-bash"><code class="language-bash"><span class="token function">eval</span> <span class="token variable"><span class="token variable">$(</span>ssh-agent<span class="token variable">)</span></span></code></pre><p>之后在ssh-agent中添加自己的key</p><pre class=" language-bash"><code class="language-bash">ssh-add ~/.ssh/id_rsa</code></pre><h2 id="git报错-–-Connection-reset-by-server-ip-port-22"><a href="#git报错-–-Connection-reset-by-server-ip-port-22" class="headerlink" title="git报错 – Connection reset by [server_ip] port 22"></a>git报错 – Connection reset by [server_ip] port 22</h2><p>解决git报错 – Connection reset by [server_ip] port 22<br>第一种情况，自己防火墙设置了22端口跳转</p><pre><code>解决方法    打开windows防火墙，选择高级设置    新建入站规则，    选择端口    新建特定端口，22    保存就ok了</code></pre><h2 id="代码块中-被转义"><a href="#代码块中-被转义" class="headerlink" title="代码块中{}被转义"></a>代码块中{}被转义</h2><p> 在node_modules\hexo-prism-plugin\src\index.js中添加</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token string">'&amp;#39;'</span><span class="token punctuation">:</span> <span class="token string">'\''</span><span class="token punctuation">,</span>  <span class="token string">'&amp;amp;'</span><span class="token punctuation">:</span> <span class="token string">'&amp;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;gt;'</span><span class="token punctuation">:</span> <span class="token string">'>'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;lt;'</span><span class="token punctuation">:</span> <span class="token string">'&lt;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;quot;'</span><span class="token punctuation">:</span> <span class="token string">'"'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#123;'</span><span class="token punctuation">:</span> <span class="token string">'{'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#125;'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-图论</title>
      <link href="/2021/08/17/leetcode-tu-lun/"/>
      <url>/2021/08/17/leetcode-tu-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><p>定义：<strong>无向图是由一组顶点（vertex）和一组能够将两个顶点相连的边（edge）组成的</strong><br>在无向图中，允许出现1.自环，即一条连接一个顶点和其自身的边，2. 连接同一对顶点的两条边称为平行边</p><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><p><img src="/img/posts/Leetcode/leetcode261.jpg" alt="Leetcode261图示"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//判断无向图是否有换，以及是否为单连通分量</span>        <span class="token comment" spellcheck="true">//当只有n-1条边，且连通数为1时，符合条件</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只应该有n-1条边</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> par <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> par1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>par2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                par<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//并查集，每个点的父节点是自己</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                par1 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                par2 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*不断向上寻找得到par1和par2的祖先节点*/</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">)</span>                    par1 <span class="token operator">=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token keyword">while</span><span class="token punctuation">(</span>par2 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">)</span>                    par2 <span class="token operator">=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--*/</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par2<span class="token punctuation">)</span><span class="token punctuation">{</span>                    par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span> <span class="token operator">=</span> par1<span class="token punctuation">;</span>                    n<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目"><a href="#323-无向图中连通分量的数目" class="headerlink" title="323. 无向图中连通分量的数目"></a>323. 无向图中连通分量的数目</h2><p>你有一个包含&nbsp;n 个节点的图。给定一个整数 n 和一个数组&nbsp;edges&nbsp;，其中&nbsp;edges[i] = [ai, bi]&nbsp;表示图中&nbsp;ai&nbsp;和&nbsp;bi&nbsp;之间有一条边。</p><p><img src="/img/posts/Leetcode/leetcode323.jpg" alt="Leetcode323图示"></p><h3 id="c-vector容器进行DFS-深度优先"><a href="#c-vector容器进行DFS-深度优先" class="headerlink" title="c++ vector容器进行DFS 深度优先"></a>c++ vector容器进行DFS 深度优先</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    int countComponents(int n, vector<vector<int>>& edges) {        vector<int>a(n, 0);        vector<vector<int>>arr(n, a);        for (auto it : edges) {            arr[it[0]][it[1]] = 1;            arr[it[1]][it[0]] = 1;        }        int res = 0;        vector<int>mark(n, 0);        for (int i = 0; i < n; i++) {            if (mark[i] == 0) {                DFS(arr, mark, i);                res++;            }        }        return res;            }private:    void DFS(vector<vector<int>>&arr, vector<int>& mark,int b) {            mark[b] = 1;            for (int i = 0; i < arr.size(); i++) {                if (arr[i][b] == 1&&mark[i] == 0) {                    DFS(arr, mark,i);                }            }            mark[b] = 2;    }};</code></pre><h3 id="java-二维数组进行dfs"><a href="#java-二维数组进行dfs" class="headerlink" title="java 二维数组进行dfs"></a>java 二维数组进行dfs</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countComponents</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> mark<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> map<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有n个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p><img src="/img/posts/Leetcode/leetcode547.jpg" alt="Leetcode547"></p><h3 id="解法：DFS-深度优先"><a href="#解法：DFS-深度优先" class="headerlink" title="解法：DFS 深度优先"></a>解法：DFS 深度优先</h3><p>关键在于：无向图最小连通数：并查集</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> N <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>i<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> si<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>si<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求最大子集和</title>
      <link href="/2021/08/15/zui-da-zi-ji-he/"/>
      <url>/2021/08/15/zui-da-zi-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="求最大子集和"><a href="#求最大子集和" class="headerlink" title="求最大子集和"></a>求最大子集和</h2><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><h4 id="法一-暴力"><a href="#法一-暴力" class="headerlink" title="法一 暴力"></a>法一 暴力</h4><pre class=" language-c++"><code class="language-c++">class Solution {    public int numTrees(int n) {        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;                for(int i = 2; i < n + 1; i++)            for(int j = 1; j < i + 1; j++)                 dp[i] += dp[j-1] * dp[i-j];                return dp[n];    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习学习笔记1</title>
      <link href="/2021/08/05/shen-du-xue-xi-xue-xi-bi-ji-1/"/>
      <url>/2021/08/05/shen-du-xue-xi-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于深度学习"><a href="#关于深度学习" class="headerlink" title="关于深度学习"></a>关于深度学习</h2><p>深度学习是通过多层来获得更为抽象的特征表达，如果有一个n层(S1,S2,S3…Sn)的深度学习系统, 输入为I，输出是O，那么深度学习的过程可以抽象的表示为: I =&gt;S1=&gt;S2=&gt;S3=&gt;…=&gt;O，每一层的信息处理都会丢失部分信息，最后的O很难是初始的I，<strong>但是如果我们可以通过深度学习调节系统中的参数使得它的输出仍然是I那么我们就可以自动的获取输入I的一系列层次特征，即S1，S2…Sn</strong></p><p><img src="/img/posts/MachineLearning/Mindmap.jpg" alt="神经网络与深度学习结构(图片选自《神经网络与深度学习》一邱锡鹏"></p><p><a href="https://blog.csdn.net/qq_36816848/article/details/122286610?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166244950816782391845436%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166244950816782391845436&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-122286610-null-null.142%5Ev46%5Epc_rank_34_2&amp;utm_term=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&amp;spm=1018.2226.3001.4187">参考学习</a></p><h3 id="浅层学习"><a href="#浅层学习" class="headerlink" title="浅层学习"></a>浅层学习</h3><p>是只含有一层隐层节点/没有节点的浅层模型，如支持向量机、最大熵方法（逻辑回归）、多层感知机等</p><p><img src="/img/posts/MachineLearning/perceptron.jpg" alt="感知机perceptron"></p><p><img src="/img/posts/MachineLearning/simple_perceptron.jpg" alt="简单感知机"></p><p><img src="/img/posts/MachineLearning/multi_layel_perceptron.jpg" alt="多层感知机"></p><p>利用人工神经网络的反向传播算法（Back Propagation算法或者BP算法），让一个人工神经网络模型从大量训练样本中学习统计规律，从而对未知事件做预测。</p><ul><li>前向传播与反向传播：前向传播（foward propagation）作用于<strong>每一层的输入</strong>，通过逐层计算得到输出结果；反向传播（backward propagation）作用于网络的<strong>输出</strong>，通过计算<strong>梯度</strong>由<strong>深</strong>到<strong>浅</strong>更新网络参数。</li></ul><p>由于我们前向传播最终得到的结果，以分类为例，最终总是有误差的，可以通过<strong>梯度下降算法</strong>减少误差。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习的实质，是通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习更有用的特征，从而最终提升分类或预测的准确性。<strong>通过深度学习最终达到特征学习的目标</strong></p><p>在深度学习中，明确突出了特征学习的重要性，通过<strong>逐层特征变换</strong>，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。</p><h2 id="深度学习与神经网络"><a href="#深度学习与神经网络" class="headerlink" title="深度学习与神经网络"></a>深度学习与神经网络</h2><p><img src="/img/posts/MachineLearning/neutral_network.jpg" alt="神经网络的结构"></p><p><img src="/img/posts/MachineLearning/model_nw.jpg" alt="神经网络的主要模型"></p><p>深度学习采用了神经网络相似的分层结构，系统由包括输入层、隐层（多层）、输出层组成的多层网络，只有相邻层节点之间有连接，同一层以及跨层节点之间相互无连接，每一层可以看作是一个<strong>逻辑回归</strong>模型。</p><p>但DL与传统神经网络的区别在于，传统神经网络中，采用的是反向传播的方式进行，也就是采用迭代的算法来训练整个网络，随机设定初值，计算当前网络的输出，然后根据当前输出和label之间的差去改变前面各层的参数，直到收敛（整体是一个梯度下降法）。而DL整体上是一个layer-wise的训练机制。这样做的原因是因为，如果采用b反向传播的机制，对于一个深层网络（7层以上），残差传播到最前面的层已经变得太小，便会出现梯度扩散(gradient diffusion)。因此传统的BP算法不能用在深度神经网络。</p><ul><li>BP算法用于深度学习会出现的问题：</li></ul><ol><li>梯度越来越稀疏，偏差原来越小，可能出现过拟合</li><li>由于随机初始值，最终收敛到局部最小</li><li>只能通过有标签的数据集进行训练，不能学习无标签的数据集，也就是监督学习</li></ol><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/8775518">参考博客</a></p><p>如果对所有层同时训练，时间复杂度会太高；如果每次训练一层，偏差就会逐层传递。这会面临跟上面监督学习中相反的问题，会严重欠拟合（因为深度网络的神经元和参数太多了）。</p><p>简单来说分为两步：</p><p>1）首先逐层构建单层神经元，这样每次都是训练一个单层网络。</p><p>2）当所有层训练完后，使用wake-sleep算法进行调优。</p><p>Wake-Sleep算法分为醒（wake）和睡（sleep）两个部分。</p><p>1）wake阶段：认知过程，通过外界的特征和向上的权重（认知权重）产生每一层的抽象表示（结点状态），并且使用梯度下降修改层间的下行权重（生成权重）。也就是“如果现实跟我想象的不一样，改变我的权重使得我想象的东西就是这样的”。</p><p>2）sleep阶段：生成过程，通过顶层表示（醒时学得的概念）和向下权重，生成底层的状态，同时修改层间向上的权重。也就是“如果梦中的景象不是我脑中的相应概念，改变我的认知权重使得这种景象在我看来就是这个概念”。</p><h4 id="使用自下而上的非监督学习"><a href="#使用自下而上的非监督学习" class="headerlink" title="使用自下而上的非监督学习"></a>使用自下而上的非监督学习</h4><p>采用无标定数据（有标定数据也可）分层训练各层参数（可以看作无监督训练过程–也是特征学习的过程）</p><ol><li>首先用无标定数据训练第一层，训练时先学习第一层的参数，可以将这一步看作一个使得输出如输出差异化的最小神经网络的隐层</li><li>一次学习没在学习到低n层时，将低n层的输出作为第n+1层的输入来训练第n+1层，以此得到每一层的参数</li></ol><h4 id="采用自顶而下的监督学习"><a href="#采用自顶而下的监督学习" class="headerlink" title="采用自顶而下的监督学习"></a>采用自顶而下的监督学习</h4><p>通过有标签的数据去训练，将误差自顶而下传输，堆网络进行微调</p><p>基于第一步各层参数进一步微调整个模型的参数，由于DL的第一步不是随机初始化，而是通过学习输入数据的结构得到的，因而这个初值更接近全局最优，从而能够取得更好的效果；所以DL效果好很大程度上归功于第一步自下而上非监督学习中的特征学习过程。</p><h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p>超参数是在<strong>开始学习过程之前设置值的参数</strong>，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。具体来讲比如算法中的学习率、梯度下降法迭代的数量、隐藏层数目、隐藏层单元数目、激活函数都需要根据实际情况来设置，这些参数实际上控制了最后的参数和的值，所以它们被称作超参数。</p><p>因此，寻求超参数的最优值是十分重要的，常见的设置超参数的方法有</p><ol><li>随机搜索：让计算机随机挑选以阻止</li><li>贝叶斯优化：使用贝叶斯优化超参数，但贝叶斯算法本身就有很多困难。</li><li>MITIE方法：先进性局部优化，利于寻找局部最优解。</li></ol><p><strong>超参数搜索的一般过程是</strong></p><ol><li>将数据集划分成训练集、验证集及测试集。</li><li>在训练集上根据模型的性能指标对模型参数进行优化。</li><li>在验证集上根据模型的性能指标对模型的超参数进行搜索</li><li>步骤 2 和步骤 3 交替迭代，最终确定模型的参数和超参数，在测试集中验证评价模型的优劣</li></ol><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>激活函数将非线性特性引入到网络中，在神经网络的神经元中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数。激活函数是为了增加神经网络模型的<strong>非线性</strong>。<strong>没有激活函数的每层都相当于矩阵相乘。就算你叠加了若干层之后，无非还是个矩阵相乘罢了。</strong>激活函数还可以把当前特征空间通过一定的线性映射转换到另一个空间，让数据能够更好的被分类。</p><ul><li>激活函数是个非线性函数：<ol><li>假若网络中全部是线性部件，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数</li><li>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</li></ol></li></ul><p>常见的激活函数有：Logistic函数，Tanh函数，ReLU函数，SoftPlus函数，可见参考<a href="https://www.cnblogs.com/wj-1314/p/12015278.html">【推荐】深度学习笔记——常用的激活（激励）函数</a><br><img src="/img/posts/MachineLearning/activate_fun.jpg" alt="激活函数"></p><h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p>Sigmoid也就是Logistic函数，表达式如下：  </p><p>$${S(x)} = \frac{1}{1+e^{(-x)}}$$  </p><p><img src="/img/posts/MachineLearning/Sigmoid.jpg" alt="Sigmoid函数即其导数图像"><br>绘图对应代码：</p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()# np.arrange(起点，终点，步长)x = np.arange(-10, 10, 0.025) # plot(x,y)plt.plot(x,1/(1+np.exp(-x)))plt.title("y = 1/(1+exp(-x))")# savefig存储要在show之前，不然输出的图片 会是空白plt.savefig('img/output_relu\'(x).png')plt.show() plt.plot(x,np.exp(-x)/(1+np.exp(-x))**2)plt.title("y = exp(-x)/(1+exp(-x))^2")plt.show()</code></pre><ul><li>Sigmoid函数连续可导，值域为(0,1)</li><li>相比较于阶跃函数，可以直接利用梯度下降算法优化网络参数</li><li>作为激活函数，将inputs映射到(0,1)，在早期的神经网络中使用地非常多，因为它很好地解释了神经元受到刺激后是否被激活和向后传递的场景（0：几乎没有被激活；1：完全被激活）。因此可以通过Simoid函数将<strong>输出转化为概率输出</strong>，常用于分类问题的<strong>事件概率</strong></li></ul><p>$$ {S’(x)} = {S(x)}{(1-S(x))} = \frac{e^{-x}}{(1+e^{-x})}$$</p><ul><li>在input x = 0时，导数醉倒为0.25，当输入为正负无穷时，导数趋于0，会发生梯度弥散  </li><li>Sigmoid函数光滑，易于求导，但是时指数级计算，计算量大，容易出现梯度弥散或者梯度饱和</li><li>当神经网络的层数很多时，如果每一层的激活函数都采用Sigmoid函数的话，就会产生梯度弥散和梯度爆炸的问题，其中梯度爆炸发生的概率非常小，而梯度消失发生的概率比较大。</li></ul><p>当一个激活函数S(x)满足<br>右饱和：$ \lim_{n\to +\infty} {S(x)} = 0 $<br>左饱和：$ \lim_{n\to -\infty} {S(x)} = 0 $<br>当S(x)同时满足左饱和与右饱和时，称之为饱和</p><h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>tanh是双曲函数中的一个，tanh() 为双曲正切，关于原点中心对称。在数学中，双曲正切 tanh 是由双曲正弦和双曲余弦这两者基本双曲函数推导而来。  </p><p>正切函数时非常常见的激活函数，<strong>与Sigmoid函数相比，它的输出均值是0</strong>，使得其<strong>收敛速度要比Sigmoid快</strong>，减少迭代次数。相对于Sigmoid的好处是它的输出的均值为0，克服了第二点缺点。<strong>但是当饱和的时候还是会杀死梯度。</strong></p><p>$$ {tanh(x)} = \frac {1-e^{-2x}}{1+e^{-2x}}$$</p><p>$$ {tanh’(x)} = {1-(tanh(x)^2)} =\frac {4e^{-2x}}{(1+e^{-2x})^2}$$</p><p><img src="/img/posts/MachineLearning/tanh.jpg" alt="tanh函数即其导数图像"><br>绘图代码如下</p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()x = np.arange(-10, 10, 0.025)plt.plot(x,(1-np.exp(-2*x))/(1+np.exp(-2*x)))plt.title("y = (1-exp(-2x))/(1+exp(-2x))")plt.show() plt.plot(x,4*np.exp(-2*x)/(1+np.exp(-2*x))**2)plt.title("y = 4exp(-2x)/(1+exp(-2x))^2")plt.show()</code></pre><ul><li>tanh函数的值域(-1,1)</li><li>在神经网络的应用中，tanh通常要优于Sigmoid的，因为tanh的输出在 -1~1之间，均值为0，更方便下一层网络的学习。</li><li>但是如果做二分类，输出层可以使用 Sigmoid，因为它可以算出属于某一类的概率。</li><li>tanh函数也存在着梯度弥散或梯度饱和和幂运算的缺点</li></ul><p>从tanh函数和sigmoid函数表达式中可以看出，<strong>tanh(x)的梯度消失问题比Simgoid(x)要轻，梯度如果过早消失会导致收敛速度较慢</strong></p><ul><li>以零为中心的影响，如果当前参数（w0, w1）的最佳优化方向是 （+d0, -d1），则根据反向传播计算公式，我们希望x0和x1符号相反，但是如果上一级神经元采用 Sigmoid 函数作为激活函数，Sigmoid不以零为中心，输出值恒为正，那么我们无法进行更快的参数更新，而是走Z字形逼近最优解。</li></ul><h3 id="ReLu函数"><a href="#ReLu函数" class="headerlink" title="ReLu函数"></a>ReLu函数</h3><p>针对Sigmoid函数和tanh的缺点，提出ReLU函数。</p><p>线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数。<strong>解决了梯度消失现象</strong>，,收敛速度远远大于 Sigmoid函数和 tanh函数,计算速度更快。计算方便，求导方便，计算速度非常快，只需要判断输入是否大于0。  </p><ul><li><strong>无饱和区，收敛快，计算简单</strong>，有时候会比较脆弱，如果变量的更新太快，还没有找到最佳值，就进入小于零的分段就会使得梯度变为零，无法更新直接死掉了。</li></ul><p>$$ {ReLu(x) = max(x,0)}$$</p><center>当x&gt;=0时，ReLu(x) = x </center><center>当x&lt;0时， ReLu(x) = 9 </center><center>ReLu'(x) = 1, 当x&gt;=0时</center><center>ReLu'(x) = 0, 当x&lt;0时</center>    <p><img src="/img/posts/MachineLearning/ReLu.jpg" alt="ReLu函数即其导数图像"></p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()x = np.arange(-10, 10, 0.025)# clip(x,最小，最大)plt.plot(x,np.clip(x,0,10e30))plt.title("y = relu(x)=max(x,0)")plt.show() from matplotlib import pyplot as pltplt.plot(x,x>0,"o")plt.title("y = relu'(x)")plt.show()</code></pre><p><strong>ReLU函数在零点不可导</strong><br>在反向传播中，对于ReLU间断点的求导按照做到书来计算，即默认情况下默认导数为零，negative_gradient = 0</p><p>可由caffe源码可知<br>~/caffe/src/caffe/layers/relu_layer.cpp倒数第十行代码：</p><pre class=" language-Python"><code class="language-Python">bottom_diff[i] = top_diff[i] * ((bottom_data[i] > 0)+ negative_slope * (bottom_data[i] <= 0));</code></pre><h4 id="ReLU的优缺点"><a href="#ReLU的优缺点" class="headerlink" title="ReLU的优缺点"></a>ReLU的优缺点</h4><p>ReLU函数就是一个取最大值函数，因为它的导数等于1或者就是0<br><strong>因为ReLU是线性的，而sigmoid和tanh是非线性的</strong>。相对于sigmoid和tanh激励函数，对ReLU求梯度非常简单，计算也很简单，可以非常大程度地提升随机梯度下降的收敛速度。</p><ul><li><p>优点： </p><ol><li>解决了梯度消失</li><li>计算方便，秩序判断输入是否大于0</li><li>收敛速度远远大于Sigmoid函数和tanh函数，可以加速网络训练</li></ol></li><li><p>缺点： 随着训练的进行，可能出现神经元死亡的情况，当有一个很大的梯度流经ReLu后，权重的更新结果可能是在此之后的任何数据点都无法激活改神经元</p><ol><li>由于负数部分恒为零，，、当x为负时导数等于零，会导致一些神经元无法激活</li><li>输出不是zero-centered</li><li>learning rate 太高，导致在训练过程中参数更新太大</li></ol></li></ul><h4 id="Leaky-ReLu函数"><a href="#Leaky-ReLu函数" class="headerlink" title="Leaky ReLu函数"></a>Leaky ReLu函数</h4><p>Leaky ReLU解决了ReLU会杀死一部分神经元的情况。Leaky ReLU 是给所有负值赋予一个非零斜率。Leaky ReLU 激活函数是在声学模型（2013）中首次提出。</p><p><img src="/img/posts/MachineLearning/LeakyReLu.jpg"></p><p><img src="/img/posts/MachineLearning/Leaky_ReLu.jpg" alt="Leaky_ReLu函数即其导数图像"></p><p>　人们为了解决 Dead ReLU Problem(ReLU的死神经问题), 提出了将 ReLU 的前半段设为 ax 而非0，通常 a = 0.01，另外一种直观的想法是基于参数的方法，即 ParmetricReLU ： f(x)=max(ax, x)，其中 a 可由方向传播算法学出来。理论上来说，Leaky ReLU 有ReLU的所有优点，外加不会有 Dead ReLU 问题，但是在实际操作当中，并没有完全证明 Leaky ReLU 总是好于 ReLU。</p><p><strong>Leaky  ReLU 主要是为了避免梯度消失，当神经元处于非激活状态时，允许一个非0的梯度存在</strong>，这样不会出现梯度消失，收敛速度快。他的优缺点和ReLU类似。</p><h3 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h3><p><a href="https://blog.csdn.net/lz_peter/article/details/84574716?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166289193816800184112865%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166289193816800184112865&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84574716-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Eadd_ask&amp;utm_term=softmax&amp;spm=1018.2226.3001.4187">Softmax理解</a></p><p>　　softmax 函数，又称为归一化指数函数。它是二分类函数 Sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。</p><p>他把<strong>一些输入映射为0-1之间的实数，并且归一化保证和为1，因此多分类的概率之和也刚好为1。</strong></p><p><img src="/img/posts/MachineLearning/Softmax01.jpg" alt="Softmax解释"></p><p>假设有一个数组V， $V_i$​表示V中的第i个元素，那么这个元素的softmax值为:</p><p>$$ S_i = \frac {e^i}{\sum_je^j} $$</p><p>该元素的softmax值，就是该元素的指数与所有元素指数和的比值。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在机器学习任务中，大部分监督学习算法都会有一个目标函数 (Objective Function),算法对该目标函数进行优化，称为优化算法的过程。 例如在分类或者回归任务中，<strong>使用损失函数( Loss Function )作为其目标函数对算法模型进行优化</strong>。</p><p>在BP神经网络中，使用均方误差作为损失函数，而在实际中，常用交叉熵作为损失函数。</p><ul><li><p>均方误差作为损失函数收敛速度慢，可能会陷入局部最优解；<strong>交叉熵</strong>作为损失函数的<strong>收敛速度</strong>比均方误差<strong>快</strong>，且较为容易找到函数最优解.</p></li><li><p>均方差损失函数：<br>  <img src="/img/posts/MachineLearning/avg_sqar.jpg"></p></li><li><p>Logistic 损失函数<br>  <img src="/img/posts/MachineLearning/logistic_loss.jpg"></p></li><li><p>负对数似然损失函数<br>  <img src="/img/posts/MachineLearning/neg_log_loss.jpg"></p></li><li><p><a href="https://blog.csdn.net/tsyccnh/article/details/79163834?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166289228816782412517434%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166289228816782412517434&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79163834-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Eadd_ask&amp;utm_term=%E4%BA%A4%E5%8F%89%E7%86%B5&amp;spm=1018.2226.3001.4187">交叉熵损失函数</a>:Logistic损失函数和负对数似然损失函数只能处理二分类问题，对于两个分类扩展到M个分类，使用交叉熵损失函数(Cross Entropy Loss)，熵用来表示所有信息量的期望[信息量：当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小，信息量和事件发生的概率]，其定义如下：</p><h2 id=""><a href="#" class="headerlink" title="  "></a>  <img src="/img/posts/MachineLearning/cross_entropy_loss.jpg"></h2></li><li><p>Hige:典型分类器是SVM算法因为 Hinge 损失可以用来解决间隔最大化问题。当分类模型需要硬分类结果的，例如分类结果是 0 或 1 、 -1或 1 的二分类数据， Hinge 损失是最方便的选择 。Hinge 损失函数定义如下：<br>  <img src="/img/posts/MachineLearning/hinge_loss.jpg"></p></li></ul><h3 id="神经网络中常用的损失函数"><a href="#神经网络中常用的损失函数" class="headerlink" title="神经网络中常用的损失函数"></a>神经网络中常用的损失函数</h3><p><a href="https://blog.csdn.net/weixin_44222014/article/details/103271192">常用损失函数参考介绍</a></p><ol><li><p>ReLU + MSE(均方差)<br> 均方误差损失函数无法处理梯度消失问题，而使用 Leak ReLU 激活函数能够减少计算时梯度消失的问题，因此在神经网络中如果需要使用均方误差损失函数，一般采用 Leak ReLU 等可以减少梯度消失的激活函数。另外，由于均方误差具有普遍性，一般作为衡量损失值的标准，因此使用均方误差作为损失函数表现既不会太好也不至于太差。</p></li><li><p>Sigmoid + Logistic<br> Sigmoid 函数会引起梯度消失问题：根据链式求导法，Sigmoid 函数求导后由多个［0, 1］范围的数进行连乘，如其导数形式为 ，当其中一个数很小时，连成后会无限趋近于零直至最后消失。而类 Logistic 损失函数求导时，加上对数后连乘操作转化为求和操作，在一定程度上避免了梯度消失，所以我们经常可以看到 Sigmoid 激活函数＋交叉摘损失函数 的组合。</p></li><li><p>Softmax + Logisitc<br> 在数学上，Softmax 激活函数会返回输出类的互斥概率分 布，也就是能把离散的输出转换为一个同分布互斥的概率，如(0.2, 0.8)。另外，Logisitc 损失函数是基于概率的最大似然估计函数而来的，因此输出概率化能够更加方便优化算法进行求导和计算，所以我们经常可以看到输出层使xu用Softmax激活函数＋交叉熵损失函数 的组合。</p></li></ol><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>深度学习网络训练过程可以分成两大部分：前向计算过程与反向传播过程。前向计算过程，是指通过我们预先设定好的卷积层、池化层等等，<strong>按照规定的网络结构一层层前向计算，得到预测的结果</strong>。反向传播过程，是为了将设定的网络中的<strong>众多参数</strong>一步步调整，使得<strong>预测结果能更加贴近真实值</strong>。在反向传播中参数更新显得尤为重要。</p><p>参数应该是<strong>朝着目标损失函数下降最快的方向</strong>更新，更确切的说，要朝着<strong>梯度方向</strong>更新</p><ul><li><p>随机梯度下降法：每次迭代（更新参数）只使用单个训练样本<br>  优点：一次迭代只需对一个样本进行计算，因此运行速度很快，还可用于在线学习<br>  缺点：（1）由于单个样本的随机性，实际过程中，目标损失函数值会剧烈波动，一方面，SGD 的波动使它能够跳到新的可能更好的局部最小值。另一方面，使得训练永远不会收敛，而是会<strong>一直在最小值附近波动</strong>。（2）一次迭代只计算一张图片，没有发挥GPU并行运算的优势，使得<strong>整体计算的效率不高</strong>。</p></li><li><p>批量梯度下降法：每次迭代更新中使用所有的训练样本<br>  优缺点分析：批量梯度下降算法能保证收敛到凸误差表面的全局最小值和非凸表面的局部最小值。但每迭代一次，需要用到训练集中的所有数据，如果数据量很大，那么迭代速度就会非常慢。</p></li><li><p>小批量梯度下降法：折中了 BGD 和 SGD 的方法，每次迭代使用 batch_size 个训练样本进行计算<br>  优缺点分析：因为每次迭代使用多个样本，所以 MBGD 比 SGD 收敛更稳定，也能避免 BGD 在数据集过大时迭代速度慢的问题。因此，MBGD是深度学习网络训练中经常使用的梯度下降方法。</p></li></ul><h3 id="动量梯度下降"><a href="#动量梯度下降" class="headerlink" title="动量梯度下降"></a>动量梯度下降</h3><p>动量梯度下降使得当前的参数更新方向不仅与当前的梯度有关，也受历史的加权平均梯度影响。对于梯度指向相同方向的维度，动量会积累并增加，而对于梯度改变方向的维度，动量会减少更新。这也就使得收敛速度加快，同时又不至于摆动幅度太大。</p><p>本质上，当使用动量时，如同我们将球推下山坡。球在滚下坡时积累动量，在途中变得越来越快。同样的事情发生在参数更新上：对于梯度指向相同方向的维度，动量会积累并增加，而对于梯度改变方向的维度，动量会减少更新。<strong>结果，我们获得了更快的收敛和减少的振荡</strong>。</p><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><p>Adam 是另一种参数自适应学习率的方法，相当于 RMSprop + Momentum，利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率</p><h2 id="激活函数、损失函数、优化函数的区别"><a href="#激活函数、损失函数、优化函数的区别" class="headerlink" title="激活函数、损失函数、优化函数的区别"></a>激活函数、损失函数、优化函数的区别</h2><p>1.激活函数：将神经网络上一层的输入，经过神经网络层的<strong>非线性变换转换</strong>后，通过激活函数，<strong>得到输出</strong>。常见的激活函数包括：sigmoid, tanh, relu等。</p><p><a href="https://blog.csdn.net/u013250416/article/details/80991831">激活函数</a></p><p>2.损失函数：度量神经网络的<strong>输出的预测值与实际值之间的差距</strong>的一种方式。常见的损失函数包括：最小二乘损失函数、交叉熵损失函数、回归中使用的smooth L1损失函数等。</p><p>3.优化函数：也就是如何把<strong>损失值</strong>从神经网络的最外层<strong>传递到最前面</strong>。如最基础的梯度下降算法，随机梯度下降算法，批量梯度下降算法，带动量的梯度下降算法，Adagrad，Adadelta，Adam等。</p><p><a href="https://blog.csdn.net/u013250416/article/details/81090059">优化函数</a></p><p>CNN由<strong>卷积层</strong>、<strong>池化层</strong>、<strong>全连接层</strong>三部分组成。</p><h2 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h2><p><a href="https://www.zhihu.com/question/22298352/answer/91131073">卷积</a></p><p>卷积网络执行的是监督训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。</p><ul><li><p>CNN的特点：</p><ol><li>能够有效的将大数据量的图片降维成小数据量。</li><li>能够有效的保留图片特征，符合图片处理的原则。</li></ol></li><li><p>CNN的核心：</p><ol><li>局部连接：通过卷积操作实现局部连接，这个局部区域的大小就是滤波器filter，避免了全连接中参数过多造成无法计算的情况。<br>  一般认为图像的空间联系是局部的像素联系比较密切，而距离较远的像素相关性较弱，因此，<strong>每个神经元没必要对全局图像进行感知，只要对局部进行感知</strong>，然后在<strong>更高层</strong>将<strong>局部的信息综合起来</strong>得到全局信息。</li></ol><ul><li>具体实现： 网络部分连通，每个神经元只与上一层的部分神经元相连，只感知局部，而不是整幅图像。</li></ul><ol start="2"><li>权值(参数)共享：通过权值共享来缩减实际参数的数量，为实现多层网络提供了可能。<br>  在局部连接中，每个神经元的参数都是一样的，即：<strong>同一个卷积核在图像中都是共享的。</strong>(对于图像上这部分学到的特征也可以用到另一部分上。所以对图像上的所有位置，都能使用同样的学习特征。)<br>  但卷积核共享会导致提取特征不充分，因此要<strong>通过增加多个卷积核来弥补</strong>，学习多种特征</li></ol></li></ul><p>CNN在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>以图像处理为例， 一般用一个正方形卷积核，遍历图片上的每一个像素点。<strong>图片与卷积核重合区域内</strong>相对应的<strong>每一个像素值</strong>，乘<strong>卷积核内相对应点</strong>的<strong>权重</strong>，然后<strong>求和</strong>， 再加上偏置后，最后得到输出图片中的一个像素值。<br>图片分<strong>灰度图</strong>和<strong>彩色图</strong>，卷积核可以是<strong>单个</strong>也可以是<strong>多个</strong>，因此卷积操作分以下三种情况：</p><ol><li><p>单通道输入，单卷积核</p><p> 单通道输入即灰度图，但卷积核即卷积核个数为1。<br> <img src="/img/posts/MachineLearning/simple_convo.jpg"></p><p> 上面是 5x5x1 的灰度图片，1表示单通道，5x5 表示分辨率，共有 行5列个灰度值。若用一个 3x3x1 的卷积核对  此5x5x1的灰度图片进行卷积，偏置项b=1，则求卷积的计算是：(-1)x1+0x0+1x2+(-1)x5+0x4+1x2+(-1)x3+0x4+1x5+1=1（注意不要忘记加偏置 1）。</p></li><li><p>多通道输入，单卷积核</p><p> 输入为彩色图片，输入的图片包含了红、绿、蓝三层数据，<strong>卷积核的深度（通道数）应该等于输入图片的通道数</strong>，所以使用 3x3x3的卷积核，最后一个 3 表示匹配输入图像 的 3 个通道，这样这个卷积核有三通道，<strong>每个通道都会随机生成 9 个待优化的参数</strong>，一共有<strong>27 个待优化参数  w</strong>和<strong>一个偏置 b</strong>。<br>  <img src="/img/posts/MachineLearning/simple_convo.jpg"></p><p> 这里还是单个卷积核的情况，但是一个卷积核可以有多个通道。默认情况下，卷积核的通道数等于输入图片的通道数。</p></li><li><p>多通道输入，多卷积核</p><p> 这是神经网络中最常见的方式，此处以3通道输入，两个卷积核为例。<br> <img src="/img/posts/MachineLearning/multi_convo.jpg"></p><ol><li>和多通道输入，单卷积核一样,先取出一个卷积核与3通道的输入进行卷积,得到一个1通道的输出output1。同样再取出第二个卷积核进行同样的操作,得到第二个输出output2。</li><li>将相同size的output1与output2进行堆叠，就得到2通道的输出output。<br> 图中输入X:[1,h,w,3]指的是：输入1张高h宽w的3通道图片。<br> 卷积核W:[k,k,3,2]指的是：卷积核尺寸为3*3，通道数为3，个数为2。</li></ol></li></ol><ul><li><strong>卷积核的个数和卷积核的通道数</strong>是不同的概念。每层卷积核的个数在设计网络时会给出，但是卷积核的通道数不一定会给出。<strong>默认情况下，卷积核的通道数=输入的通道数</strong>，因为这是进行卷积操作的必要条件。</li><li>卷积操作后，<strong>输出的通道数=卷积核的个数</strong></li><li>偏置数=卷积核数</li></ul><p>在卷积层中，可以通过调节步长参数 s 实现特征图的高宽成倍缩小，从而降低网络的参数量。</p><p>卷积层参数/卷积计算量<br>卷积参数 = 卷积核长度x卷积核宽度x输入通道数x输出通道数+输出通道数（偏置）<br>卷积计算量 = 输出数据大小x卷积核的尺度x输入通道数</p><p>例：输入：224x224x3，输出：224x244x64，卷积核：3x3</p><p>参数量 = 3x3x3x64+64<br>计算量 = 224x224x64x3x3x3</p><h4 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充 Padding"></a>填充 Padding</h4><p>为了使卷积操作后能得到满意的输出图片尺寸，经常会使用padding对输入进行填充操作。默认在图片周围填充0。</p><h3 id="池化层（Pooling-layel"><a href="#池化层（Pooling-layel" class="headerlink" title="池化层（Pooling-layel)"></a>池化层（Pooling-layel)</h3><p>功能：主要作用是把数据降维，可以有效的避免过拟合<br>池化作用如下</p><ol><li>使卷积神经网络<strong>抽取特征</strong>是<strong>保证特征局部不变性。</strong></li><li>池化操作能<strong>降低维度</strong>，<strong>减少参数数量</strong>。</li><li>池化操作优化比较简单。</li></ol><p><img src="/img/posts/MachineLearning/pooling.jpg"></p><p><img src="/img/posts/MachineLearning/pooling2.jpg"></p><p>池化层同样基于<strong>局部相关性</strong>的思想，通过从<strong>局部相关</strong>的一组元素中进行采样或信息聚合，从而得到新的元素值。通常我们用到两种池化进行下采样：<br>（1）最大池化(Max Pooling)，从局部相关元素集中选取最大的一个元素值。<br>（2）平均池化(Average Pooling)，从局部相关元素集中计算平均值并返回。</p><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>功能：根据不同任务输出我们想要的结果</p><p>每个神经元与前后相邻层的每一个神经元都有连接关系,输入特征，输出预测的结果。<br>全连接层的参数量 = $\sum {(前层x后层+后层)}$</p><p>由于一般全连接层参数较多，实际应用中一般不会将原始图片直接喂入全连接网络。尤其现实生活中高分辨率的彩色图像，像素点更多，且为红绿蓝三通道信息。待优化的参数过多， 容易导致模型过拟合。<br>在实际应用中，会先对原始图像<strong>进行卷积特征提取</strong>，把提取到的<strong>特征</strong>喂给全连接网络，再让全连接网络计算出分类评估值。</p><h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>卷积神经网络中最常用的是ReLU。<br><a href="https://blog.csdn.net/wjinjie/article/details/104729911">激活函数的选择</a></p><h3 id="卷积神经网络的训练步骤"><a href="#卷积神经网络的训练步骤" class="headerlink" title="卷积神经网络的训练步骤"></a>卷积神经网络的训练步骤</h3><p><img src="/img/posts/MachineLearning/convo_procedure.jpg"></p><ol><li><p>用随机数初始化<strong>所有的卷积核参数/权重</strong></p></li><li><p>将训练集图片作为输入，进行前向步骤，包括<strong>卷积</strong>、<strong>ReLU激活</strong>、<strong>池化</strong>、<strong>全连接层的前向传播</strong>，并计算各个类别对应的输出概率</p></li><li><p>计算出书层的总误差</p></li><li><p>用误差<strong>反向传播</strong>算法计算<strong>误差相对于所有权重的梯度</strong>，利用梯度下降<strong>更新所有的卷积核参数/权重的值</strong></p></li></ol><p>卷积核个数、卷积核尺寸、网络架构这些参数，是在 之前就已经固定的，且不会在训练过程中改变——只有<strong>卷积核矩阵</strong>和<strong>神经元权重</strong>会更新。</p><h4 id="经典网络介绍"><a href="#经典网络介绍" class="headerlink" title="经典网络介绍"></a>经典网络介绍</h4><p><a href="https://blog.csdn.net/jiaoyangwm/article/details/80011656">卷积神经网络介绍</a></p><ul><li><p>残差网络(Residual Network,ResNet)：通过非线性的卷积层增加直连边，也就是残差连接的方式来提高信息传播小笼包</p></li><li><p>AlexNet</p></li></ul><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p><a href="https://my.oschina.net/u/876354/blog/1621839">循环神经网络</a>通过使用带自反馈的神经元，能够处理任意长度的序列，比前馈神经网络更符合生物神经网络结构。<br>RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。</p><h2 id="目标检测算法-Yolo"><a href="#目标检测算法-Yolo" class="headerlink" title="目标检测算法-Yolo"></a>目标检测算法-Yolo</h2><p>Yolo是one-stage，一步回归到位，与two-stage相比，核心优势在于速度非常快，适合做实时检测任务，但可能相比two-stage(MaskRcnn)的检测精度效果会相对较差</p><p>考虑指标；</p><ul><li>map：map越高，效果越好，，不要单看精度、召回率。把所有阈值都考虑进来，以recall为横轴，precison为纵轴，作一个曲线图，map值就是所有类别的平均值</li><li>IoU：/frac {预测值与真实值的重叠区域(交集)}{预测值与真实值的并集}，IoU越高越好</li><li>精度 = /frac {TP}{TP+FP}</li><li>召回率 = /frac {TP}{TP+FN}</li></ul><p>在检测任务中的精度与招呼率代表：</p><ul><li><p>TP = true positive(1被正确的判断为1) FN = false Negative（1被错误的判断为0）</p></li><li><p>FP = false positive(0被错误的判断为1) FN = false negative（0被正确的判断为0）</p></li><li><p>置信度(confidence)：通俗而言就是检测一个物体它是一个人的可能性有多大，需要基于置信度阈值来计算</p></li></ul><p>Yolo的map比fast-Rcnn低，但速度比rcnn快</p><h3 id="Yolo-V1"><a href="#Yolo-V1" class="headerlink" title="Yolo-V1"></a>Yolo-V1</h3><p>输入： SxS的网格</p><p>预测得出得出bounding box（x,y,w,h） + confidence ==&gt; 四个偏移量加上一个置信度</p><ul><li>置信度较高才说明是一个物体，此时再去作筛选</li></ul><h3 id="Yolo-v3"><a href="#Yolo-v3" class="headerlink" title="Yolo-v3"></a>Yolo-v3</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习3-多元梯度下降</title>
      <link href="/2021/07/30/ji-qi-xue-xi-3-duo-yuan-ti-du-xia-jiang/"/>
      <url>/2021/07/30/ji-qi-xue-xi-3-duo-yuan-ti-du-xia-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>多元线性回归也就是用多个特征变量来进行预测  </p><div align="center"><font size="4">$h_\theta$($\theta$) = $\theta_0$+$\theta_1$$x_1$+$\theta_2$$x_2$+$\theta_3$$x_3$+$\theta_4$$x_4$...+$\theta_n$$x_n$</font></div>    <center>定义$x_0$ = 1</center>  <p>所以<br>    x =<br>        $$\begin{bmatrix}<br>        x_0 x_1 x_2 … x_n<br>        \end{bmatrix}$$</p><p>$\theta$ = $$\begin{bmatrix}\theta_0 \ \theta_1  \ \theta_2 \ … \theta_n\end{bmatrix}$$</p><p>所以得出$h_\theta(x) = \theta^Tx$</p><h2 id="用梯度下降处理多元线性回归"><a href="#用梯度下降处理多元线性回归" class="headerlink" title="用梯度下降处理多元线性回归"></a>用梯度下降处理多元线性回归</h2><p>在梯度下降中的假设<br>$$h_\theta(x) = \theta^Tx$$</p><p>代价函数</p><p>$$J(\theta_0,\theta_1…\theta_n) = \frac{1}{2m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))^2$$</p><p>梯度下降</p><center>重复多次</center>    <p>$$\theta := \theta_j - \alpha \frac{\partial {J(\theta)}}{\partial \theta_j}$$</p><p>$\alpha$是学习率</p><p>最终梯度下降</p><center>重复</center>$$ \theta_j := \theta_j - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_j^{(i)}$$<p>即<br>$$ \theta_0 := \theta_0 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_0^{(i)}$$<br>$$ \theta_1 := \theta_1 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_1^{(i)}$$<br>$$ \theta_2 := \theta_2 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_2^{(i)}$$</p><h2 id="特征缩放-Feature-scaling"><a href="#特征缩放-Feature-scaling" class="headerlink" title="特征缩放(Feature scaling)"></a>特征缩放(Feature scaling)</h2><blockquote><p>不同特征的取值在一个相近的范围，这样梯度下降容易更好地收敛</p></blockquote><p>特征地范围不要过小也不要过大</p><h3 id="均值归一化-Mean-normalization"><a href="#均值归一化-Mean-normalization" class="headerlink" title="均值归一化(Mean normalization)"></a>均值归一化(Mean normalization)</h3><blockquote><p>将$x_i$用$x_i-\mu_i$代替是的特征均值为0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-哈希表</title>
      <link href="/2021/07/30/leetcode-ha-xi-biao/"/>
      <url>/2021/07/30/leetcode-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="构造哈希表"><a href="#构造哈希表" class="headerlink" title="构造哈希表"></a>构造哈希表</h2><p>参考<a href="https://leetcode.cn/problems/design-hashset/">Leetcode705-设计哈希结合</a></p><p>要解决的问题</p><ul><li>映射： 将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</li><li>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理</li><li>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</li></ul><p>考虑到哈希表后期需要扩容，一般不会考虑直接用数组，而是采用链表</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习2-矩阵方程</title>
      <link href="/2021/07/23/ji-qi-xue-xi-2-ju-zhen-fang-cheng/"/>
      <url>/2021/07/23/ji-qi-xue-xi-2-ju-zhen-fang-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵的基本概念"><a href="#矩阵的基本概念" class="headerlink" title="矩阵的基本概念"></a>矩阵的基本概念</h2><ul><li>dimension ：行x列 </li><li>矩阵表示<br>  2x3的矩阵表示:<br>  $$\begin{bmatrix}<br>  1&amp;1&amp;0 \<br>  1&amp;0&amp;1 \<br>  \end{bmatrix}$$<br><br>  3x2的矩阵表示:<br>  $$\begin{bmatrix}<br>  0&amp;1 \<br>  1&amp;0 \<br>  1&amp;1 \<br>  \end{bmatrix}$$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch配置</title>
      <link href="/2021/07/21/torch-pei-zhi/"/>
      <url>/2021/07/21/torch-pei-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cuda:11.3.0（官网安装）<a href="https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local">https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local</a><br>Nvida CUDA 11.4.141<br>显卡： NVDIA Getforce RTX 3050 Ti</p></blockquote><p>troch安装网址：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><h2 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h2><p>直接在C:\user\.condarc中修改</p><pre class=" language-shell"><code class="language-shell">channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - defaultsssl_verify: falseshow_channel_urls: truereport_errors: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习1--机器学习是干什么</title>
      <link href="/2021/07/20/ji-qi-xue-xi-1-ji-qi-xue-xi-shi-gan-shi-me/"/>
      <url>/2021/07/20/ji-qi-xue-xi-1-ji-qi-xue-xi-shi-gan-shi-me/</url>
      
        <content type="html"><![CDATA[<p>监督学习与非监督学习，假设函数与代价函数，梯度下降</p><h2 id="监督学习与非监督学习"><a href="#监督学习与非监督学习" class="headerlink" title="监督学习与非监督学习"></a>监督学习与非监督学习</h2><blockquote><p><strong>有无预期输出</strong>是监督学习与非监督学习的最大区别</p></blockquote><ul><li>监督学习：学习一个模型使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</li></ul><p>即：利用训练数据集学习一个模型，再用模型对测试样本集进行预测。</p><p><strong>分类问题（离散）</strong>与<strong>回归问题（连续）</strong>等都是监督学习。</p><ul><li>非监督学习：直接对数据进行建模。没有给定事先标记过的训练范例，所用的数据没有属性或标签这一概念。事先不知道输入数据对应的输出结果是什么。</li></ul><p>自动对输入的资料进行分类或分群，以寻找数据的模型和规律。</p><p><strong>聚类算法</strong>是一种非监督学习，针对数据集，自动找出数据中的结构，从而把数据分成不同的簇。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>此处以最简单的线性回归（如房价预测）为例，线性回归的学习是为了预测未来房价</p><p>机器学习是在已知部分x与y的情况下，得出一个房价相关的线性函数y = ax + b</p><p>所以代价函数是与参数a,b相关的函数,使得代价函数最小化，是线性回归中的学习目标</p><p>常用的代价函数有<br>    <img src="/img/posts/MachineLearning/cost_function.jpg" alt="平方和代价函数"></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="梯度下降的过程"><a href="#梯度下降的过程" class="headerlink" title="梯度下降的过程"></a>梯度下降的过程</h3><ol><li>选定几个参数a1,a2,a3…</li><li>选择初始值</li><li>从初值开始按照给定的步幅进行梯度下降，寻找局部极小值</li></ol><p><img src="/img/posts/MachineLearning/slope0.jpg" alt="梯度下降可以用等高线图具象化"></p><p><img src="/img/posts/MachineLearning/slope1.jpg" alt="选择初始点"></p><p><img src="/img/posts/MachineLearning/slope3.jpg" alt="从a点一步一步往下梯度下降"></p><p><img src="/img/posts/MachineLearning/slope2.jpg" alt="从b点一步一步往下梯度下降"></p><blockquote><p>从不同的点进行梯度下降可能得到<strong>不同</strong>的局部极小值</p></blockquote><h3 id="梯度下降的数理解释"><a href="#梯度下降的数理解释" class="headerlink" title="梯度下降的数理解释"></a>梯度下降的数理解释</h3><p><img src="/img/posts/MachineLearning/slope_definition.jpg" alt="梯度下降的数理解释"></p><p>a是学习率<br>下一步的值 = 这一步的值 - 学习率*代价函数分别对参数a1,a2,a3…的偏导</p><p>对于梯度下降公式中偏导的简化</p><p><img src="/img/posts/MachineLearning/slope_deri0.jpg" alt="符合求偏导"></p><p>梯度下降是一种<strong>同步更新</strong>算法，要求参数a1,a2,a3同步更新，所以<br><img src="/img/posts/MachineLearning/slope_detail0.jpg" alt="要按照左侧的顺序来"></p><h3 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h3><p><img src="/img/posts/MachineLearning/slope_linear.jpg" alt="梯度下降再线性回归中的模型"></p><p>将代数函数用等高线图（右侧）表示</p><p><img src="/img/posts/MachineLearning/slope4.jpg" alt="由于该代数函数是一个凹函数，所以局部极小就是全局最小，因此要得到左侧最拟合的目标函数，需要右侧趋近于等高线图最中间的圆圈"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度下降 </tag>
            
            <tag> 代价函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>识别mnist手写数字数据集</title>
      <link href="/2021/07/11/shi-bie-mnist-shou-xie-shu-zi-shu-ju-ji/"/>
      <url>/2021/07/11/shi-bie-mnist-shou-xie-shu-zi-shu-ju-ji/</url>
      
        <content type="html"><![CDATA[<p>MNIST包含70,000张手写数字图像: 60,000张用于培训，10,000张于测试。图像是灰度的，28x28像素的。<br>识别mnist手写数字及可以视作图像识别的入门学习任务<br>需要准备pytorch环境</p><pre class=" language-Python"><code class="language-Python">import torchimport torchvisionfrom torch.utils.data import DataLoader</code></pre><h2 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h2><pre class=" language-Python"><code class="language-Python">n_epochs = 3 # 整个训练集训练的次数batch_size_train = 64  # 训练集的批次大小batch_size_test = 1000  # 测试机batchsizelearning_rate = 0.01momentum = 0.5log_interval = 10# 对于可重复实验设置随机种子，进行重复实验，设置随机种子random_seed = 1torch.manual_seed(random_seed)</code></pre><p>learning_rate和momentum是我们稍后将使用的优化器的超参数。  </p><h2 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h2><p>直接利用torchvision加载minist数据集，我们将使用batch_size=64进行训练，并使用size=1000对这个数据集进行测试。下面的Normalize()转换使用的值0.1307和0.3081是MNIST数据集的全局平均值和标准偏差，此处我们将它们作为给定值。</p><pre class=" language-Python"><code class="language-Python"> # 下载训练集和测试集, './minist_data'是目录下相对路径 # 记得要设置download为true，不然可能下载到一般突然中断 # train=True是训练集，batch_size=batch_size_traintrain_loader = dataLoader(    torchvision.datasets.MNIST('./mnist_data',train=True, download=True,                          transform= torchvision.transforms.Compose([                              torchvision.transforms.ToTensor(),                              torchvision.transforms.Normalize((0.1307,),(0.3081,))                          ])),    batch_size=batch_size_train, shuffle=True) # train=False是测试集，batch_size=batch_size_testtest_loader = dataLoader(    torchvision.datasets.MNIST('./mnist_data',train=False, download=True,                          transform= torchvision.transforms.Compose([                              torchvision.transforms.ToTensor(),                              torchvision.transforms.Normalize((0.1307,),(0.3081,))                          ])),    batch_size=batch_size_test, shuffle=True)</code></pre><p>下载完成后，在目录./mnist_data/MNIST/raw目录下可以看到这些<br><img src="/img/posts/Programming/mnist0.jpg"></p><p>利用train_loader来看训练数据的组成</p><pre class=" language-Python"><code class="language-Python">examples = enumerate(train_loader)batch_idx, (example_data, example_targets) = nex(examples)print(example_targets)  # example_targets是图片实际对应的数字标签print(example_data.shape)  # 一批训练数据是一个数据张量</code></pre><p>输出结果<br><img src="/img/posts/Programming/mnist1.jpg"></p><p>这意味着我们有64个例子的28x28像素的灰度(即没有rgb通道)。</p><p>尝试用mathplotllib绘制部分</p><pre class=" language-Python"><code class="language-Python">import matplotlib.pyplot as pltfig = plt.figure()for i in range(12):    plt.subplot(3,4,i+1)  # subplot(m,n,i) 说明是m*n的网格表示，i表示每个plot的编号， 这样可以把几张图放在一张图片中表示出来    plt.tight_layout()    plt.imshow(example_data[i][0], cmap='gray', interpolation='none')    plt.title("Ground Truth:{}".format(example_targets[i]))    plt.xticks([])    plt.yticks([])plt.show()</code></pre><p><img src="/img/posts/Programming/mnist2.jpg" alt="输出结果"></p><h2 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
