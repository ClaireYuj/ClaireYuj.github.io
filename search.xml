<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习手撕合集</title>
      <link href="/2025/03/17/ji-qi-xue-xi-shou-si-he-ji/"/>
      <url>/2025/03/17/ji-qi-xue-xi-shou-si-he-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><h3 id="L1-x2F-L2正则化对比"><a href="#L1-x2F-L2正则化对比" class="headerlink" title="L1/L2正则化对比"></a>L1/L2正则化对比</h3><table><thead><tr><th><strong>特性</strong></th><th>L1正则化</th><th>L2正则化</th></tr></thead><tbody><tr><td>解的稀疏性</td><td>产生稀疏解（特征选择）</td><td>非稀疏解</td></tr><tr><td>优化形式</td><td>$|w|_1$</td><td>$|w|_2^2$</td></tr><tr><td>梯度特性</td><td>不连续梯度（需特殊优化方法）</td><td>平滑梯度</td></tr><tr><td>适用场景</td><td>高维稀疏数据（如文本分类）</td><td>通用场景</td></tr></tbody></table><hr><h3 id="归一化-vs-标准化"><a href="#归一化-vs-标准化" class="headerlink" title="归一化 vs 标准化"></a>归一化 vs 标准化</h3><table><thead><tr><th><strong>对比维度</strong></th><th>归一化（Normalization）</th><th>标准化（Standardization）</th></tr></thead><tbody><tr><td>公式</td><td>$(x - x_{\min}) / (x_{\max} - x_{\min})$</td><td>$(x - \mu) / \sigma$</td></tr><tr><td>分布</td><td>强行压缩到[0,1]区间</td><td>保留原始分布形态</td></tr><tr><td>适用场景</td><td>图像处理、固定范围特征</td><td>数据分布未知或存在异常值</td></tr><tr><td>缺点</td><td>对异常值敏感</td><td>不保证有界性</td></tr></tbody></table><hr><h3 id="KNN算法与k值影响"><a href="#KNN算法与k值影响" class="headerlink" title="KNN算法与k值影响"></a>KNN算法与k值影响</h3><p><strong>算法思想</strong>：  </p><ol><li>计算测试样本与所有训练样本的距离  </li><li>选取k个最近邻样本  </li><li>通过多数投票（分类）或均值（回归）预测</li></ol><p><strong>k值过大问题</strong>：  </p><ul><li>模型偏向全局分布，丧失局部特征  </li><li>计算开销增大（需存储全部训练数据）  </li><li>对噪声和无关特征更敏感</li></ul><hr><h4 id="5-AUC是什么？"><a href="#5-AUC是什么？" class="headerlink" title="5. AUC是什么？"></a>5. AUC是什么？</h4><p><strong>定义</strong>：  </p><ul><li>ROC曲线下面积，取值范围[0,1]  </li><li>物理意义：随机选取正样本得分高于负样本的概率</li></ul><p><strong>快速计算</strong>：<br>$$\text{AUC} = \frac{\sum_{i=1}^{m} \sum_{j=1}^{n} I(p_i &gt; p_j)}{m \cdot n}$$<br>其中$m,n$为正负样本数，$I$为指示函数</p><hr><h3 id="AUC推广到非二分类问题"><a href="#AUC推广到非二分类问题" class="headerlink" title="AUC推广到非二分类问题"></a>AUC推广到非二分类问题</h3><p><strong>多分类推广</strong>：  </p><ul><li><strong>One-vs-Rest</strong>：对每个类别计算AUC后取平均  </li><li><strong>Weighted AUC</strong>：按类别样本比例加权  </li><li><strong>Ranking Metrics</strong>：直接使用NDCG/MAP等排序指标</li></ul><p><strong>快速计算优化</strong>：  </p><ul><li>近似采样：随机抽取部分样本对  </li><li>分桶排序：对预测值分桶后计算近似排名</li></ul><hr><h3 id="熵与交叉熵"><a href="#熵与交叉熵" class="headerlink" title="熵与交叉熵"></a>熵与交叉熵</h3><p><strong>熵</strong>：<br>$$H(p) = -\sum_{i=1}^n p_i \log p_i$$  </p><ul><li>描述系统的不确定性，熵越大越混乱</li></ul><p><strong>交叉熵</strong>：<br>$$H(p,q) = -\sum_{i=1}^n p_i \log q_i$$  </p><ul><li>衡量两个概率分布的差异  </li><li>在机器学习中常用作损失函数（当p为真实分布，q为预测分布时）</li></ul><hr><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器通过调节模型参数，最小化损失函数。</p><h4 id="三种梯度下降法对比"><a href="#三种梯度下降法对比" class="headerlink" title="三种梯度下降法对比"></a>三种梯度下降法对比</h4><table><thead><tr><th><strong>类型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>批量梯度下降</td><td>稳定收敛，方向准确</td><td>内存要求高，计算慢</td></tr><tr><td>随机梯度下降</td><td>内存小，适合在线学习</td><td>震荡大，收敛不稳定</td></tr><tr><td>小批量梯度下降</td><td>平衡速度与稳定性（常用）</td><td>需调批量大小</td></tr></tbody></table><hr><h4 id="优化器改进路线"><a href="#优化器改进路线" class="headerlink" title="优化器改进路线"></a>优化器改进路线</h4><ol><li><strong>Momentum</strong>：引入动量项加速收敛，减少震荡。  </li><li><strong>Adagrad</strong>：自适应学习率，适合稀疏数据。  </li><li><strong>RMSprop</strong>：修正 Adagrad 的学习率衰减问题。  </li><li><strong>Adam</strong>：结合 Momentum 和 RMSprop，自适应学习率 + 动量。  </li><li><strong>Nadam</strong>：Adam + Nesterov 加速梯度。</li></ol><hr><h4 id="SGD-随机梯度下降"><a href="#SGD-随机梯度下降" class="headerlink" title="SGD(随机梯度下降)"></a>SGD(随机梯度下降)</h4><p>$$ \theta_{t+1} = \theta_t - lr * grad(\theta)$$<br>梯度也就是损失函数loss($\theta$)对$\theta$的偏导，也据说loss function上升或者下降的方向。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sgd</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> param<span class="token punctuation">,</span> grad <span class="token keyword">in</span> zip<span class="token punctuation">(</span>params<span class="token punctuation">,</span> grads<span class="token punctuation">)</span><span class="token punctuation">:</span>        param <span class="token operator">-=</span> lr <span class="token operator">*</span> grad    <span class="token keyword">return</span> params</code></pre><hr><h4 id="Adam-自适应矩估计"><a href="#Adam-自适应矩估计" class="headerlink" title="Adam(自适应矩估计)"></a>Adam(自适应矩估计)</h4><p>分为动量计算、偏差修正、参数更新三个步骤。</p><ul><li><p><strong>动量计算</strong>：<br>以动量为一阶矩，自适应学习率为二阶矩。<br>  一阶矩衰减率$\beta_1 = 0.9$, 二阶矩衰减率$\beta_2 = 0.99$<br>  $m_t  = \beta_1<em>m_{t-1}+ (1-\beta_1) * grad(\theta) $<br>  $v_t  = \beta_2</em>v_{t-1}+ (1-\beta_2) * grad^2(\theta) $</p></li><li><p><strong>偏差修正</strong>：<br>针对冷启动问题，设置初始时刻得零偏置<br>$$\hat{m_t} = \frac{m_t}{1-\beta_t^1},  \hat{v_t} = \frac{v_t}{1-\beta_t^2}$$</p></li><li><p><strong>参数更新</strong><br>$$\theta_{t+1} = \theta_{t}-lr * \frac{\hat{m_t}}{\sqrt{\hat{v_t}}+\epsilon}$$<br>$\epsilon$=1e-8，防止除零</p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Adam</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> params<span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">,</span> beta1<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> beta2<span class="token operator">=</span><span class="token number">0.999</span><span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>params <span class="token operator">=</span> params        self<span class="token punctuation">.</span>lr <span class="token operator">=</span> lr        self<span class="token punctuation">.</span>beta1 <span class="token operator">=</span> beta1        self<span class="token punctuation">.</span>beta2 <span class="token operator">=</span> beta2        self<span class="token punctuation">.</span>eps <span class="token operator">=</span> eps        self<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> params<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 一阶矩</span>        self<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> params<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 二阶矩</span>        self<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 时间步</span>    <span class="token keyword">def</span> <span class="token function">step</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grads<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>t <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>param<span class="token punctuation">,</span> grad<span class="token punctuation">)</span> <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>self<span class="token punctuation">.</span>params<span class="token punctuation">,</span> grads<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>beta1 <span class="token operator">*</span> self<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>beta1<span class="token punctuation">)</span> <span class="token operator">*</span> grad            self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>beta2 <span class="token operator">*</span> self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>beta2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>grad <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 偏差校正</span>            m_hat <span class="token operator">=</span> self<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>beta1 <span class="token operator">**</span> self<span class="token punctuation">.</span>t<span class="token punctuation">)</span>            v_hat <span class="token operator">=</span> self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>beta2 <span class="token operator">**</span> self<span class="token punctuation">.</span>t<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 更新参数</span>            param <span class="token operator">-=</span> self<span class="token punctuation">.</span>lr <span class="token operator">*</span> m_hat <span class="token operator">/</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>v_hat<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>eps<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>params</code></pre><hr><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><h3 id="推荐算法了解哪些？"><a href="#推荐算法了解哪些？" class="headerlink" title="推荐算法了解哪些？"></a>推荐算法了解哪些？</h3><p><strong>分类</strong>：  </p><table><thead><tr><th>类型</th><th>代表算法</th></tr></thead><tbody><tr><td>协同过滤</td><td>User-CF, Item-CF, SVD++</td></tr><tr><td>矩阵分解</td><td>ALS, BPR</td></tr><tr><td>深度学习</td><td>NeuralCF, DIN, GraphSAGE</td></tr><tr><td>序列建模</td><td>GRU4Rec, SASRec</td></tr><tr><td>多任务学习</td><td>MMOE, ESMM</td></tr></tbody></table><hr><h3 id="普适性物品（如新华字典）降权策略"><a href="#普适性物品（如新华字典）降权策略" class="headerlink" title="普适性物品（如新华字典）降权策略"></a>普适性物品（如新华字典）降权策略</h3><p><strong>指标设计</strong>：  </p><table><thead><tr><th>方法</th><th>公式示例</th><th>特点</th></tr></thead><tbody><tr><td>逆流行度权重</td><td>$w = \log \frac{N}{1+\text{曝光量}}$</td><td>抑制高频物品</td></tr><tr><td>个性化衰减因子</td><td>$w_u = 1 - \frac{\text{用户点击次数}}{C+\text{用户总点击量}}$</td><td>动态调整用户侧权重</td></tr><tr><td>内容质量加权</td><td>$w = \frac{\text{优质分}}{1+\text{曝光量}}$</td><td>结合质量评估</td></tr></tbody></table><hr><h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><p><strong>Goal</strong>：将用户-物品评分矩阵 R 分解为两个低维矩阵 U（用户特征）和 V（物品特征），使得 $R≈U⋅V^T$</p><h4 id="协同过滤的概念是什么？"><a href="#协同过滤的概念是什么？" class="headerlink" title="协同过滤的概念是什么？"></a>协同过滤的概念是什么？</h4><p><strong>核心思想</strong>：  </p><ul><li>基于用户-物品交互行为（显式/隐式）的相似性进行推荐  </li><li>两类方法：  <ul><li><strong>User-CF</strong>：找相似用户，推荐他们喜欢的物品  </li><li><strong>Item-CF</strong>：找相似物品，推荐给用户</li></ul></li></ul><p><strong>关键公式</strong>（用户相似度计算）：<br>$$\text{sim}(u,v) = \frac{\sum_{i \in I_{uv}}(r_{ui} - \bar{r}<em>u)(r</em>{vi} - \bar{r}<em>v)}{\sqrt{\sum</em>{i \in I_{uv}}(r_{ui} - \bar{r}<em>u)^2} \sqrt{\sum</em>{i \in I_{uv}}(r_{vi} - \bar{r}_v)^2}}$$</p><hr><h4 id="损失函数（带正则化）"><a href="#损失函数（带正则化）" class="headerlink" title="损失函数（带正则化）"></a>损失函数（带正则化）</h4><p>[<br>L = \sum_{(u,i) \in \text{已知评分}} \left( R_{ui} - U_u \cdot V_i^T \right)^2 + \lambda \left( |U|_F^2 + |V|_F^2 \right)<br>]</p><ul><li>( U_u ): 用户 ( u ) 的潜在特征向量  </li><li>( V_i ): 物品 ( i ) 的潜在特征向量  </li><li>( \lambda ): 正则化系数</li></ul><hr><h4 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h4><ul><li><strong>用户特征梯度</strong>：<br>[<br>\frac{\partial L}{\partial U_u} = -2 \left( R_{ui} - U_u \cdot V_i^T \right) V_i + 2\lambda U_u<br>]</li><li><strong>物品特征梯度</strong>：<br>[<br>\frac{\partial L}{\partial V_i} = -2 \left( R_{ui} - U_u \cdot V_i^T \right) U_u + 2\lambda V_i<br>]</li></ul><hr><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><strong>数据准备</strong>：加载用户-物品评分数据（稀疏格式）。</li><li><strong>参数初始化</strong>：随机初始化 ( U ) 和 ( V )。</li><li><strong>迭代优化</strong>：<ul><li>遍历每个已知评分 ( (u, i, R_{ui}) )。</li><li>计算预测误差 ( e_{ui} = R_{ui} - U_u \cdot V_i^T )。</li><li>更新用户和物品特征：<br>[<br>U_u \leftarrow U_u + \alpha \left( e_{ui} \cdot V_i - \lambda U_u \right)<br>]<br>[<br>V_i \leftarrow V_i + \alpha \left( e_{ui} \cdot U_u - \lambda V_i \right)<br>]</li></ul></li><li><strong>重复</strong>：直到损失收敛或达到最大迭代次数。</li></ol><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">class</span> <span class="token class-name">MatrixFactorization</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_users<span class="token punctuation">,</span> num_items<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> lambda_reg<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>num_users <span class="token operator">=</span> num_users        self<span class="token punctuation">.</span>num_items <span class="token operator">=</span> num_items        self<span class="token punctuation">.</span>k <span class="token operator">=</span> k          <span class="token comment" spellcheck="true"># 潜在因子数量</span>        self<span class="token punctuation">.</span>alpha <span class="token operator">=</span> alpha  <span class="token comment" spellcheck="true"># 学习率</span>        self<span class="token punctuation">.</span>lambda_reg <span class="token operator">=</span> lambda_reg  <span class="token comment" spellcheck="true"># 正则化系数</span>        self<span class="token punctuation">.</span>epochs <span class="token operator">=</span> epochs        <span class="token comment" spellcheck="true"># 初始化用户和物品特征矩阵</span>        self<span class="token punctuation">.</span>U <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token operator">/</span>self<span class="token punctuation">.</span>k<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span>num_users<span class="token punctuation">,</span> self<span class="token punctuation">.</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>V <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token operator">/</span>self<span class="token punctuation">.</span>k<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span>num_items<span class="token punctuation">,</span> self<span class="token punctuation">.</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ratings<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""训练模型        ratings: 三元组列表 [(user_id, item_id, rating)]        """</span>        <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>            total_loss <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> u<span class="token punctuation">,</span> i<span class="token punctuation">,</span> r <span class="token keyword">in</span> ratings<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 计算预测值和误差</span>                prediction <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>U<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                error <span class="token operator">=</span> r <span class="token operator">-</span> prediction                <span class="token comment" spellcheck="true"># 计算梯度并更新参数</span>                grad_u <span class="token operator">=</span> error <span class="token operator">*</span> self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>lambda_reg <span class="token operator">*</span> self<span class="token punctuation">.</span>U<span class="token punctuation">[</span>u<span class="token punctuation">]</span>                grad_v <span class="token operator">=</span> error <span class="token operator">*</span> self<span class="token punctuation">.</span>U<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>lambda_reg <span class="token operator">*</span> self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                self<span class="token punctuation">.</span>U<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>alpha <span class="token operator">*</span> grad_u                self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>alpha <span class="token operator">*</span> grad_v                <span class="token comment" spellcheck="true"># 累计损失（可选）</span>                total_loss <span class="token operator">+=</span> error<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>lambda_reg <span class="token operator">*</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>self<span class="token punctuation">.</span>U<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Epoch {epoch+1}, Loss: {total_loss / len(ratings):.4f}"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""预测用户u对物品i的评分"""</span>        <span class="token keyword">return</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>U<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h4><ul><li><strong>ItemCF的关联规则为什么有效？应用前后指标差异</strong><ul><li><strong>有效性原理</strong>：<br>基于用户行为共现（如同时点击A和B物品），挖掘物品间相似性。假设用户偏好相似的物品组合。</li><li><strong>指标差异</strong>：<br>- <strong>提升指标</strong>：推荐准确率（CTR↑）、覆盖率（长尾物品曝光↑）<br>- <strong>潜在下降</strong>：多样性（过度聚焦关联物品可能↓）<br>- 工业案例：Amazon应用ItemCF后购买率提升20%</li></ul></li></ul><h3 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h3><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><h5 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h5><h6 id="手写Multi-head-Attention公式"><a href="#手写Multi-head-Attention公式" class="headerlink" title="手写Multi-head Attention公式"></a>手写Multi-head Attention公式</h6><p><strong>计算步骤</strong>：  </p><ol><li>输入序列$X \in \mathbb{R}^{n \times d}$，生成Q/K/V矩阵：<br>$$Q = XW^Q, \ K = XW^K, \ V = XW^V \quad (W^Q, W^K, W^V \in \mathbb{R}^{d \times d_k})$$  </li><li>分割为$h$个头：<br>$$Q_i = Q[:, i \cdot d_k/h : (i+1) \cdot d_k/h] \quad (\text{同理} K_i, V_i)$$  </li><li>单头注意力：<br>$$\text{head}_i = \text{Softmax}\left(\frac{Q_iK_i^T}{\sqrt{d_k/h}}\right)V_i$$  </li><li>多头拼接与线性变换：<br>$$\text{MultiHead}(Q,K,V) = \text{Concat}(\text{head}_1, …, \text{head}_h)W^O$$</li></ol><hr><h6 id="4-Attention的复杂度是多少？"><a href="#4-Attention的复杂度是多少？" class="headerlink" title="4. Attention的复杂度是多少？"></a>4. Attention的复杂度是多少？</h6><p><strong>公式</strong>：$$O(n^2 \cdot d)$$<br><strong>解析</strong>：  </p><ul><li>核心计算来自QK^T矩阵乘法（$n \times d$与$d \times n$）  </li><li>复杂度分解：  <ul><li>QK^T计算：$O(n^2 d)$  </li><li>Softmax与加权求和：$O(n^2)$</li></ul></li><li>总主导项为$O(n^2 d)$</li></ul><hr><h4 id="MAP（最大后验概率）和似然函数有什么关系？"><a href="#MAP（最大后验概率）和似然函数有什么关系？" class="headerlink" title="MAP（最大后验概率）和似然函数有什么关系？"></a>MAP（最大后验概率）和似然函数有什么关系？</h4><p><strong>技术解析</strong>：<br>MAP（最大后验估计）是贝叶斯框架下的参数估计方法，满足：<br>$$\theta_{MAP} = \arg\max_\theta P(\theta|X) = \arg\max_\theta \underbrace{P(X|\theta)}<em>{\text{似然}} \cdot \underbrace{P(\theta)}</em>{\text{先验}}$$<br><strong>关系</strong>：  </p><ul><li>MAP = 极大似然估计（MLE） × 先验概率  </li><li>当先验为均匀分布时，MAP退化为MLE</li></ul><hr><h4 id="什么情况下，MAP的损失函数可以用NMSE来计算？（高斯噪声）"><a href="#什么情况下，MAP的损失函数可以用NMSE来计算？（高斯噪声）" class="headerlink" title="什么情况下，MAP的损失函数可以用NMSE来计算？（高斯噪声）"></a>什么情况下，MAP的损失函数可以用NMSE来计算？（高斯噪声）</h4><p><strong>核心条件</strong>：<br>当数据噪声服从高斯分布且参数先验也为高斯分布时。<br><strong>推导</strong>：  </p><ul><li>高斯噪声下，似然函数为：<br>$$P(X|\theta) \propto \exp\left(-\frac{1}{2\sigma^2}|y - f_\theta(x)|^2\right)$$  </li><li>高斯先验：<br>$$P(\theta) \propto \exp\left(-\frac{1}{2\tau^2}|\theta|^2\right)$$  </li><li>对数后验：<br>$$-\frac{1}{2\sigma^2}\text{MSE} - \frac{1}{2\tau^2}|\theta|^2 + \text{const}$$<br>此时优化目标等价于正则化MSE（NMSE）</li></ul><hr><hr><h4 id="GBDT-vs-Bagging"><a href="#GBDT-vs-Bagging" class="headerlink" title="GBDT vs Bagging"></a>GBDT vs Bagging</h4><p><strong>核心区别</strong>：  </p><table><thead><tr><th></th><th>GBDT</th><th>Bagging</th></tr></thead><tbody><tr><td>基学习器关系</td><td>串行训练，依赖残差</td><td>并行训练，相互独立</td></tr><tr><td>样本权重</td><td>动态调整（错误样本权重增加）</td><td>均匀采样（Bootstrap）</td></tr><tr><td>方差-偏差平衡</td><td>主要降低偏差</td><td>主要降低方差</td></tr><tr><td>典型算法</td><td>XGBoost, LightGBM</td><td>Random Forest</td></tr></tbody></table><hr><h4 id="XGBoost参数调整思路"><a href="#XGBoost参数调整思路" class="headerlink" title="XGBoost参数调整思路"></a>XGBoost参数调整思路</h4><p><strong>调参优先级</strong>：  </p><ol><li><strong>学习率</strong>（<code>learning_rate</code>）：0.05~0.3  </li><li><strong>树深</strong>（<code>max_depth</code>）：3~8  </li><li><strong>正则化</strong>（<code>lambda</code>, <code>alpha</code>）：0.1~10  </li><li><strong>采样率</strong>（<code>subsample</code>, <code>colsample_bytree</code>）：0.6~1.0</li></ol><p><strong>示例参数组合</strong>：  </p><pre class=" language-python"><code class="language-python">params <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'objective'</span><span class="token punctuation">:</span> <span class="token string">'reg:squarederror'</span><span class="token punctuation">,</span>    <span class="token string">'learning_rate'</span><span class="token punctuation">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span>    <span class="token string">'max_depth'</span><span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span>    <span class="token string">'subsample'</span><span class="token punctuation">:</span> <span class="token number">0.8</span><span class="token punctuation">,</span>    <span class="token string">'colsample_bytree'</span><span class="token punctuation">:</span> <span class="token number">0.8</span><span class="token punctuation">,</span>    <span class="token string">'reg_lambda'</span><span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">}</span></code></pre><h4 id="Boosting-Bagging-Stacking"><a href="#Boosting-Bagging-Stacking" class="headerlink" title="Boosting, Bagging, Stacking"></a>Boosting, Bagging, Stacking</h4><p>以上三种都是集成学习，其核心是分层模型融合：</p><p><strong>基模型（Base Models</strong>：多个不同算法（如SVM、决策树、神经网络）独立训练。<br><strong>元模型（Meta-Model</strong>：以基模型的预测结果为输入，训练一个最终模型（如逻辑回归）。<br><strong>Boosting</strong><br>通过顺序训练基学习器，每个基学习器专注于纠正前一个模型的错误。<br>代表算法：AdaBoost、GBDT、XGBoost、LightGBM、CatBoost。<br><strong>Bagging</strong></p><p>通过并行训练多个基学习器，每个基学习器在随机采样子集上训练，最终通过投票或平均得到结果。<br>代表算法：随机森林（Random Forest）、ExtraTrees。<br><strong>Stacking</strong><br>通过分层模型融合：第一层训练多个异构基学习器，第二层用元模型（Meta-Model）组合它们的输出。<br>常见用法：基模型为 SVM、决策树、KNN，元模型为线性回归或逻辑回归。</p><h4 id="XGBoost相比GDBT提升在哪里"><a href="#XGBoost相比GDBT提升在哪里" class="headerlink" title="XGBoost相比GDBT提升在哪里"></a>XGBoost相比GDBT提升在哪里</h4><h4 id="双塔模型"><a href="#双塔模型" class="headerlink" title="双塔模型"></a>双塔模型</h4><p>分为用户塔和物品塔， 用户塔对用户id和特征做embedding获得用户向量（每次召回时，在线算用户a的向量），物品塔对物品id和特征做embedding获得物品向量（物品向量会提前算好，存在数据库中，每次召回时，都可以在数据库中查找）。通过对用户向量和物品向量做内积/求余弦相似度，获得的结果即模型输出。<br>每次召回时，将用户a的向量和物品向量数据库中的所有向量进行相似度计算，获得k-top向量，作为召回结果。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 八股 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux实操记录</title>
      <link href="/2023/12/16/linux-shi-cao-ji-lu/"/>
      <url>/2023/12/16/linux-shi-cao-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="环境变量修改"><a href="#环境变量修改" class="headerlink" title="环境变量修改"></a>环境变量修改</h3><p>修改配置文件</p><pre class=" language-bash"><code class="language-bash">vim /etc/profile</code></pre><p>重启文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> /etc/profile</code></pre><pre class=" language-bash"><code class="language-bash">vim ~/.bashrc</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> ~/.bashrc</code></pre><p>添加环境变量</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/your/path/to/add</code></pre><p>例如</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> JAVA_HOME<span class="token operator">=</span>/usr/lib/jvm/java-8-openjdk-amd64<span class="token function">export</span> HADOOP_HOME<span class="token operator">=</span>/usr/local/hadoop<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$HADOOP_HOME</span>/bin</code></pre><h2 id="Anaconda配置"><a href="#Anaconda配置" class="headerlink" title="Anaconda配置"></a>Anaconda配置</h2><h3 id="jupyter使用"><a href="#jupyter使用" class="headerlink" title="jupyter使用"></a>jupyter使用</h3><h4 id="远程访问配置"><a href="#远程访问配置" class="headerlink" title="远程访问配置"></a>远程访问配置</h4><ol><li>生成配置文件</li></ol><pre class=" language-bash"><code class="language-bash">jupyter notebook --generate-config</code></pre><ol start="2"><li>密钥生成</li></ol><pre class=" language-bash"><code class="language-bash">ipython</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> notebook<span class="token punctuation">.</span>auth <span class="token keyword">import</span> passwdpasswd<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="3"><li>按照要求输入密码，之后会生成一串加密后的密文，复制密文，quit()</li></ol><pre class=" language-bash"><code class="language-bash">vim ~/.jupyter/jupyter_notebook_config.py</code></pre><p>ESC:$进入文件末尾，输入</p><pre class=" language-txt"><code class="language-txt">c.ServerApp.ip = '*'c.ServerApp.password = '复制的密文'c.ServerApp.open_browser = Falsec.ServerApp.port = 8888c.ServerApp.allow_remote_access = Truec.ServerApp.allow_root = True</code></pre><p>注意此处设置的jupyter端口为8888，要注意使用的阿里云服务器安全组设置，8888是否是可用端口<br>4. 打开jupyter notebook</p><pre class=" language-bash"><code class="language-bash">jupyter notebook</code></pre><ol start="5"><li>在本机端cmd窗口输入</li></ol><pre class=" language-cmd"><code class="language-cmd">ssh -L [本机的端口号]:localhost:[服务器的jupyter notebook预留端口号] [服务器名称]@[服务器ip地址] -p [服务器端口号]ssh -L 5005:localhost:8888 root@172.18.xxx.xxx -p 22</code></pre><ol start="6"><li>打开浏览器输入 localhost:5005即可</li></ol><h2 id="基于docker的Hadoop集群搭建"><a href="#基于docker的Hadoop集群搭建" class="headerlink" title="基于docker的Hadoop集群搭建"></a>基于docker的Hadoop集群搭建</h2><h3 id="伪分布式（单节点Hadoop集群搭建）"><a href="#伪分布式（单节点Hadoop集群搭建）" class="headerlink" title="伪分布式（单节点Hadoop集群搭建）"></a>伪分布式（单节点Hadoop集群搭建）</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention机制学习</title>
      <link href="/2023/11/06/attention-ji-zhi-xue-xi/"/>
      <url>/2023/11/06/attention-ji-zhi-xue-xi/</url>
      
        <content type="html"><![CDATA[<ol><li>Encoder-Decoder机制</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Attention </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人机学习笔记</title>
      <link href="/2023/10/12/wu-ren-ji-xue-xi-bi-ji/"/>
      <url>/2023/10/12/wu-ren-ji-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>参考课程<a href="https://www.coursera.org/learn/robotics-flight">Robotics: Aerial Robotics</a></p><h2 id="简介四旋翼"><a href="#简介四旋翼" class="headerlink" title="简介四旋翼"></a>简介四旋翼</h2><p>以对于四旋翼而言,当观察马达1与3，以及马达2与4时，他们分别转向不同的方向。</p><p>所以事实上，如果你观察表示旋转方向的箭头时， Omega 1与Omega 3是逆时针方向，当从顶部观察时。 而Omega 2与Omega 4是逆时针方向， 当从底部观察时。<br><img src="/img/posts/UAV/course00.jpg"></p><p>当两边的旋翼转速不一样时，例如左边比右边转速更快，会使得无人机转向右边<br><img src="/img/posts/UAV/course01.jpg"><br><img src="/img/posts/UAV/course02.jpg"></p><p><strong>如何实现无人机的移动？</strong><br>如果是向前移动，只需要让无人机向前倾斜。<br>你真正需要做的是使飞行器向前方倾斜， 这使得飞行器向前加速。 但是当你接近目标时，你希望使飞行器<strong>停下来</strong>。 为此，你需要<strong>向反方向倾斜</strong>。 产生一个相反推力使其在接近目标时减速。 然后你使它反向倾斜以恢复到平衡状态。</p><h3 id="UAV的关键组成"><a href="#UAV的关键组成" class="headerlink" title="UAV的关键组成"></a>UAV的关键组成</h3><p><strong>State Estimate</strong><br>指车辆估计其位置 、方向和速度的能力。 换句话说，位置和方向的变化率。<br>当在一些无GPS、无运动扑捉相机 的条件下，如何实现导航？<br><img src="/img/posts/UAV/course03.jpg" alt="假设有三个柱子，假定机器人有传感器可以测量障碍，机器人到主子的距离分别为d1,d2,d3"></p><p>SLAM建图，尝试描述delta x和x1,y1,x2,y2,x3,y3。假定现在的距离估计d1‘，d2‘与d3‘ 不同于原始的深度估计d1，d2与d3。 所以我们需要自问的问题是，对于机器人是否可能 同时估计柱子的位置与位移delta x。<br><img src="/img/posts/UAV/course05.jpg" alt="实验室所使用无人机"></p><p><strong>Control</strong><br>根据对当前状态的估计，车辆必须能够计算出需要发送到电机或转子的命令，并让它们以适当的速度旋转以实现所需的动作。</p><p><strong>Mapping</strong><br>车辆必须具备一定的基本能力来绘制其环境地图。 如果它不知道周围的环境是什么样子， 那么它就无法推理这种环境并规划在这种环境中的安全轨迹。</p><p><strong>Planning</strong><br>最后，车辆必须能够计算出如何绕过一组障碍物并到达目的地的轨迹。</p><h2 id="四旋翼的能量和系统设计"><a href="#四旋翼的能量和系统设计" class="headerlink" title="四旋翼的能量和系统设计"></a>四旋翼的能量和系统设计</h2><p>推力与电机RPMs（转速）或角速度的曲线是一个近似的二次方程。<br>每次电机旋转，同样存在阻力需要电机去克服，阻力的瞬时关系也是二次方程<br><img src="/img/posts/UAV/course06.jpg"><br>给定某运行速度ω0，相应地， 该运行速度会产生一个阻力矩， 且每个转子都要克服相应的阻力矩。而这里就是引入电机的时候了， 通过调整电机的尺寸， 从而，电机可产生扭矩来克服前述的阻力矩。因此，当四旋翼处于悬停状态时， 转子通过转速补偿自身的重力。即，使用重量可以确定每个转子的运行速度。 这反过来给出需要应用在每一个电机上的扭矩大小。</p><p><img src="/img/posts/UAV/course07.jpg"></p><p>四旋翼旋转产生力矩，当产生的力矩与重力抵消时，悬停。<br><strong>如何控制UAV的高度</strong></p><p><img src="/img/posts/UAV/course08.jpg"><br>State:x<br>Input:u<br>输入函数 u(t)<br>轨迹函数 $x^{des}(t)$ </p><p>误差：e(t) = $x^{des}(t)$ - x(t)也就是预测轨迹与实际轨迹的误差。我们要尽可能消差为0<br><img src="/img/posts/UAV/course09.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> UAV轨迹规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE+AirSim仿真UAV</title>
      <link href="/2023/10/09/ue-airsim-fang-zhen-uav/"/>
      <url>/2023/10/09/ue-airsim-fang-zhen-uav/</url>
      
        <content type="html"><![CDATA[<p>参考视频<a href="https://www.bilibili.com/video/BV1wz4y1i7sW/?spm_id_from=333.999.0.0">开源无人机模拟和GIS监视器UE+AirSim</a></p><p><a href="https://www.bilibili.com/video/BV15u411C7pM/?spm_id_from=333.788.recommend_more_video.4&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">使用深度强化学习的无人机语义线索主动路径感知</a></p><h2 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h2><ol><li>下载UE，直接<a href="https://www.unrealengine.com/zh-CN/">官网</a>下载即可</li><li>安装VS Studio2022注意需要是2022，之前尝试了2017，在配置AirSim时报错</li><li>VS Studio2022需要配置C++和Windows10 SDK 10.0.19041的桌面开发</li><li>AirSim 配置:在自定义AirSim目录下</li></ol><pre class=" language-cmd"><code class="language-cmd">git clone git@github.com:microsoft/AirSim.git</code></pre><ol start="5"><li>build<br>从Vs Studio的工具-&gt;命令行 进入AirSim目录</li></ol><pre class=" language-cmd"><code class="language-cmd">cd AirSim\Unreal\Environments\Blocksbuild.cmd</code></pre><p>如果不成功就多试几次<br>6. 设置block为启动项<br><img src="/img/posts/UAV/block_startup.jpg" alt="设置block为启动项"><br>7.打开UE启动</p>]]></content>
      
      
      <categories>
          
          <category> UAV轨迹规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4 </tag>
            
            <tag> UAV轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocos开发记录</title>
      <link href="/2023/08/08/cocos-kai-fa-ji-lu/"/>
      <url>/2023/08/08/cocos-kai-fa-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="碰撞分组"><a href="#碰撞分组" class="headerlink" title="碰撞分组"></a>碰撞分组</h2><p><a href="https://docs.cocos.com/creator/manual/zh/physics/physics-group-mask.html?h=%E6%8E%A9%E7%A0%81">碰撞与分组</a><br>分组和掩码是物体之间能否进行物理碰撞检测的必要条件。分组可以简单的理解为一个碰撞对象所处的分组，掩码可以简单的理解为该碰撞对象需要与哪些分组对象进行碰撞<br>可以通过直接在项目设置 面板进行设置，位置为 菜单栏 =&gt; 项目 =&gt; 项目设置 进行设置</p><p><img src="/img/posts/GameDeve/CocosPhysicsGroupSetting.jpg" alt="project setting"></p><p>在rigidbody处进行设置group<br><img src="/img/posts/GameDeve/CocosgGoupSetting.jpg" alt="group setting"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cocos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经纬恒润实习面经</title>
      <link href="/2023/04/19/jing-wei-heng-run-shi-xi-mian-jing/"/>
      <url>/2023/04/19/jing-wei-heng-run-shi-xi-mian-jing/</url>
      
        <content type="html"><![CDATA[<p>经纬恒润测开实习</p><ol><li>自我介绍</li><li>根据项目问了下测试流程和测试方法（答：黑盒，白盒，还有在项目中的具体实现，但这一块组织的不是太好，可以有时间再多看一些）</li><li>登录界面中错误的用户名和正确的用户名属于黑盒测试中的什么方法</li><li>http和https的区别</li><li>OSI七层模型是什么</li><li>Http属于七层模型中的哪一层</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试八股--操作系统</title>
      <link href="/2023/04/18/mian-shi-ba-gu-cao-zuo-xi-tong/"/>
      <url>/2023/04/18/mian-shi-ba-gu-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p><strong>概念</strong><br><strong>进程是计算机中正在运行的程序</strong>，是操作系统进行资源分配和调度的基本单位。每个进程都有自己的地址空间和数据栈，不同进程之间互相独立。</p><p><strong>线程是进程中的一个执行单元</strong>，是操作系统进行调度的基本单位。在一个进程中可以有多个线程，它们共享进程的地址空间和数据栈，因此可以共享数据和通信。<br>特点</p><p>进程有独立的地址空间，各进程之间互相独立，彼此隔离。进程之间通信需要借助操作系统提供的IPC机制。</p><p>线程共享进程的地址空间和数据栈，因此线程之间的通信比进程之间的通信更快捷、方便。<br>区别</p><ol><li>进程之间是互相独立的，线程之间是共享进程的资源的。</li><li>进程拥有独立的地址空间，而线程共享所在进程的地址空间。</li><li>进程拥有独立的堆和栈，线程共享所在进程的堆和栈。</li><li>进程之间通信需要借助操作系统提供的IPC机制，而线程之间通可以直接通过共享内存、消息队列、信号量等机制实现。</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>原理</p><p>多线程就是在一个进程中创建多个线程来并发执行任务，可以提高系统的资源利用率和响应速度。多线程可以通过操作系统提供的线程库来实现，例如POSIX线程库（pthread）。<br><strong>如何实现同步</strong></p><p>多线程的实现需要考虑到线程间的同步问题。同步是指在多线程的环境中，为了避免多个线程同时访问共享的资源而引发的数据不一致、死锁等问题。一些常见的同步机制包括：</p><p><strong>互斥锁</strong>：多个线程同时只有一个线程可以访问共享资源，其他需要等待。互斥锁可以保证在任意时刻只有一个线程访问临界从而避免数据不一致的问题。</p><p><strong>信号量</strong>：可以用来控制多个线程的并发访问。信号量可以表示的可用数量，当某个线程需要访问共享资源时，需要申请信号如果信号量的值大于0，则可以访问资源，否则需要等待。</p><p><strong>条件变量</strong>：可以用来实现线程之间的通信。条件变量提供了一待/通知机制，当条件不满足时，线程可以等待，当条件满足线程可以被通知并继续执行。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指多个进程或线程<strong>因竞争系统资源而陷入一种互相等待的状态，导致所有进程或线程都无法继续执行下去</strong>。这种状态被称为死锁状态。<br>条件</p><p>死锁发生需要满足以下四个条件：</p><p><strong>互斥条件</strong>：一个资源只能被一个进程或线程占用，其他进程或线程需要等待。<br><strong>持有和等待条件</strong>：一个进程或线程已经持有了一个资源，但还需要另外一个资源才能继续执行，而资源已被其他进程或线程占用。<br><strong>不可剥夺条件：</strong>进程或线程持有的资源不能被其他进程或线程强制剥夺。<br><strong>循环等待条件</strong>：多个进程或线程之间形成一个环路，每个进程或线程都在等待下一个进程或线程持的资源。</p><p>要避免死锁，需要破坏以上四个条件之一，例如：</p><p>通过加锁顺序来避免循环等待。<br>通过资源预分配和资源剥夺来避免持有和等待条件。<br>通过资源共享和剥夺来避免不可剥夺条件。<br>在实际编程中，避免死锁是一项非常重要的任务。对于多线程程序，需要仔细设计和管理线程之间的同步，避免出现死锁和其他线程安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用指南</title>
      <link href="/2023/04/18/git-shi-yong-zhi-nan/"/>
      <url>/2023/04/18/git-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/bjbz_cxy/article/details/116703787?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168178388816800182174092%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168178388816800182174092&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116703787-null-null.142%5Ev84%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=git%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">git命令大全</a></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>多人合作写一个东西，先进行clone<br>git clone 仓库地址 </p><p>修改或者添加后用下面操作进行上传，这样会减少上传时出现错误。</p><p>1.把需要上传的文件夹变成git可管理的文件；</p><p>git init</p><p>2.将本地文件添加到暂存区；</p><p>git add .</p><p>3.将暂存区文件提交到主分支（master）上；</p><p>git commit -m’对修改过的代码的描述’</p><p>4.添加你要上传到的远程仓库；</p><p>git remote add origin 仓库地址</p><p>5.进行初始化推送；</p><p>git push -u origin master或git push origin master</p><p>6.如果在第五步后报错那就先git pull –rebase origin master同步远程仓库再进行第五步推送。</p><h3 id="配置与初始化"><a href="#配置与初始化" class="headerlink" title="配置与初始化"></a>配置与初始化</h3><p>初次使用git需要设置你的用户名以及邮箱，这将作为当前机器git的标识，如果你用它来下载远程仓库一些需要登录权限的仓库会要求登录，git默认使用配置邮箱以及用户名登入，但会要求你手动输入密码<br>用户名设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"你的用户名"</span></code></pre><p>邮箱设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.email <span class="token string">"你的邮箱"</span></code></pre><p>使用git init初始化当前仓库，可以用ls-ah查看.git的隐藏目录</p><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><blockquote><p>add: 将文件添加到缓存区<br> commit: 提交到本地仓库</p></blockquote><p>git中有工作区与缓存区的概念：<br><strong>工作区</strong>：工作区就是你当前的工作目录<br><strong>缓存区</strong>：这里存放了你使用git add命令提交的文件描述信息，它位于.git目录下的index文件中<br>这些文件中存储了我们一些提交的缓存数据，git会解析它们，HEAD文件就是指向当前的仓库。最后使用git commit提交时git会提交到当前仓库中，当前的工作区也就成为了最新一次提交的仓库版本。</p><p>例如： 在当前目录下创建一个新的文件 test.txt</p><pre class=" language-linux"><code class="language-linux">touch test.txtgit add test.txt</code></pre><p>这个时候还不算添加到了本地仓库，我们还需要使用git commit命令为其添加修改的描述信息</p><p>注意在使用git commit时我们只需要简单描述一下我们做了什么，不要像写注释那样写一大堆，不然将来在回滚代码或者查看历史版本时，很难审阅。</p><p>我们需要使用-m命令来简写描述我们的信息，如果不使用-m，会调用终端的注释编辑器让你输入描述信息，但是不建议使用</p><pre class=" language-linux"><code class="language-linux">git commit -m "add new file \"test.c\""</code></pre><p>可以用git -amend改写上一次提交的信息，会进入vim</p><pre class=" language-linux"><code class="language-linux">git commit --amend</code></pre><p>如果要将所有的改动文件添加到缓存区:git add –all</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>rm:删除</p><pre class=" language-linux"><code class="language-linux">git rm test.txt</code></pre><p>删除后恢复（仅限 git rm删除后恢复，因为git rm可以将文件先放入缓存区）</p><ol><li>重置缓存区操作</li></ol><pre class=" language-linux"><code class="language-linux">git reset</code></pre><ol start="2"><li>取消操作</li></ol><pre class=" language-linux"><code class="language-linux">git checkout test.txt</code></pre><h3 id="查看历史提交日志、回滚代码仓库"><a href="#查看历史提交日志、回滚代码仓库" class="headerlink" title="查看历史提交日志、回滚代码仓库"></a>查看历史提交日志、回滚代码仓库</h3><p>查看日志：<br>git log</p><p>可以查看到历史版本</p><p>使用以下命令进行回滚</p><pre class=" language-linux"><code class="language-linux">git reset --hard 要回滚的id</code></pre><p>如果只要回滚当前仓库指向的版本，可以直接</p><pre class=" language-linux"><code class="language-linux">git reset --hard HEAD^</code></pre><p>^代表上一个版本的意思，HEAD代表当前仓库的指向，当前HEAD指向master，就代表回滚到master上一次提交的版本</p><pre class=" language-linux"><code class="language-linux">git reset --hard HEAD~3</code></pre><p>后面的<del>3，代表以当前版本为基数，回滚多少次。HEAD</del>3代表回滚master前三个版本’</p><p>查看单个文件的可回滚版本：</p><pre class=" language-linux"><code class="language-linux">git log test.txt</code></pre><p>通用可以使用git reset 回滚</p><h3 id="查看提交后的文件是否有改动"><a href="#查看提交后的文件是否有改动" class="headerlink" title="查看提交后的文件是否有改动"></a>查看提交后的文件是否有改动</h3><pre class=" language-linux"><code class="language-linux">git status</code></pre><h3 id="撤销修改并回到上一次修改的状态"><a href="#撤销修改并回到上一次修改的状态" class="headerlink" title="撤销修改并回到上一次修改的状态"></a>撤销修改并回到上一次修改的状态</h3><blockquote><p>checkout:通常用于切换分支仓库</p></blockquote><p>当我们在工作中修改了一个文件，猛然间发现内容好像改的不对，想重新修改，这个时又不知道自己改了什么代码，想撤销修改，有一个最简单的方法，就是git checkout – file，注意中间要有“–”，checkout这个命令是切换分支的功能，关于它我们后面在细说，你现在只需要知道这个命令加上“–”可以用来将文件切换到最近一次的状态</p><p>注意这个恢复只能恢复到上一次提交的状态，如你刚提交了这个文件到仓库，随后你修改了它，那么使用这个命令只会回到刚刚提交后的那个状态里，不能回到你还没有提交，但修改的状态中。</p><p>这个功能不能一直迭代恢复，如果恢复到了修改前的版本，你想再次回滚回滚到修改前在之前的版本是不行的。</p><pre class=" language-linux"><code class="language-linux">git checkout --test.txt</code></pre><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>git checkoout -b 可以创建分支</p><pre class=" language-linux"><code class="language-linux">git checkout -b newbranch</code></pre><p>创建了新分支newbranch<br>可以用git branch查看当前属于什么分支，也就是head的指向</p><pre class=" language-linux"><code class="language-linux">git branch</code></pre><p>git checkout -b等价于</p><pre class=" language-linux"><code class="language-linux">git branch newbranchgit checkout newbranch</code></pre><p><strong>git branch 如果后面跟着名字则会创建分支，但不会切换</strong><br><strong>git checkout 后面如果是分支名称则切换过去</strong></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre class=" language-linux"><code class="language-linux">git checkout master</code></pre><p>切换回master分支</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>git merge</p><p>例如要合并master和newbranch，可以切换回master，在master下执行合并</p><ol><li>切换</li></ol><pre class=" language-linux"><code class="language-linux">git checkout master</code></pre><ol start="2"><li>合并</li></ol><pre class=" language-linux"><code class="language-linux">git merge newbranch</code></pre><p>这里需要说一点，如果你在任何分支下创建文件，没有提交到仓库，那么它在所有仓库都是可见的，比如你在分支dev中创建了一个文件，没有使用git add和git commit提交，此时你切换到master，这个文件依旧存在的，因为你创建的文件在工作目录中，你切换仓库时git只会更新跟仓库有关的文件，无关的文件依然存放在工作区</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git删除本地分支：git branch -D</p><p>git branch -D 分支名<br>git删除远程分支：git push origin –delete</p><p>注意这里的远程分支名不需要加origin，输入分支名就可以了</p><p>git push origin –delete 远程分支名</p><h3 id="本地仓库关联远程仓库"><a href="#本地仓库关联远程仓库" class="headerlink" title="本地仓库关联远程仓库"></a>本地仓库关联远程仓库</h3><ol><li>git remote add origin<br>例如</li></ol><pre class=" language-linux"><code class="language-linux">git remote add origin git@github.com:beiszhihao/test.git</code></pre><ol start="2"><li>git push推送到远程</li></ol><pre class=" language-linux"><code class="language-linux">git push -u origin master</code></pre><p>push：将本地仓库与远程仓库合并</p><p>-u：将本地仓库分支与远程仓库分支一起合并，就是说将master的分支也提交上去，这样你就可以在远程仓库上看到你在本地仓库的master中创建了多少分支，不加这个参数只将当前的master与远程的合并，没有分支的历史记录，也不能切换分支</p><p>origin：远程仓库的意思，如果这个仓库是远程的那么必须使用这个选项</p><p>master：提交本地matser分支仓库</p><h3 id="git拉取远程仓库到本地，拉取分支，切换远程分支"><a href="#git拉取远程仓库到本地，拉取分支，切换远程分支" class="headerlink" title="git拉取远程仓库到本地，拉取分支，切换远程分支"></a>git拉取远程仓库到本地，拉取分支，切换远程分支</h3><p>git clone拉到本地</p><pre class=" language-linux"><code class="language-linux">git clone git@github.com:xxx.git</code></pre><p>git clone -b 分支名： 拉取知道哪个分支</p><pre class=" language-linux"><code class="language-linux">git clone master git@github.com:xxx.git</code></pre><pre class=" language-linux"><code class="language-linux">git pull origin master</code></pre><p>将远程分支拉到本地并合并</p><h3 id="git提交本地的到远程git-add-git-commit-git-push"><a href="#git提交本地的到远程git-add-git-commit-git-push" class="headerlink" title="git提交本地的到远程git add, git commit, git push"></a>git提交本地的到远程git add, git commit, git push</h3><pre class=" language-linux"><code class="language-linux">git statusgit add --allgit commit -m "add xxx"git push origin master</code></pre><h3 id="git-fetch拉取全部分支"><a href="#git-fetch拉取全部分支" class="headerlink" title="git fetch拉取全部分支"></a>git fetch拉取全部分支</h3><p>也可以git fetch xxx拉取指定分支（但fetch不会合并，pull会合并）</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试八股--测试知识</title>
      <link href="/2023/04/17/mian-shi-ba-gu-ce-shi-zhi-shi/"/>
      <url>/2023/04/17/mian-shi-ba-gu-ce-shi-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="测试的流程"><a href="#测试的流程" class="headerlink" title="测试的流程"></a>测试的流程</h2><p>分析需求（业务、需求分析） -&gt; 制定测试时间进度计划 -&gt; 设计测试用例 -&gt; 执行测试 -&gt; 测试评估</p><h2 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h2><p>界面测试、功能测试、性能测试、安全测试、易用性测试、兼容性测试</p><p><strong>界面测试</strong>: UI是否有错别字，排版是否有错、是否对齐<br><strong>功能测试</strong>: 每个按键是否有响应，依次检查具体功能你是否实现，输入错误信息是否会报错<br><strong>性能测试</strong>：功能操作的响应时间(页面加载时间、多并发测试)<br><strong>安全测试</strong>：敏感信息是否加密<br><strong>易用性测试</strong>：是否便于用户使用（UI、引导）<br><strong>兼容性测试</strong>:在不同版本、不同系统之间的兼容性</p><h2 id="测试用例的具体设计"><a href="#测试用例的具体设计" class="headerlink" title="测试用例的具体设计"></a>测试用例的具体设计</h2><h3 id="黑白盒测试"><a href="#黑白盒测试" class="headerlink" title="黑白盒测试"></a>黑白盒测试</h3><p><strong>白盒测试</strong>：又称结构测试（透明和测试），白盒测试了解程序的内部结构，需要测测试–逻辑覆盖、循环覆盖、基本路径覆盖<br>4种覆盖标准发现错误：<br>1.<strong>语句覆盖</strong>：每条语句至少执行一次。</p><p>2.<strong>判定覆盖</strong>：每个判定的每个分支至少执行一次。</p><p>3.<strong>条件覆盖</strong>：每个判定的每个条件应取到各种可能的值。</p><p>4.判定/条件覆盖同时满足判定覆盖条件覆盖。</p><p>5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。</p><p>6.<strong>路径覆盖</strong>使程序中每一条可能的路径至少执行一次。</p><p><strong>黑盒测试</strong>：（功能测试，未知代码内部逻辑结构）<br><strong>黑盒测试可以发现的错误</strong>：</p><ol><li>功能不正确或遗漏</li><li>界面错误</li><li>输入输出错误</li><li>数据库访问错误</li><li>性能错误</li><li>初始化和终止错误</li></ol><p><strong>黑盒测试方法</strong>：</p><ol><li>边界值分析法:大量的错误是发生在边界值的处理上</li><li>等价类划分：每一个等价类中的一个数据对于揭露程序中的错误都是等效的，所以在每个等价类中选取一个数据作为测试的输入条件，就可以用少量的代表性的测试数据<blockquote><p>划分等价类的方法：下面给出六条确定等价类的原则。</p></blockquote></li><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。</li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类.</li><li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。</li><li>在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。</li><li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。</li><li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类。</li><li>错误猜测法：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。</li><li>因果图法： <strong>考虑输入条件之间的相互组合</strong>，可能会产生一些新的情况. 但要检查输入条件的组合不是一件容易的事情，即使把所有输入条件划分成等价类，他们之间的组合情况也相当多. 因此必须考虑采用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例. 这就需要利用因果图（逻辑模型）。<strong>找出原因与结果，生成因果图，再转换成判定表。</strong></li></ol><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>如postman，selenium</p><h2 id="冒烟测试和回归测试"><a href="#冒烟测试和回归测试" class="headerlink" title="冒烟测试和回归测试"></a>冒烟测试和回归测试</h2><p><strong>冒烟测试</strong>：在<strong>完成一个新版本的开发</strong>后，对软件的基本功能进行测试，由开发任意和测试人员共同执行，是一个测试活动而不是一个测试阶段，也就是说单元测试，集成测试，系统测试中都会有冒烟测试。<br>注重的是对程序的主要功能进行验证，但不会对具体功能进行深入测试。</p><ul><li><strong>执行冒烟测试的前提</strong></li></ul><p>由于冒烟测试是与开发的合同协作，因此有几个合作前提：<br>1.初步了解代码中进行了什么更改。若要理解该更改，必须理解使用的技术<br>2.开发需告知此修改对其他功能是否影响<br>3.更改对各组件的依存关系有何影响</p><p><strong>冒烟测试用例应该包含的内容</strong></p><p>1.业务流的测试：保证正常业务链路的通畅。<br>2.工作流的测试：主要是测试流程流转是否正常，至于流程步骤的表单内容是否正确则不关注。<br>3.关键功能的测试：至少要保证系统运转所需的启动数据以及一些开关控制正常。<br>4.重要基本功能的测试：比如对核心业务有影响的一些增删改等。</p><p><strong>回归测试</strong>：指修改旧代码后（修复一个bug），重新测试以确定新代码没有引入新的错误，一般在进行软件的第二轮测试开始的。</p><h2 id="执行测试的步骤"><a href="#执行测试的步骤" class="headerlink" title="执行测试的步骤"></a>执行测试的步骤</h2><p>搭建环境，冒烟测试，正式测试</p><h2 id="测试评估（撰写测试文档）"><a href="#测试评估（撰写测试文档）" class="headerlink" title="测试评估（撰写测试文档）"></a>测试评估（撰写测试文档）</h2><ol><li>bug编号</li><li>bug的优先级</li><li>bug产生的模块</li><li>bug的大体内容（摘要）</li><li>bug对应的版本</li><li>bug的详细描述，包含具体步骤的文字，截图等</li><li>bug出现时的测试环境</li></ol><h2 id="有一个登陆界面进行测试"><a href="#有一个登陆界面进行测试" class="headerlink" title="有一个登陆界面进行测试"></a>有一个登陆界面进行测试</h2><p>功能性测试用例：</p><ol><li>输入正确的账号密码，点击登录，能够成功登录；</li><li>输入错误的账号密码，点击登录，不能够成功登录；</li><li>不输入账号密码，直接点击登录，不能够成功登录；</li></ol><p>安全性测试用例：</p><ol><li>输入特殊字符，如’&amp;’、’&lt;’、’&gt;’等，检查是否能够正常登录；</li><li>在登录过程中，使用网络抓包工具，检查账号密码是否以明文传输；</li></ol><p>易用性测试用例：</p><ol><li>检查账号和密码框的提示信息是否清晰易懂；</li><li>检查登录按钮是否易于识别，是否有醒目的样式；</li><li>检查在输入账号密码时是否支持自动填充功能，以提高用户的使用体验；</li></ol><p>性能测试用例：</p><ol><li>使用大量并发用户进行登录测试，观察服务器的负载情况；(Jmeter可以)</li><li>对不同的网络环境进行测试，观察登录响应时间；</li></ol><p>兼容性测试用例：</p><ol><li>使用不同的浏览器进行测试，包括 Chrome、Firefox、Safari、IE 等；</li><li>在不同的操作系统下进行测试，包括 Windows、MacOS、Linux 等；</li><li>检查登录页面在不同的分辨率下的表现，确保能够适应各种屏幕尺寸。</li></ol><h2 id="有一个登录页面出现了bug，你怎么排除是前端还是后端的问题？"><a href="#有一个登录页面出现了bug，你怎么排除是前端还是后端的问题？" class="headerlink" title="有一个登录页面出现了bug，你怎么排除是前端还是后端的问题？"></a>有一个登录页面出现了bug，你怎么排除是前端还是后端的问题？</h2><p>我会根据技术文档设置一组正确的传入参数，然后写一个post请求。使用postman发起请求直接调用接口，如果返回值有错误说明就是后端出错，如果返回值正确，说明原页面前端传入参数或者格式有误。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试八股--设计模式</title>
      <link href="/2023/04/17/mian-shi-ba-gu-she-ji-mo-shi/"/>
      <url>/2023/04/17/mian-shi-ba-gu-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>常见的设计模式：单例模式，工厂方法模式，抽象工厂模式，代理模式，装饰器模式，观察者模式，责任链模式</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>特点：<strong>一个类只有一个实例</strong>，且该类能自行创立这个实例，单例类对外提供一个访问该单例的全局访问点</p><p>优点：</p><ol><li>可以保证内存里只有一个实例，减少内存的开销</li><li>避免对资源的多重占用</li></ol><p>缺点：</p><ol><li>单例模式一般没有接口，拓展困难</li></ol><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><p>类一旦加载就创建一个单例，保证在getInstance（）方法前单例就已经存在，这种饿汉式会造成空间浪费</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hungry</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Hungry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Hungry HUNGRY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hungry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Hungry <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> HUNGRY<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>为了避免内存空间的浪费，采用懒汉式，即用到该单例对象的时候再创建</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyMan</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">LazyMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> LazyMan lazyMan<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> LazyMan <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMan<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            lazyMan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazyMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> lazyMan<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                lazyMan<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但这段代码在多线程下会存在问题，会发现结果都不一样，因此，并发情况下，这段代码是有问题的。我们需要进行两端检测，进行“加锁”：synchronized (Singleton.class)。<br>同时，我们使用双重检查锁定模式，即在第一次检查实例是否存在后，使用 synchronized 关键字进行同步，确保只有一个线程能够创建 Singleton 实例。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyMan</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">LazyMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> LazyMan lazyMan<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> LazyMan <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMan<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一层检查，检查是否有引用指向对象，高并发情况下会有多个线程同时进入</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazyMan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//第一层锁，保证只有一个线程进入</span>                <span class="token comment" spellcheck="true">//双重检查，防止多个线程同时进入第一层检查(因单例模式只允许存在一个对象，故在创建对象之前无引用指向对象，所有线程均可进入第一层检查)</span>                <span class="token comment" spellcheck="true">//当某一线程获得锁创建一个LazyMan对象时,即已有引用指向对象，lazyMan不为空，从而保证只会创建一个对象</span>                <span class="token comment" spellcheck="true">//假设没有第二层检查，那么第一个线程创建完对象释放锁后，后面进入对象也会创建对象，会产生多个对象</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>lazyMan<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//第二层检查</span>                    <span class="token comment" spellcheck="true">//synchronized关键字作用为禁止指令重排，保证返回Singleton对象一定在创建对象后</span>                    lazyMan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazyMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这行代码存在的问题，不能保证原子性实际上会执行以下内容：</span>                    <span class="token comment" spellcheck="true">//(1)在堆上开辟空间；(2)属性初始化;(3)引用指向对象</span>                    <span class="token comment" spellcheck="true">//假设以上三个内容为三条单独指令，因指令重排可能会导致执行顺序为1->3->2(正常为1->2->3),当单例模式中存在普通变量需要在构造方法中进行初始化操作时，单线程情况下，顺序重排没有影响；但在多线程情况下，假如线程1执行lazyMan = new LazyMan()语句时先1再3，由于系统调度线程2的原因没来得及执行步骤2，但此时已有引用指向对象也就是lazyMan!=null，故线程2在第一次检查时不满足条件直接返回lazyMan，此时lazyMan为null</span>                    <span class="token comment" spellcheck="true">//synchronized关键字可保证lazyMan = new LazyMan()语句执行顺序为123，因其为非原子性依旧可能存在系统调度问题(即执行步骤时被打断)，但能确保的是只要lazyMan!=0，就表明一定执行了属性初始化操作；而若在步骤3之前被打断，此时lazyMan依旧为null，其他线程可进入第一层检查向下执行创建对象</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> lazyMan<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                lazyMan<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>实例化对象不是用new，用工厂方法替代。将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>用来生产同一等级架构中的任意产品(对于增加新的产品，需要修改已有代码)<br>在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。</p><p>以一个接口，两个实现类，一个工厂，一个测试类为例</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建enemy接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Enemy</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建boss实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Boss</span> <span class="token keyword">implements</span> <span class="token class-name">Enemy</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Boss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建guard实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Guard</span> <span class="token keyword">implements</span> <span class="token class-name">Enemy</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Guard"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Enemy <span class="token function">getEnemy</span><span class="token punctuation">(</span>String enemy<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>enemy<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Boss"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Boss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>enemy<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Guard"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span>  <span class="token keyword">new</span> <span class="token class-name">Guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Enemy p1<span class="token operator">=</span> EnemyFactory<span class="token punctuation">.</span><span class="token function">getEnemy</span><span class="token punctuation">(</span><span class="token string">"Boss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Enemy p2<span class="token operator">=</span> EnemyFactory<span class="token punctuation">.</span><span class="token function">getEnemy</span><span class="token punctuation">(</span><span class="token string">"Guard"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们通过创建一个PhoneFactory类，成功的完成工厂的创建。我们在创建对象时，也就不需要直接创建对象，而是可以通过创建工厂，这样大大的降低了代码的耦合性。<br><strong>但是，静态工厂模式是不能添加数据的</strong>。比如说，我们想添加一个“Slim”敌人类，你不直接修改工厂代码，是不能实现的。所以，就有了第二种的工厂方法模式。</p><h3 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建敌人接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Enemy</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建Boss实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Boss</span> <span class="token keyword">implements</span> <span class="token class-name">Enemy</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Boss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建敌人工厂接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EnemyFactory</span> <span class="token punctuation">{</span>    Enemy <span class="token function">getEnemy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建Boss工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BossFactory</span> <span class="token keyword">implements</span> <span class="token class-name">EnemyFactory</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Phone <span class="token function">getEnemy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Boss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Enemy enemy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BossFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEnemy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enemy<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们创建了敌人工厂接口EnemyFactory，再创建Boss工厂，这样就可以通过BossFactory创建对象。增加新的具体工厂和产品族很方便，比如说，我们想要增加guard，只需要创建一个GuardFactory实现enemy工厂接口，合理的解决的简单工厂模式不能修改代码的缺点。但是，在现实使用中，简单工厂模式占绝大多数。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode101--栈、队列、哈希表</title>
      <link href="/2023/04/12/leetcode101-zhan-dui-lie-ha-xi-biao/"/>
      <url>/2023/04/12/leetcode101-zhan-dui-lie-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=295&amp;tqId=23281&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">两个栈实现队列</a></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode101--二分查找</title>
      <link href="/2023/04/12/leetcode101-er-fen-cha-zhao/"/>
      <url>/2023/04/12/leetcode101-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></h2><p>给定一个&nbsp;n&nbsp;个元素有序的（升序）整型数组&nbsp;nums 和一个目标值&nbsp;target &nbsp;，写一个函数搜索&nbsp;nums&nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>注意二分查找主要是边界的确定 也就是判断是使用while(left &lt; right)还是whie(left &lt;= right),这个时候就要判断时左闭右闭区间还是左闭右开区间</p><h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span>mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//right初值改变</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//while判断条件改变</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//right改变，因为 右开， 不需要mid-1</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// left不变，因为左闭</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试八股--Java</title>
      <link href="/2023/04/11/mian-shi-ba-gu-java/"/>
      <url>/2023/04/11/mian-shi-ba-gu-java/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的特性"><a href="#Java的特性" class="headerlink" title="Java的特性"></a>Java的特性</h2><p><strong>封装</strong>：把一个对象的属性和方法封装起来，为了提高安全性<br><strong>继承</strong>：子类继承父类的方法和熟悉，Java不支持多继承<br><strong>多态</strong>：同一个类型的对象在指向同一个方法，可能出现多种行为 如 Animal cat = new cat</p><p>实现多态：先继承，再重写父类中的方法，最后向上转型</p><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>接口中可以有 default 方法、静态方法，静态方法可通过接口直接调用， default 方法必须通过对象调用。实现接口的类不能继承接口静态方法，接口中可以声明 abstract 方法，此时，abstract 方法跟接口中的普通方法具有相同效果。</p><p>什么时候使用抽象类和接口</p><p><strong>抽象类</strong>：如果你拥有一些方法并且想让它们中的一些有默认实现<br><strong>接口</strong>：如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，可以实现多个接口。因此你就可以使用接口来解决它。<br>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就要改变所有实现了该接口的类</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表：Java中的链表分为单向链表和双向链表两种，它们分别由LinkedList和Node类实现。LinkedList类实现了List接口和Deque接口，内部使用双向链表实现，可以在列表开头和结尾快速添加、删除元素。Node类是Java中的链表节点类，它包含一个指向下一个节点的指针。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈：Java中的栈由Stack类实现，底层使用<strong>数组</strong>实现。Stack类提供了push、pop、peek等方法，可以实现后进先出的操作。栈在实现时通常使用数组或链表，其中使用数组实现的栈需要在容量不足时进行扩容。通常的做法是，<strong>当数组已满时，创建一个新的更大的数组，并将所有元素复制到新数组中。</strong>Java中的Stack类默认使用数组实现，当数组大小不足时会进行扩容，扩容时会将数组大小翻倍。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>Java中的队列由Queue接口实现，它有很多实现类，如LinkedList、ArrayDeque、PriorityQueue等。LinkedList实现了Queue接口，可以当作队列来使用，它使用双向链表实现。ArrayDeque也实现了Queue接口，内部使用数组实现。PriorityQueue是一个优先队列，可以按照元素的优先级进行排序。</p><p>队列：队列在实现时通常使用数组或链表，其中<strong>使用数组实现的队列需要在容量不足时进行扩容。通常的做法与栈类似，当数组已满时，创建一个新的更大的数组，并将所有元素复制到新数组中。</strong>Java中的Queue接口有多种实现，其中ArrayBlockingQueue、PriorityBlockingQueue和LinkedBlockingQueue默认使用数组或链表实现，当数组或链表大小不足时会进行扩容。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>Java中的二叉树有很多实现，最常用的是TreeNode类，它是Java中的二叉树节点类。TreeNode包含一个指向左子节点和右子节点的指针，还包含节点值等信息。Java中的二叉树可以使用递归或循环实现。<br>二叉树通常使用指针或数组实现，其中使用数组实现的二叉树需要在容量不足时进行扩容。通常的做法是，当数组已满时，创建一个新的更大的数组，并将所有元素复制到新数组中。Java中的TreeSet和TreeMap类使用红黑树实现，不需要扩容机制。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Java中的哈希表由HashMap类实现，它使用数组和链表或红黑树实现。HashMap将元素的键映射到数组下标上，然后将元素存储在相应的链表或红黑树上。在哈希表中查找元素时，先根据键找到数组下标，然后再在相应的链表或红黑树上查找元素。</p><p>哈希表在实现时通常使用数组和链表相结合的方式，其中使用数组实现的哈希表需要在容量不足时进行扩容。通常的做法是，创建一个新的更大的数组，并将所有元素重新哈希到新数组中。Java中的HashMap类在默认情况下使用数组和链表相结合的方式实现哈希表，当元素个数超过容量的75%时会进行扩容，扩容时将数组大小翻倍，并将所有元素重新哈希到新数组中。</p><p>使用红黑树实现的哈希表可以通过如下方式进行动态扩容：</p><ol><li>设置一个阈值，当哈希表中元素数量达到该阈值时，进行扩容操作。</li><li>在扩容操作中，创建一个新的红黑树哈希表，其大小为原来的两倍，然后逐个将原来哈希表中的元素重新哈希并插入到新哈希表中。</li><li>插入操作中，先在新哈希表中查找该元素所属的红黑树。</li><li>如果该红黑树为空，则新建一个红黑树，并将元素插入到该树中。</li><li>如果该红黑树已经存在，则直接将元素插入到该树中。</li><li>如果插入后该红黑树中节点数超过了一个预设的阈值，则进行红黑树的平衡操作。</li><li>最后，删除原哈希表中的所有元素，释放原哈希表所占的内存空间。</li></ol><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>如果一个类加载器收到了类加载请求，它不会自己先去加载，而是把请求委托给父类的加载器，父类加载器再委托给父类的父类加载器，直到到达顶层或者某一层的父类加载器无法完成加载任务</p><p>作用：</p><ol><li>通过类加载器之间的优先级关系，避免重复加载</li><li>提高安全性，避免修改java的核心api</li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>byte，boolean: 一个字节 8 bits<br>short，char: 两个字节 16 bits<br>int，float：四个字节 32 bits<br>long，double：八个字节 64 bits</p><h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>Integer是int的包装类，int只是一种数据类型<br>所以Integer必须经过实例化才能使用，Integer实际上是对象的的引用，每次new一个Integer时，是生成一个指向该对象的指针，而int是直接存储数据的值<br>Integer默认null，int 默认0</p><h3 id="String，StringBuilder，StringBuffer的区别"><a href="#String，StringBuilder，StringBuffer的区别" class="headerlink" title="String，StringBuilder，StringBuffer的区别"></a>String，StringBuilder，StringBuffer的区别</h3><p><a href="https://blog.csdn.net/qq_47183158/article/details/123729517">参考</a></p><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>String底层是<strong>通过char类型</strong>的数据实现的，是被 <strong>final</strong> 修饰的类，不能被继承；String实现了 Serializable 和 Comparable 接口，表示String支持序列化和可以比较大小；所以字符串的值创建之后就不可以被修改，具有不可变性。</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token string">"456"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 打印出来的a为456</span></code></pre><p>因为第二次赋值时会生成一个新的对象，a指向新的实例对象，而之前的实例对象如果不再引用会被当作垃圾回收。</p><p>实例化一个String对象时：string a = “123”;此时的a存在字符串<strong>常量池</strong>中，而new String(“123”)会存在<strong>堆中</strong></p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer代表一个<strong>字符序列可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列，但都不会产生新的对象。通过StringBuffer生成的字符串，可以调用toString()方法将其转换为一个String对象。</p><pre class=" language-java"><code class="language-java">StringBuffer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// b打印结果为：123456</span></code></pre><p>且<strong>StringBuffer是线程安全的</strong>：</p><ol><li><p>StringBuffer类中的方法都添加了synchronized关键字，用来保证线程安全。</p></li><li><p>StringBuffer 每次<strong>获取 toString</strong> 都会<strong>直接使用缓存区的 toStringCache 值来构造一个字符串</strong>。StringBuffer 的这个toString 方法仍然是同步的。</p></li></ol><p>而 StringBuilder 则每次都需要<strong>复制一次字符数组</strong>，再构造一个字符串。<br>3. 性能：StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，<strong>所以StringBuilder 的性能要大于 StringBuffer。</strong></p><p>StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，而 StringBuilder 更适合单线程场合。</p><h5 id="StringBuffer的扩容机制"><a href="#StringBuffer的扩容机制" class="headerlink" title="StringBuffer的扩容机制"></a>StringBuffer的扩容机制</h5><p>StringBuffer和StringBuilder都是继承自AbstractStringBuilder，它们两个的区别在于buffer是线程安全的，builder是线程不安全的，前者安全效率低，后者高效不安全。它们的扩容机制也是这样的区别，所以我们只需要分析一个的扩容就可以了，分析buffer，另一个只用把synchronized关键字去掉就是一样的。</p><ol><li>初始容量</li></ol><p>既然是容器，那么是一定会有个初始容量的，目的在于避免在内存中过度占用内存。容器的初始容量有默认和使用构造函数申明两种。</p><p>StringBuffer类可以创建可修改的字符串序列，该类有以下三个改造方法。</p><p>StringBuffer()的初始容量可以容纳16个字符，当该对象的体存放的字符的长度大于16时，实体容量就自动增加StringBuffer对象可以通过length()方法获取实体中存放的符序列长度，通过 capacity()方法来获取当前实体的实际量。</p><p>StringBuffer(int size)可以指定分配给该对象的实体的初容量参数为参数size指定的字符个数。当该对象的实体存放的符序列的长度大于size个字符时，实体的容量就自动的增加。便存放所增加的字符。<br>StringBuffer(String s)可以指定给对象的实体的初始容量参数字符串s的长度额外再加16个字符。当该对象的实体存放字符序列长度大于size个字符时，实体的容量自动的增加，以存放所增加的字符。</p><ol start="2"><li>扩容实现</li></ol><p>在父类AbstractStringBuilder中,底层是一个字符数组来保存字符串的</p><pre class=" language-java"><code class="language-java"><span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>StringBuffer:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">StringBuffer</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>因此扩容其实是，使用append()方法在字符串后面追加值的时候，如果长度超过了该字符串存储空间大小了就就会先进性扩容。<strong>构建新的并且存储空间更大的字符串</strong>，将旧的复制过去。</p><blockquote><p>扩容规则：<br>    先原始容量 * 2 + 2（加2是因为拼接字符串通常末尾都会有个多余的字符）<br>    如果扩容了之后，容量够用，新的容量就为扩容之后的容量。<br>    如果扩容了之后，容量不够用，新的容量就是所需要的容量，即原始字符串长度加上新添加的字符串长度。<br>    扩容完成之后，将原始数组复制到新的容量中，然后将新的字符串添加进去</p></blockquote><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p><strong>StringBuilder</strong>: 也代表可变字符串对象，这点和StringBuffer很相似，但StringBuilder不是线程安全的</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>哈希表是一种以键值key存储数据value的结构，以key作为标识值存储value值；只要输入待查找的key，即可获取其对应的value值。<strong>当按照键值查询元素时，使用相同的hash函数将key转换为数组下标，从数组中按照下标对应的位置获取数据</strong>。它实际上是数组的一种扩展，数组+链表+红黑树。</p><ol><li>JDK8以后hashmap的底层数据结构由数据+链表+红黑树实现<br>2、jdk8以后插入数据采用尾插法。因为引入了树形结构，总是要遍历</li></ol><p><strong>红黑树是一种自平衡的二叉查找树，是一种高效的查找树。</strong></p><p>首先，红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性：</p><ol><li>节点是红色或黑色</li><li>根是黑色</li><li>叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是最底层的空节点（外部节点），下中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点</li><li>红色节点的子节点都是黑色，红色节点的父节点都是黑色，从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点</li><li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li></ol><p><strong>为什么用红黑树不用平衡二叉树：</strong>平衡二叉追求完全平衡，在实际应用中的空间开销较大，读取方面表现优异，但维护代价大。而红黑树不追求完全平衡，性能更优。</p><p><strong>为什么不选择B树和B+树</strong>：B+树比B树更加矮胖，且由于B+树的非叶子节点上不存储数据，在HashMap中数据率较少的情况下，数据会挤在一个节点中，退化成为链表。且B树和B+树主要用于数据存储在磁盘上的场景，而红黑树用于内存排序。</p><p><strong>哈希冲突</strong>：由于映射的范围限制，key取值的可能性大于映射范围，出现两个不同的key映射到同一个位置。解决哈希冲突的常见方法有开放地址法和链表法。<br><strong>开放地址法</strong>：在根据关键字查找哈希之后，如果发现这个地址已经有值了，就不能放在这个地址，否则会覆盖掉之前的映射。可以对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果该地址空着就可以使用；如果超过容器最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。<br><strong>链表法</strong>：对关键字重复的哈希地址，来做一个链表。在很多高级语言的实现当中，都是使用这种方式处理冲突。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>参数化类型–把一种明确的工作推迟到<strong>实际创建对象</strong>时才确定名曲的数据类型<br>如：ArrayList<object> arr = new Arraylist&lt;&gt;()<br>各种泛型类：List，Set，Map<p></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM就是java虚拟机，JVM运行时数据区有<strong>方法区</strong>，<strong>Java堆</strong>、<strong>程序计数器</strong>，<strong>本地方法栈</strong>，<strong>虚拟机栈</strong><br><a href="https://blog.csdn.net/weixin_43122090/article/details/105093777?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168142794216782425193986%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168142794216782425193986&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105093777-null-null.142%5Ev83%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=jvm&amp;spm=1018.2226.3001.4187">参考博客</a></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是所有线程共享的内存区域，它用于存储已被Java虚拟机加载的<strong>类信息、常量、静态变量时编译器编译后的代码</strong>等数据。<br>它有个别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryErro常。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>java堆是java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>。<strong>所有的对象实例以及数组</strong>都要在堆上分配。</p><p>java堆是垃圾收集器管理的主要区域，因此也被成为“GC堆”。从内存回收角度来看java堆可分为：新生代和老生代。</p><p>无论怎么划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步的划分都是为了更好的回收内存，或者更快的分配内存。<br>根据Java虚拟机规范的规定，<strong>java堆可以处于物理上不连续的内存空间中</strong>。当前主流的虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制）。如果堆中没有内存可以完成实例分配，并且<strong>堆也无法再扩展时，将会抛出OutOfMemoryError异常。</strong></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它可以看作是：保存当前线程所正在执行的字节码指令的地址(行号)</p><p>由于Java虚拟机的多线程是通过<strong>线程轮流切换</strong>并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存。<strong>程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。</strong></p><p>可以把它看作线程计数器，由于线程时最小的执行单元，不具备记忆功能，所以当线程A被线程B打断后它会挂起，然后等到线程B执行完成后，从程序计数器中恢复A之前的状态。</p><h4 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h4><p>java虚拟机是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法在执行的同时都会创建一个栈帧</strong>（StaFrame）用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p><p><strong>局部变量表</strong>：是用来存储我们临时8个基本数据类型、对象引用地址、returnAddress类型。（returnAddress中保存的是return后要执行的字节码的指令地址。）</p><p><strong>操作数栈</strong>：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操作，读取我们的代码，进行计算后再放入局部变量表中去</p><p><strong>动态链接</strong>：假如我方法中，有个 service.add()方法，要链接到别的方法中去，这就是动态链接，存储链接的地方</p><p><strong>出口</strong>：出口正常的话就是return 不正常的话就是抛出异常落</p><p><strong>一个方法调用另一个方法，会创建很多栈帧吗？</strong><br>答：会创建。如果一个栈中有动态链接调用别的方法，就会去创建新的栈帧，栈中是由顺序的，一个栈帧调用另一个栈帧，另一个栈帧就会排在调用者下面</p><p><strong>本地方法栈（Native Method Stack）</strong></p><p>本地方法栈很好理解，他很栈很像，只不过方法上带了 native 关键字的栈字<br>它是虚拟机栈为虚拟机执行Java方法（也就是字节码）的服务<br>native关键字的方法是看不到的，必须要去oracle官网去下载才可以看的到，而且native关键字饰的大部分源码都是C和C++的代码。</p><h3 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h3><p><img src="/img/posts/interview/jvm2.jpg"></p><p><strong>直接内存与堆内存的区别</strong>：<br>直接内存申请空间耗费很高的性能，<strong>堆内存申请空间耗费比较低</strong><br><strong>直接内存的IO读写的性能要优于堆内存</strong>，在多次读写操作的情况相差非常明显</p><p>虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般户先进行编译成机器码后执行。</p><p>“虚拟机”是一个相对于“物理机”的概念，<strong>虚拟机的字节码是不能直接在物理机上运行的，需要JVM字节码执行引擎编译成机器码后才可在物理机上执行</strong>。</p><h3 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h3><p>GC主要用于Java<strong>堆</strong>的管理。Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。</p><blockquote><p>什么是内存垃圾？</p></blockquote><p>程序在运行过程中，会产生大量的内存垃圾（<strong>一些没有引用指向的内存对象</strong>都属于内存垃圾，因为这些对象已经无法访问，程序用不了它们了，对程序而言它们已经死亡），为了确保程序运行时的性能，java虚拟机在程序运行的过程中不断地进行自动的垃圾回收（GC）</p><blockquote><p>怎么清理内存垃圾？<br>GC是不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行清楚那个对象，即使程序员能明确地判断出有一块内存已经无用了，是应该回收的，程序员也不能强制垃圾收集器回收该内存块。程序员唯一能做的就是通过调用System.gc 方法来”建议”执行垃圾收集器，但是他是否执行，什么时候执行却都是不可知的。这也是垃圾收集器的最主要的缺点。当然相对于它给程序员带来的巨大方便性而言，这个缺点是瑕不掩瑜的。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>lijie<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 手动回收垃圾</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// gc回收垃圾之前调用</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"gc回收垃圾之前调用的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h3><pre class=" language-java"><code class="language-java">#常用的设置<span class="token operator">-</span>Xms：初始堆大小，JVM 启动的时候，给定堆空间大小。 <span class="token operator">-</span>Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。 <span class="token operator">-</span>Xmn：设置堆中年轻代大小。整个堆大小<span class="token operator">=</span>年轻代大小<span class="token operator">+</span>年老代大小<span class="token operator">+</span>持久代大小。 <span class="token operator">-</span>XX<span class="token operator">:</span>NewSize<span class="token operator">=</span>n 设置年轻代初始化大小大小 <span class="token operator">-</span>XX<span class="token operator">:</span>MaxNewSize<span class="token operator">=</span>n 设置年轻代最大值<span class="token operator">-</span>XX<span class="token operator">:</span>NewRatio<span class="token operator">=</span>n 设置年轻代和年老代的比值。如<span class="token operator">:</span> <span class="token operator">-</span>XX<span class="token operator">:</span>NewRatio<span class="token operator">=</span><span class="token number">3</span>，表示年轻代与年老代比值为 <span class="token number">1</span>：<span class="token number">3</span>，年轻代占整个年轻代<span class="token operator">+</span>年老代和的 <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token operator">-</span>XX<span class="token operator">:</span>SurvivorRatio<span class="token operator">=</span>n 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。<span class="token number">8</span>表示两个Survivor <span class="token operator">:</span>eden<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">8</span> <span class="token punctuation">,</span>即一个Survivor占年轻代的<span class="token number">1</span><span class="token operator">/</span><span class="token number">10</span>，默认就为<span class="token number">8</span><span class="token operator">-</span>Xss：设置每个线程的堆栈大小。JDK5后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。<span class="token operator">-</span>XX<span class="token operator">:</span>ThreadStackSize<span class="token operator">=</span>n 线程堆栈大小<span class="token operator">-</span>XX<span class="token operator">:</span>PermSize<span class="token operator">=</span>n 设置持久代初始值<span class="token operator">-</span>XX<span class="token operator">:</span>MaxPermSize<span class="token operator">=</span>n 设置持久代大小 <span class="token operator">-</span>XX<span class="token operator">:</span>MaxTenuringThreshold<span class="token operator">=</span>n 设置年轻带垃圾对象最大年龄。如果设置为 <span class="token number">0</span> 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。#下面是一些不常用的<span class="token operator">-</span>XX<span class="token operator">:</span>LargePageSizeInBytes<span class="token operator">=</span>n 设置堆内存的内存页大小<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseFastAccessorMethods 优化原始类型的getter方法性能<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>DisableExplicitGC 禁止在运行期显式地调用System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，默认启用<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>AggressiveOpts 是否启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等，jdk6纸之后默认启动<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseBiasedLocking 是否启用偏向锁，JDK6默认启用<span class="token operator">-</span>Xnoclassgc 是否禁用垃圾回收<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseThreadPriorities 使用本地线程的优先级，默认启用等等等<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="JVM调优总结"><a href="#JVM调优总结" class="headerlink" title="JVM调优总结"></a>JVM调优总结</h3><ol><li>在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。</li><li>初始堆值和最大堆内存内存越大，吞吐量就越高，但是也要根据自己电脑(服务器)的实际内存来比较。</li><li>最好使用并行收集器,因为并行收集器速度比串行吞吐量高，速度快。当然，服务器一定要是多线程的</li><li>设置堆内存新生代的比例和老年代的比例最好为1:2或者1:3。默认的就是1:2<br>5.减少GC对老年代的回收。设置生代带垃圾对象最大年龄，进量不要有大量连续内存空间的java对象，因为会直接到老年代，内存不够就会执行GC</li></ol><h2 id="java的四种引用类型"><a href="#java的四种引用类型" class="headerlink" title="java的四种引用类型"></a>java的四种引用类型</h2><p>强引用: 在程序内存不足(OOM)的时候也不会被回收 -&gt; 是创建一个对象，并把这个对象赋给一个引用遍历<br>软引用：只有在OOM的时候，要迫切释放空间的时候，JVM才会释放软引用的对象 -&gt; 软引用可实现内存敏感的告诉缓存，比如网页缓存与图片缓存，使用软引用能防止内存泄漏，增强程序的鲁棒性<br>弱引用：JVM发现了弱引用就会回收。<br>虚引用：和弱引用差不多，但在被回收前胡放入referenceQueue中</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p><strong>深拷贝</strong>: 深拷贝是一个独立的对象拷贝，拷贝所有的属性的同时，创建自己的内存空间，对深拷贝对象的引用指向该拷贝对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> Address address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Address address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        person<span class="token punctuation">.</span>address <span class="token operator">=</span> <span class="token punctuation">(</span>Address<span class="token punctuation">)</span> address<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> person<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String city<span class="token punctuation">;</span>    <span class="token keyword">public</span> String street<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Address</span><span class="token punctuation">(</span>String city<span class="token punctuation">,</span> String street<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>street <span class="token operator">=</span> street<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>浅拷贝</strong>: 被复制的对象的所有变量都与原来对象的值相同，但所有对浅拷贝对象的引用仍然指向原来的对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> Address address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Address address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><p><strong>重写</strong>：子类重写父类的方法<br><strong>重载</strong>：同名方法，不同的参数类型、参数数量、参数顺序</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final修饰的类不可以被继承，但可以继承其他类<br>final修改的方法不可以被覆盖，但可以被继承<br>final修饰的基本数据类型是常量</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static方法：静态方法不能访问类的非静态成员变量和非静态成员方法<br>static变量：静态变量被所有的对象所共享，在内存中只有一个父辈，在创建对象时被初始化</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><strong>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</strong></p><p><a href="https://blog.csdn.net/didi1663478999/article/details/98523122">示例</a><br>在多线程中，volatile和synchronized都起到非常重要的作用，synchronized是通过加锁来实现线程的安全性。而volatile的主要作用是在多处理器开发中保证共享变量对于多线程的可见性。<br>可见性的意思是，<strong>当一个线程修改一个共享变量时，另外一个线程能读取到修改以后的值</strong><br>volatile时乐观锁（认为自己使用数据时不会有别的线程修改数据，因此不会添加锁），适合读取操作频繁的场景</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronied主要用于解决多线程的资源同步性，对于普通同步方法–锁是当前实例对象，对于静态同步方法，锁是当前类的class对象。对于同步方法块，所是synchronized括号里配置的对象。<br>synchronized是所著当前变量，只有当前线程可以访问该变量，其他线程会block<br>voliate仅仅能在变量级别使用，而synchronzed可以在变量、方法和类级别使用<br>volatile进能实现变量的修改可见性，不能保证原子性，而synchronized可以保证变量的修改可见性和原子性<br>synchronized和lock都是悲观锁，认为在自己写入数据时会有别的线程修改数据，适合写入操作频繁的场景</p><p>synchronized 在字节码层被映射成两个指令：monitorenter 和 monitorexit，当一个线程遇到 monitorenter 指令时，会尝试去获取锁，如果获取成功，锁的数量 +1，（因为synchronized是一个可重入锁，需要使用锁计数来判断锁的情况），如果没有获取到锁，就会阻塞；当线程遇到 monitorexit 指令时，锁计数 -1，当计数器为 0 时，线程释放锁；如果线程遇到异常，也会释放锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">APP</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。<br>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p><h3 id="如何在Java中实现线程？"><a href="#如何在Java中实现线程？" class="headerlink" title="如何在Java中实现线程？"></a>如何在Java中实现线程？</h3><p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程<br>调用runnable接口更好</p><h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h3><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程</p><h3 id="创建线程池-1"><a href="#创建线程池-1" class="headerlink" title="创建线程池"></a>创建线程池</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><strong>原理</strong>：  提交一个任务到线程池中，线程池的处理流程如下：</p><ol><li>判断线程池里的<strong>核心线程是否都在执行任务</strong>，如果不是（核心线程空闲或者还有核心线程没有被建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li><li>线程池判断<strong>工作队列是否已满</strong>，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。果工作队列满了，则进入下个流程。</li><li>判断线程池里的线程<strong>是否都处于工作状态</strong>，如果没有，则创建一个新的工作线程来执行任务。如果经满了，则交给饱和策略来处理这个任务。<br>采用ThreadPoolExecutor创建的优点：<br>可以实时获取线程池内线程的各种状态<br>可以动态调整线程池大小</li></ol><p>ThreadPoolExecutor参数：</p><p>corePoolSize 核心线程数大小，当线程数 &lt; corePoolSize ，会创建线程执行 runnable<br>maximumPoolSize 最大线程数， 当线程数 &gt;= corePoolSize的时候，会把 runnable 放入workQueue中<br>keepAliveTime 保持存活时间，当线程数大于corePoolSize的空闲线程能保持的最大时间。<br>unit 时间单位<br>workQueue 保存任务的阻塞队列<br>threadFactory 创建线程的工厂</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>pool<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">long</span> currentTimeMillis <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 构造一个线程池</span>        ThreadPoolExecutor threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                corePoolSize <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>                maximumPoolSize <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span>                keepAliveTime <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                String task <span class="token operator">=</span> <span class="token string">"task="</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建任务并提交到线程池中："</span> <span class="token operator">+</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//等待所有线程执行完毕当前任务。</span>            threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> loop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//等待所有线程执行完毕当前任务结束，等待2秒</span>                loop <span class="token operator">=</span> <span class="token operator">!</span>threadPool<span class="token punctuation">.</span><span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTimeMillis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span>  <span class="token keyword">class</span> <span class="token class-name">ThreadPoolTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>     <span class="token keyword">private</span> Object attachData<span class="token punctuation">;</span>    <span class="token function">ThreadPoolTask</span><span class="token punctuation">(</span>Object tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>attachData <span class="token operator">=</span> tasks<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行任务："</span> <span class="token operator">+</span> attachData <span class="token operator">+</span> <span class="token string">"任务，使用的线程池，线程名称："</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        attachData <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre></object></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目问答--分布式订票系统项目</title>
      <link href="/2023/04/11/xiang-mu-wen-da-fen-bu-shi-ding-piao-xi-tong-xiang-mu/"/>
      <url>/2023/04/11/xiang-mu-wen-da-fen-bu-shi-ding-piao-xi-tong-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="界面测试"><a href="#界面测试" class="headerlink" title="界面测试"></a>界面测试</h2><p>检查每个界面的UI、字号、对齐等</p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><ol><li><p>用户注册和登录功能测试用例<br>检查用户注册时输入的用户名、密码等信息是否合法；<br>检查用户登录时输入的用户名、密码是否正确；<br>检查用户登录后是否可以正常进入系统；<br>检查用户登录后是否可以退出系统；<br>检查用户登录后是否可以修改个人信息；<br>检查用户登录后是否可以查看订单历史记录。</p></li><li><p>票务查询和购买功能测试用例<br>检查用户可以根据起点站和终点站查询车票；<br>检查用户可以选择购买某个车次的车票；<br>检查用户可以选择座位类型和数量；<br>检查用户购买车票后系统能够正确扣除相应的余额；<br>检查用户购买车票后系统能够正确更新余票数量。</p></li><li><p>订单管理功能测试用例<br>检查用户可以查看当前的订单列表；<br>检查用户可以查看某个订单的详细信息；<br>检查用户可以取消某个未出行的订单；<br>检查用户可以退票并获得相应的退票金额；<br>检查用户可以重新预定某个已取消的订单。</p></li></ol><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ol><li>网络服务和数据库分布式部署功能测试用例<br>检查网络服务的故障转移是否正常；<br>检查数据库分布式部署的数据同步是否正常；</li></ol><h2 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h2><ol><li>用户隐私检测<br>用户密码是否加密</li><li>数据库备份和同步功能测试用例<br>检查数据库备份是否正常；<br>检查数据库备份和同步的时间间隔是否合理；<br>检查数据库备份和同步的数据完整性和一致性。</li></ol><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>使用ajax+json进行数据通信，使得网页无需在刷新页面的情况下进更新<br>内容</p><h2 id="在项目中找出的bug"><a href="#在项目中找出的bug" class="headerlink" title="在项目中找出的bug"></a>在项目中找出的bug</h2><ol><li><p>功能方面：<br><strong>注册</strong>：用户注册时时发现充值数目出错，通过测试排查，定位到是在多用户情况下注册时jdbc往数据库中插入数据时会将将user表和topup（也就是充值表）中写入数据，由于设置的是用户id是自增，会出现在两个表中用户id数据不一致的情况。</p></li><li><p>数据库内容备份时：</p></li></ol><p>由于我们这个项目是一个分布式系统，它的服务和数据库分布部署在不同的机器上，这三个数据库会进行数据同步用于备份。在检测时我们发现，如果有一台服务器宕机了，网页就接收不到数据了。通过对代码的逐步检查、debug，定位到了是jdbc连接的问题，由于在开发过程中的疏忽，三个连接并不是连接连接到三台数据库。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测开 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目问答--Unity项目who am I</title>
      <link href="/2023/04/11/xiang-mu-wen-da-unity-xiang-mu-who-am-i/"/>
      <url>/2023/04/11/xiang-mu-wen-da-unity-xiang-mu-who-am-i/</url>
      
        <content type="html"><![CDATA[<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>在白盒测试中，我们将关注角色攻击的各种状态和技能的具体实现，编写针对代码的测试用例。</p><ol><li><p>静止状态测试用例<br>检查角色在静止状态下是否可以使用技能；<br>检查角色在静止状态下是否可以切换到移动状态；<br>检查角色在静止状态下是否可以切换到跑动状态；<br>检查角色在静止状态下是否可以攻击敌人；<br>检查角色在静止状态下是否可以受到敌人的攻击。</p></li><li><p>移动状态测试用例<br>检查角色在移动状态下是否可以使用技能；<br>检查角色在移动状态下是否可以切换到静止状态；<br>检查角色在移动状态下是否可以切换到跑动状态；<br>检查角色在移动状态下是否可以攻击敌人；<br>检查角色在移动状态下是否可以受到敌人的攻击。</p></li><li><p>跑动状态测试用例<br>检查角色在跑动状态下是否可以使用技能；<br>检查角色在跑动状态下是否可以切换到静止状态；<br>检查角色在跑动状态下是否可以切换到移动状态；<br>检查角色在跑动状态下是否可以攻击敌人；<br>检查角色在跑动状态下是否可以受到敌人的攻击。</p></li><li><p>释放技能状态测试用例<br>检查角色在释放技能状态下是否可以攻击敌人；<br>检查角色在释放技能状态下是否可以受到敌人的攻击；<br>检查角色在释放技能状态下技能释放是否正常；<br>检查角色在释放技能状态下是否可以正常切换状态；<br>检查角色在释放技能状态下技能的读条是否正常。</p></li><li><p>技能测试用例<br>针对四种技能，我们需要编写具体的测试用例来测试技能的具体实现：</p></li></ol><p>检查技能释放的动画效果是否正常；<br>检查技能对敌人造成的伤害是否正确；<br>检查技能的范围是否正确；<br>检查技能的冷却时间是否正常；<br>检查需要读条的技能读条的时间是否正常；<br>检查技能的持续时间是否正常。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><ol><li><p>攻击敌人测试用例<br>检查角色攻击敌人时，敌人是否会受到相应的伤害；<br>检查角色攻击敌人时，敌人的状态是否会发生相应的变化；<br>检查角色攻击敌人时，角色的状态是否会发生相应的变化；<br>检查角色攻击敌人时，攻击的范围是否正确；<br>检查角色攻击敌人时，攻击的次数是否正确；<br>检查角色攻击敌人时，攻击的速度是否正确。</p></li><li><p>技能测试用例<br>检查使用技能时，技能释放是否成功；<br>检查使用技能时，技能对敌人是否造成了相应的伤害；<br>检查使用技能时，技能的范围是否正确；<br>检查使用技能时，技能的冷却时间是否正确；<br>检查使用技能时，需要读条的技能读条的时间是否正确；<br>检查使用技能时，技能的持续时间是否正确。</p></li><li><p>状态转换测试用例<br>检查角色在不同的状态下，是否可以进行相应的操作；<br>检查角色在不同的状态下，是否可以进行正确的状态转换；<br>检查角色在不同的状态下，是否可以受到正确的攻击；<br>检查角色在不同的状态下，是否可以对敌人进行正确的攻击；<br>检查角色在不同的状态下，是否可以对技能进行正确的释放。</p></li><li><p>用户体验测试用例<br>检查游戏中角色攻击的流畅性和稳定性；<br>检查游戏中角色攻击的音效和视觉效果是否正常；<br>检查游戏中角色攻击的操作是否容易上手；<br>检查游戏中角色攻击的难度是否适当；<br>检查游戏中角色攻击的交互是否友好。</p></li></ol><h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><p>进程（Process）：是一个正在执行中的程序的实例，它拥有独立的地址空间和系统资源，每个进都是独立的，可以由操作系统进行调度和管理。进程是系统资源分配的基本单位，它可以包含多个程，但它们共享进程的资源。<br>线程（Thread）：是进程的一个执行单元，是程序中执行的最小单位，线程通常在进程内部并发行，拥有共享的地址空间和资源。一个进程可以包含多个线程，它们共享进程的资源，因此线程间通信和数据共享比进程间的通信和数据共享更加容易和高效。<br>协程（Coroutine）：是一种用户态的轻量级线程，协程的调度由用户程序控制，协程之间可以通yield、resume等操作进行协作式的调度，不需要操作系统进行上下文切换，因此比线程更加轻级、高效。</p><p>总体来说，<strong>线程是CPU调度的基本单位，进程是资源分配的基本单位，协程是用户态的调度单位</strong>。进程之间相互独立，线程之间共享进程的资源，协程之间可以通过用户程序进行协作式调度。</p><h2 id="测试中的bug"><a href="#测试中的bug" class="headerlink" title="测试中的bug"></a>测试中的bug</h2><ol><li><p>角色释放技能攻击敌人但敌人不掉血<br>通过白盒测试对掉血判定的每个条件设置用例进行测试，锁定了原因是由于技能上没有设置为刚体，无法进行碰撞检测。</p></li><li><p>黑盒测试：角色回血时，回复的血量超过了总血量，没有设置上限</p></li><li><p>角色释放技能后，技能未命中敌人，但技能特效未消失，添加每个技能的timeout（在超过timeout后，自动销毁）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 测开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-树</title>
      <link href="/2023/04/10/leetcode101-shu/"/>
      <url>/2023/04/10/leetcode101-shu/</url>
      
        <content type="html"><![CDATA[<p>二叉树的遍历( traversing binary tree )是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><ol><li>先序遍历<br> 先序遍历(PreOrder) 的操作过程如下：<br> 若二叉树为空，则什么也不做，否则，<br> 1)访问根结点;<br> 2)先序遍历左子树;<br> 3)先序遍历右子树</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根节点</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>中序遍历<br> 中序遍历( InOrder)的操作过程如下：<br> 若二叉树为空，则什么也不做，否则，<br> 1)中序遍历左子树;<br> 2)访问根结点;<br> 3)中序遍历右子树。</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根结点</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>后序遍历</li></ol><p> 后序遍历(PostOrder) 的操作过程如下：<br> 若二叉树为空，则什么也不做，否则，<br> 1)后序遍历左子树;<br> 2)后序遍历右子树;<br> 3)访问根结点。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归遍历右子树</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问根结点</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>二叉树可以通过<strong>遍历序列</strong>构造</p><p>由二叉树的<strong>先序序列</strong>和<strong>中序序列</strong>可以唯一地确定一棵二叉树。<br>在先序遍历序列中,第一个结点一定是二叉树的根结点;而在中序遍历中,根结点必然将中序序列分割成两个子序列,前一个子序列是根结点的左子树的中序序列,后一个子序列是根结点的右子树的中序序列。根据这两个子序列,在先序序列中找到对应的左子序列和右子序列。在先序序列中,左子序列的第一个结点是左子树的根结点,右子序列的第一个结点是右子树的根结点。<br>如此递归地进行下去,便能唯一地确定这棵二叉树<br>同理,由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。<br>因为后序序列的最后一个结点就如同先序序列的第一个结点,可以将中序序列分割成两个子序列,然后采用类似的方法递归地进行划分,进而得到一棵二叉树。<br>由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树。<br>要注意的是,若只知道二叉树的先序序列和后序序列,则无法唯一确定一棵二叉树。<br>例如,求先序序列( ABCDEFGHI)和中序序列(BCAEDGHFI）所确定的二叉树<br>首先,由先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列,EDGHFI为右子树的中序序列。然后由先序序列可知B是左子树的根结点,D是右子树的根结点。以此类推,就能将剩下的结点继续分解下去,最后得到的二叉树如图所示。<br><img src="/img/posts/Leetcode/binarytree.jpg"></p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p><img src="/img/posts/Leetcode/leetcode94.jpg"></p><p>虽然给的是要返回List，但可以自己写一个inorder来进行递归</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子节点递归</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 根节点</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右子节点</span>    <span class="token punctuation">}</span></code></pre><h2 id="98-验证二叉搜索数"><a href="#98-验证二叉搜索数" class="headerlink" title="98.验证二叉搜索数"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98.验证二叉搜索数</a></h2><p><img src="/img/posts/Leetcode/leetcode98.jpg"></p><p>注意 <strong>root.left&lt;root.left.right&lt;root</strong>，因此可以给每个值设置一个max和min，每次迭代时更新：<br><img src="/img/posts/Leetcode/leetcode98_false.jpg" alt="因为4<5，但4是5的右子树中的节点，所有为false"></p><ol><li>若该节点为左子节点，max更新为root.val，min保持（因为该节点可能是上上一个节点的右节点，保存上上个节点的值为最小值）</li><li>若为右节点，则反之</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> min <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义边界，注意等于号！！</span>        <span class="token keyword">long</span> max <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">return</span> <span class="token function">judge</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> min<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judge</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token operator">||</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val <span class="token operator">||</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">>=</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当左节点不为空，且左子节点大于根节点或小于最小值 || 当右节点不为空，且右节点大于最大值或小于根节点时 为false</span>        <span class="token keyword">return</span> <span class="token function">judge</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">judge</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96.不同的二叉搜索树</a></h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数</p><p><img src="/img/posts/Leetcode/leetcode96.jpg"></p><p>是用数学方法进行推导的，以[1,2,3,4,5]为例<br><strong>dp[i]表示1~i形成的二叉搜索树的数量</strong></p><p><img src="/img/posts/Leetcode/leetcode96_1.jpg"></p><p>当root=3时，左子树为[1,2] 右子树为[4,5],因为<strong>对于二叉搜索树而言，确定了序列，也就确定了这棵树</strong>，所有[1,2] = [4,5] = dp[2], **[1,2][3][4,5] = dp[2] * dp[2] = dp[i-1]<em>dp[n-i]</em>*<br>由于[1,2,3,4,5]可以分别以1~5为根，因此公式为</p><center>dp[n] = dp[n-1]*dp[0] + dp[n-2]*dp[1]....+dp[0]*dp[n-1]<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></center>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门</title>
      <link href="/2023/04/09/django-ru-men/"/>
      <url>/2023/04/09/django-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>进入虚拟环境 pip install django<br>打开anaconda，cd 到一个你想放置你代码的目录，输入：</p><pre class=" language-cmd"><code class="language-cmd">        django-admin startproject web</code></pre><p>在该目录下会新建一个web项目存在<br>|web/<br>|── manage.py<br>|── web/<br>|       ├── <strong>init</strong>.py<br>|       | settings.py<br>|       | urls.py<br>|       | asgi.py<br>|       | wsgi.py</p><p>分别的用处：<br>这些目录和文件的用处是：</p><p>最外层的 <strong>web/ 根目录</strong>只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。<br><strong>manage.py</strong>: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin 和 manage.py 获取所有 manage.py 的细节。<br><strong>里面一层的 web/ 目录</strong>包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 myweb.urls).<br><strong>web/<strong>init</strong>.py：</strong>一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。<br><strong>web/settings.py：</strong>Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。<br><strong>web/urls.py：</strong>Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。<br><strong>web/asgi.py：</strong>作为你的项目的运行在 ASGI 兼容的 Web 服务器上的入口。阅读 如何使用 ASGI 来部署 了解更多细节。<br><strong>web/wsgi.py：</strong>作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。<br>在该目录下运行</p><pre class=" language-cmd"><code class="language-cmd">py manage.py runserver</code></pre><p>在localhost:8000上部署成功<br>如果想要换端口，就输入py manage.py runserver+端口。<br>如果想要用ip地址访问（也称为远程访问），需要在8080前加上0.0.0.0:<br>也就是</p><pre class=" language-cmd"><code class="language-cmd">py manage.py runserver 0.0.0.0:8080</code></pre><p>然后可以在浏览器输入本机ip：8080访问</p><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><pre class=" language-cmd"><code class="language-cmd">python manage.py startapp myapp</code></pre><p>myapp目录如下：</p><p>|web项目根目录<br>├── myapp应用名称<br>│   ├── migrations数据模型迁移记录目录<br>│   │   └── <strong>init</strong>.pyinti文件，标识当前所在的数据模型迁移记录目录是一个 Python 包<br>│   ├── <strong>init</strong>.pyinti文件，标识当前所在的应用目录是一个 Python 包<br>│   ├── admin.pyDjango Admin 应用的配置文件<br>│   ├── apps.py应用程序本身的属性配置文件<br>│   ├── models.py用于定义应用中所需要的数据表的配置文件<br>│   ├── tests.py用于编写当前应用程序的单元测试的测试文件<br>│   └── views.py用来定义视图处理函数的文件<br>├── web项目名称<br>│   ├── <strong>init</strong>.py<br>│   ├── settings.py<br>│   ├── urls.py<br>│   └── wsgi.py<br>└── manage.py</p><p>migrations 数据模型迁移记录目录：migrations 目录用于存储数据库迁移时生成的文件，该目录下的 <strong>init</strong>.py 文件标识 migrations 是一个 Python 包。</p><p>admin.py 文件：admin.py 用于将 Model 定义的数据表注册到管理后台，是 Django Admin 应用的配置文件；</p><p>apps.py 文件：apps.py 用于应用程序本身的属性配置文件；</p><p>models.py 文件：models.py 用于定义应用中所需要的数据表；</p><p>tests.py 文件：tests.py 用于编写当前应用程序的单元测试；</p><p>views.py 文件：views.py 用来定义视图处理函数的文件；</p><h3 id="添加项目"><a href="#添加项目" class="headerlink" title="添加项目"></a>添加项目</h3><p>在settings.py中</p><pre class=" language-python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'myapp'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 添加应用</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的cmd命令</title>
      <link href="/2023/04/04/chang-yong-de-cmd-ming-ling/"/>
      <url>/2023/04/04/chang-yong-de-cmd-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>netstat -ano|findstr “8080”<br>可用于查找8080端口是否被占用，若出现  TCP    [::]:8080              [::]:0                 LISTENING       40788</p><p>可用tasklist|findstr “40788”找到该进程名，假设进程为01.exe</p><p>可用taskkill /f /t /im 01.exe 强制结束该进程</p><p>net start mysql80可启动mysql服务</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本数据结构</title>
      <link href="/2023/04/04/c-ji-ben-shu-ju-jie-gou/"/>
      <url>/2023/04/04/c-ji-ben-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h3><ol><li>不存在空引用，但可以有空指针。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ol><p>在64位系统中地址的总线宽度是8个字节，32位系统4个字节，所以32位系统中一个指针式4个bit，64位系统上是8个bit</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">&amp;</span>s <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"i: "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s："</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"p: "</span><span class="token operator">&lt;&lt;</span>p<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>输出：<br> i: 0x61ff04<br> s：0x61ff04<br> p: 0x61ff04</p></blockquote><p> 引用分配到内存和指针指向的内存都是同一块内存</p><p> C++中用引用传参更加安全，如swap(&amp;a,&amp;b)</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能</p><ol><li>struct能包含成员函数</li><li>struct能继承</li><li>struct能实现多态</li></ol><p>结构体和类最本质的一个区别就是默认的访问控制： </p><p>默认的继承访问权限：struct是public的，class是private的</p><p>C++中，不使用结构体丝毫不会影响程序的表达能力。C++之所以要引入结构体，是为了保持和C程序的兼容性</p><p>但有时仍会在C++中使用结构体，是因为可以使用结构体将不同类型数据组成整体，方便于保存数据(若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦)</p><p>struct可以继承class，同样class也可以继承struct</p><p>struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它们并无区别</p><p>概念：class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到<br>类型：<strong>struct是值类型，class是引用类型</strong>，因此它们具有所有值类型和引用类型之间的差异<br>效率：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑<br>关系：struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存分成5个区，<strong>堆，栈，自由存储区，全局/静态存续区，常量存续区</strong>。</p><p>栈区(stack sagment)：由<strong>编译</strong>器自动分配释放，存放<strong>函数的参数的值，局部变量的值</strong>等。在Windows下，栈是向低地址扩展的数据结构，是一块<strong>连续的内存的</strong>区域。这句话的意思是<strong>栈顶的地址和栈的最大容量是系统预先规定好的</strong>，在Windows下，栈的大小是1M，如果申请的空间超过栈的剩余空间时，将提示stack overflow。因此，能从栈获得的空间较小。</p><p>堆区(heap sagment) ：程序<strong>运行时动态内存分配</strong>，堆是可以上增长的。 一般由程序员分配释放，内存使用new进行分配，使用delete或delete[]释放。如果未能对内存进行正确的释放，会造成内存泄漏。但在程序结束时，会由操作系统自动回收。它与数据结构中的堆是两回事。<strong>堆是向高地址扩展的数据结构，是不连续的内存区域</strong>。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>自由存储区：使用malloc进行分配，使用free进行回收。</p><p>全局/静态存储区：<strong>全局变量和静态变量被分配到同一块内存中</strong>，C语言中区分初始化和未初始化的，C++中不再区分了。（全局变量、静态数据 存放在全局数据区）</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>构造函数–初始化对象时执行<br>析构函数在每次删除所创建的对象时执行，它<strong>不会返回任何值，也不能带有任何参数</strong>。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">test</span><span class="token punctuation">{</span>       <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token function">test</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>test<span class="token operator">::</span><span class="token function">test</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"create test:"</span><span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>test<span class="token operator">::</span><span class="token operator">~</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"delete test"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        test <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"test 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world, %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>输出<br> create test:test 1<br> hello world, 10<br> delete test</p></blockquote><h4 id="实例化方法"><a href="#实例化方法" class="headerlink" title="实例化方法"></a>实例化方法</h4><h5 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h5><pre class=" language-cpp"><code class="language-cpp">test <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建在栈里</p><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><pre class=" language-cpp"><code class="language-cpp">    test<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"hello:"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> t<span class="token punctuation">;</span></code></pre><p>指针形式，常用于初始化链表头。<br>创建在堆里，需要自己手动释放内存</p><p>使用new的方式，如果对象没有初始化，此时没有分配内存空间，也无法delete。<br>不要new一个null对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>class derived-class: access-specifier base-class</p></blockquote><p>访问修饰符是public，protected，private</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 基类</span><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// eat() 函数</span>    <span class="token comment" spellcheck="true">// sleep() 函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//派生类</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token operator">:</span> <span class="token keyword">public</span> Animal <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// bark() 函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><strong>public</strong>: 可以被类以外成员访问<br><strong>private</strong>： 只可以被类和友元函数访问，要想修改相应的参数或操作，只能通过类中public函数和友元函数，类中成员默认是private<br><strong>protected</strong>： 可以被派生类访问</p><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>拷贝是指将一个对象的值或状态复制到另一个对象中，使得两个对象在某些方面具有相同的特性。</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>拷贝构造函数必须<strong>是当前类的引用</strong><br><strong>拷贝构造函数是const 引用</strong></p><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> x<span class="token punctuation">;</span>  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 普通构造函数</span>  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 拷贝构造函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyClass <span class="token class-name">obj1</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用普通构造函数创建对象</span>MyClass <span class="token class-name">obj2</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用拷贝构造函数创建对象</span></code></pre><p>在创建对象 obj1 时，使用了普通构造函数，将参数值 42 赋值给成员变量 x；在创建对象 obj2 时，使用了拷贝构造函数，将对象 obj1 的值复制到新对象 obj2 中。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝（shallow copy）是指将<strong>对象的所有成员变量直接复制到另一个对象中，包括指针类型成员变量所指向的内存地址</strong>。因此，如果两个对象共用同一块内存地址，那么<strong>它们之间的关系就会非常紧密，任何一方的修改都会影响到另一方。</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> other<span class="token punctuation">.</span>str<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyString <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyString <span class="token function">str2</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 浅拷贝</span>str1<span class="token punctuation">.</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str1<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Hello"</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str2<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Hello"</span></code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝（deep copy）是指将对象的所有成员变量复制到另一个对象中，并<strong>为指针类型成员变量分配新的内存空间，将原来指向的内存数据复制到新的内存空间中。</strong>因此，深拷贝可以避免共用内存带来的问题。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//分配新的内存空间</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> other<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyString <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyString <span class="token function">str2</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 深拷贝</span>str1<span class="token punctuation">.</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str1<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Hello"</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str2<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "hello"</span></code></pre><h2 id="数据结构-容器"><a href="#数据结构-容器" class="headerlink" title="数据结构(容器)"></a>数据结构(容器)</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>内存空间连续的一段地址，无法改变大小</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;array></span> </span><span class="token comment" spellcheck="true">//头文件</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">></span> myarray<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>myarray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    myarray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//赋值</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> myarray<span class="token punctuation">.</span>begin<span class="token punctuation">;</span>it<span class="token operator">!=</span>myarray<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//遍历</span>cout<span class="token operator">&lt;&lt;</span>myarray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取特定数值</span></code></pre><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>动态数组</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;vector></span> </span><span class="token comment" spellcheck="true">// 头文件</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myvector<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加元素</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> myvector<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> isEmpty <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myvector<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在末尾插入五个3</span>myvector<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除末尾元素</span>myvector<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回第一个元素</span>iterator it <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取迭代首地址</span></code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;list></span></span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mylist</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>num<span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//使用数组创建list</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> mylist<span class="token punctuation">.</span>begin<span class="token punctuation">;</span>it<span class="token operator">!=</span>mylist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//遍历</span><span class="token keyword">auto</span> it <span class="token operator">=</span> mylist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mylist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入</span><span class="token punctuation">}</span></code></pre><p>都大差不差</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Link<span class="token punctuation">{</span>    <span class="token keyword">char</span> elem<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//代表数据域</span>    <span class="token keyword">struct</span> Link <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//代表指针域，指向直接后继元素</span><span class="token punctuation">}</span>link<span class="token punctuation">;</span></code></pre><p>双向链表</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//C++双向链表模板</span><span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> ListNode    <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>next<span class="token punctuation">,</span><span class="token operator">*</span>prev<span class="token punctuation">;</span>        <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//复制val->x,next->nullptr,prev->nullptr</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//头节点尾节点都为空，表示为空链表</span>    ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span><span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实现反转链表</p><pre class=" language-cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> nex <span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            nex <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//提前该语句</span>            cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>            cur<span class="token operator">=</span>nex<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// nex = cur->next;//当cur为空指针时该语句会报错，运行超时，需要将该语句提前</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>deque:前后两端都可以进行数据的插入和删除，至此数据的快速随机访问</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;deque></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> D<span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//赋值</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>D<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span>        <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    D<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在索引为1的地方插入10</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>D<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span>        <span class="token punctuation">}</span>    D<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在头部插入</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> D<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>D<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历</span>        <span class="token punctuation">}</span>    D<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//头部弹出</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>输出<br> 1 2 3<br> 1 10 2 3<br> -1 1 10 2 3 </p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>后入先出LIFO<br>动态实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> SqStack_dynamic<span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> base<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈底 </span>    <span class="token keyword">int</span><span class="token operator">*</span> top<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶 </span><span class="token punctuation">}</span>SqStack_dynamic<span class="token punctuation">;</span></code></pre><p>静态实现</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> SqStack_static<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶 </span><span class="token punctuation">}</span>SqStack_static<span class="token punctuation">;</span></code></pre><p>STL中的栈</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> S<span class="token punctuation">;</span>    S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> my_map<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//三种插入的方式</span>    my_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//插入pair对</span>    my_map<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"insert second"</span><span class="token punctuation">;</span>    my_map<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ten"</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> my_map<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>my_map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//it->first得到第一个的值，it->second得到第二个的值</span>    <span class="token comment" spellcheck="true">//map的删除</span>    my_map<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除2</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> my_map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    my_map<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//删除找到的10</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set也是一种关联性容器，它同map一样，底层使用红黑树实现，插入删除操作时仅仅移动指针即可，不涉及内存的移动和拷贝，所以效率比较高。从中文名就可以明显地看出，<strong>在set中不会存在重复的元素</strong>，若是保存相同的元素，将直接视为无效。</p><p>unordered_set常用：<br><strong>insert</strong>:插入指定元素<br><strong>erase</strong>: 删除指定元素<br><strong>find</strong>:查找指定元素<br><strong>size</strong>,获取容器中元素的数量<br><strong>empty</strong>:判断是否为空<br><strong>swap</strong>:交换</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> us<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入元素（去重）</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历容器方式一（范围for）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> us<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1 4 3 2</span>    <span class="token comment" spellcheck="true">//删除元素方式一</span>    us<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除元素方式二</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator pos <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查找值为1的元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历容器方式二（迭代器遍历）</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        it<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//4 2</span>    <span class="token comment" spellcheck="true">//容器中值为2的元素个数</span>    cout <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span>    <span class="token comment" spellcheck="true">//容器大小</span>    cout <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span>    <span class="token comment" spellcheck="true">//清空容器</span>    us<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//容器判空</span>    cout <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span>    <span class="token comment" spellcheck="true">//交换两个容器的数据</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> us<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//11 22 33 44</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101--链表</title>
      <link href="/2023/04/03/leetcode101-lian-biao/"/>
      <url>/2023/04/03/leetcode101-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/submissions/">206.反转链表</a></h2><p><img src="/img/posts/Leetcode/leetcode206.jpg"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化判断头和头的下一个是否为空，若空，直接返回</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//新建一个cur用来记录现在的</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            ListNode pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>，<span class="token comment" spellcheck="true">//每次新建一个pre，存放head的下一个，然后把pre指向cur，实现翻转</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="21-合并有序链表"><a href="#21-合并有序链表" class="headerlink" title="21.合并有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21.合并有序链表</a></h2><p><img src="/img/posts/Leetcode/leetcode21.jpg"></p><blockquote><p>动态规划＋递归<br> 先判断l1.val和l2.val，确定现在是l1还是l2，若是l1, 要确定下一个merge(l1.next,l2)，返回了l1</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode list1<span class="token punctuation">,</span> ListNode list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            list1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> list2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            list2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></h2><p><img src="/img/posts/Leetcode/leetcode24.jpg"></p><blockquote><p>逆向思维–递归<br> 拆分任务–每两个互相交换，也就是每两个都要实现head.next指向swap(next.next),next.next指向head<br> 确定终止条件 – head==null||next==null</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// head的下一个是next之后的节点继续交换</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p><img src="/img/posts/Leetcode/leetcode24.jpg"></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>很巧妙的方法，<strong>把指针A和B同时连续遍历A、B两个链表</strong><br>pointerA -&gt; AB<br>pointerB -&gt; BA<br>假设A到交点需要a步，B到交点需要b步，交点到终点需要b步：<br>pointerA从起点到第二次走到交点：a+c+b<br>pointerB从起点到第二次走到交点：b+c+a<br>第二次就相遇</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode pointerA <span class="token operator">=</span> headA<span class="token punctuation">;</span>        ListNode pointerB <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pointerA<span class="token operator">!=</span>pointerB<span class="token punctuation">)</span><span class="token punctuation">{</span>            pointerA <span class="token operator">=</span> pointerA <span class="token operator">==</span> null<span class="token operator">?</span> headB<span class="token operator">:</span>pointerA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pointerB <span class="token operator">=</span> pointerB <span class="token operator">==</span> null<span class="token operator">?</span> headA<span class="token operator">:</span>pointerB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pointerA<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234.回文链表</a></h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br>可以将链表复制到<strong>Arraylist</strong>中国，直接通过下标比较</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>head<span class="token operator">!=</span>null<span class="token punctuation">;</span>head<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>            array<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">--</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">!=</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础概念</title>
      <link href="/2023/04/02/shu-ju-ku-ji-chu-gai-nian/"/>
      <url>/2023/04/02/shu-ju-ku-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><strong>键</strong></p><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。比如一张学生信息表，学生表中含有学号或者身份证号的任意组合都称为此表的超键。如：（学号），（学号，姓名），（身份证号，性别）等；</p><p>1.候选键（candidate key）：一个或者多个属性的组合，能够唯一确定实体的一个实例。不含多余属性的超键称为候选键；</p><p>2.主键（primary key）:从候选键中，选中用来作为唯一标识的属性或者属性组，被称为主键。（员工的编号可以作为主键）</p><p>3.可选键（alternative key）：候选键中，没有选中的其他键，可以称之为可选键。（员工电子邮件</p><p>学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）</p><p>超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！</p><p>候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！</p><p>主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了！</p><p>外键：宿舍号就是学生信息表的外键</p><p><strong>范式</strong></p><p>第一范式（1NF）<br>在关系模型中，对于添加一个规范的要求，所有的域都是原子性的，即数据库的每一个项都是不可分割的原子数据项，而不能是集合、数组、记录等非原子的数据项。<br>实现某个属性有多个值时，必须拆分为不同的属性，第一范式无重复的域。</p><p>第二范式（2NF）<br>第二范式就是在第一范式的基础上完全依赖于主键。消除了部份依赖。（<br>数据库表中的每个实例或记录必须可以被唯一的区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一表示。<br>例如，学生号可以实现每一个学生的区分，学生号就是候选键。找不到候选键，就要增加额外属性实现区分。</p><p>第三范式（3NF）<br>：1. 满足第二范式 2. R中的非主属性对主键有传递性的依赖（表中的非主属性之间不能functionally determined by另一个非主属性）<br>General说法（这个比较好记）:1. 满足第二范式 2. R中的所有非主属性都是fully functionally dependent on R上的每个key 3. R中的所有非主属性都是non-transitively dependent onR上的每个key<br>例如，班级表，班级编号class_Id，年级信息等；那么在学生表中，列出班级编号后就不再显示年级信息等。</p><p>巴斯-科德范式（BCNF）<br>在3NF的基础上，任何主属性不能对主属性子集依赖，即在3NF基础上消除对主码子集的依赖。<br>BCNF没有加入新的设计规范，只是对第二范式和第二范式的设计规范要求更强，因此被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，是数据库冗余度更小。</p><p><strong>依赖关系</strong><br>部分依赖<br>通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p><p>完全依赖<br>通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB。</p><p>传递依赖</p><p>传递的依赖：（transitive dependency）<br>通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么说C传递依赖于A。<br>严格传递依赖：我们称C对属性A严格传递依赖当他满足： A-&gt;B, B-&gt;C, B-/-&gt;A, C-/-&gt;B<br>只有两个属性的时候属性，不能说transitive dependency</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -MySQL -数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC与mysql锁机制</title>
      <link href="/2023/04/01/jdbc-yu-mysql-suo-ji-zhi/"/>
      <url>/2023/04/01/jdbc-yu-mysql-suo-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h3><p>第一范式：属性不可再分。即一个属性不能再拆分为更小的子属性，确保每个属性的原子性。<br>第二范式：唯一性约束。即每个非主属性都必须依赖于完整的主键，而不能依赖于主键的一部分。<br>第三范式：消除传递依赖。即非主属性不能依赖于其他非主属性，而只能依赖于主键。</p><h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p><strong>事务</strong>：事务是一个由有限操作集合组成的逻辑单元，事务操作的目的是<strong>数据一致</strong>和<strong>操作隔离</strong>。<br><strong>数据一致</strong>是事务提交时保证十五欸的所有操作全部成功完成，并且更改永久生效；事务回滚时，保证可以恢复到事务执行之前的状态。<strong>操作隔离</strong>是指多个同时执行的事物之间应该相互独立，互不影响。</p><p>ACID，即原子性、一致性、隔离性和持久性。</p><ul><li><p>原子性：要么全部提交（commit后写日志），要么全部失败（回滚事务）。保证十五的原子性要求在发生异常是，对事务所有执行过的操作进行回滚，回滚是通过<strong>回滚日志</strong>实现。回滚日志种记录了所有操作的逆操作，因此回滚就是将该事务回滚日志种的所有操作再执行一遍。</p></li><li><p>隔离性：该会话事务内部的SQL操作及操作的数据库对象<strong>与并发的其它会话事务是隔离的</strong>。<strong>事务的隔离级别是由数据库</strong>提供的,数据库隔离级别在服务器端保证客户端用户一定不会发生哪些并发冲突。方法有：隐式锁、多版本（MVCC）等。应用场景是数据库多并发控制</p></li><li><p>一致性：是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束（触发器等）。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性，这就是“一致”的意思。应用场景是：但用户场景</p></li><li><p>持久性：事务一旦提交，对数据库的改变是永久的，被提交后就<strong>无法回滚</strong>。事务的持久性也是事务日志保证的</p></li></ul><h3 id="并发冲突"><a href="#并发冲突" class="headerlink" title="并发冲突"></a>并发冲突</h3><h4 id="读不一致"><a href="#读不一致" class="headerlink" title="读不一致"></a>读不一致</h4><p>读不一致性本质上是读写操作的不一致性</p><p><strong>脏读</strong>：一个事务读取了另一个事务<strong>未提交</strong>的数据。当事务A查询事物B修改后但是未提交的数据时，事物B有可能会因为某些情况进行回滚，此时事物A读到的数据就是错的，这是的数据也称之为脏数据。它是对一条记录而言的。脏读本质上是读写操作的冲突，<strong>解决办法是写完之后再读。</strong></p><p><strong>不可重复读</strong>：一个事务<strong>两次读取同一个数据</strong>，两次读取的<strong>数据不一致</strong>（也就是有另一个事务修改了数据并提交了）。当事务A查询第一次是，事物B虽然修改了数据但是没有提交，此时事物A查询的还是之前未修改的值，但是当事物B提交后，事物A第二次查询，此时查询到的值是事物B修改后的值，这次查询的值不一样，即读取的数据不一致。它是对一条记录而言的。不可重复读本质上是读写操作的冲突，<strong>解决办法是读完再写。</strong></p><p><strong>幻读</strong>：一个事务<strong>两次读取一个事务某个范围的记录，两次读取的记录不一致。</strong>假设事务A第一次查询一段范围的rows中的某数据时，此时有5列。但是之后又另外一个事物B增加了一列，当事物A再次进行相同的查询时，发现有6列，这就是所谓的幻读。<strong>它是对多条记录而言的</strong>。幻读本质上是读写操作的冲突，解决办法是<strong>读完再插入/删除。</strong><br>不可重复读是record维度，而幻读是transaction维度。<br>不可重复读主要发生在update，而幻读主要发生在insert和delete</p><h4 id="写不一致"><a href="#写不一致" class="headerlink" title="写不一致"></a>写不一致</h4><p>写不一致性本质上是写写操作的不一致性<br>出现<strong>丢失修改</strong>（一个事务的更新覆盖了另一个事务的更新）。事务A和事务B需要对同一个row的元素进行修改。A和B同时读到该row的的数据，分别修改，后提交的事务B覆盖了事务A的更新。更新丢失本质上是写写操作的冲突，解决办法是<strong>一个一个地写。</strong><br>防止丢失修改的并发控制类型常见的有三种方法：</p><ol><li>加锁（保守式并发控制）- 在从获取记录直到记录在数据库中更新的这段时间内，该行对用户不可用。</li><li>开放式并发控制（原始值） - 只有当实际更新数据时，该行才对其他用户不可用。更新将在数据库中检查该行并确定是否进行了任何更改。如果试图更新已更改的记录，则将导致并发冲突。</li><li>最后的更新生效 - 只有当实际更新数据时，该行才对其他用户不可用。但是，不会将更新与初始记录进行比较；而只是写出记录，这可能就改写了自上次刷新记录后其他用户所进行的更改。</li></ol><h3 id="为什么要MySQL锁"><a href="#为什么要MySQL锁" class="headerlink" title="为什么要MySQL锁"></a>为什么要MySQL锁</h3><p>要控制数据库中的事务并发性需要使用MySQL中的锁，注意Synchronized这种只能用于控制Java代码块的并发访问，但不能控制数据库的并发访问</p><p>MySQL 提供了多种锁机制，包括<strong>共享锁（Shared Lock）和排他锁（Exclusive Lock）</strong>等。其中，<strong>共享锁用于防止其他事务对资源进行写操作，而排他锁则用于防止其他事务对资源进行读写操作。</strong></p><p>在 JDBC 中，可以通过以下方式来使用 MySQL 锁机制：</p><ol><li><p>通过设置 SQL 语句的 Isolation Level 属性来指定事务的隔离级别，从而控制并发访问。</p></li><li><p>在 SQL 语句中使用 Lock In Share Mode（共享锁）或 For Update（排他锁）等关键字来控制锁机制。</p></li></ol><h3 id="多用户场景下并发控制的手段"><a href="#多用户场景下并发控制的手段" class="headerlink" title="多用户场景下并发控制的手段"></a>多用户场景下并发控制的手段</h3><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><blockquote><p>使用<strong>隔离级别</strong>:一个会话事务对数据库的存取与并发的另一个会话事务的隔离程度。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 并发一致性就越好, 但并发性越弱。</p></blockquote><p>数据库中，事务隔离级别（Transaction Isolation Level）指的是多个事务同时执行时，各自之间的隔离程度。数据库系统提供了四种事务隔离级别，分别为：</p><p>1.读未提交（RU）<br>具有Read uncommitted隔离级别的事务，<strong>允许读取未被其他事务提交的变更</strong>，可能出现脏读、不可重复读、幻读，以及丢失修改。选择Read uncommitted的原因是，在只读的历史数据库中，可以提高效率。<br>2. 读已提交（RC）<br>具有Read committed隔离级别的事务，确保只允许读取已经被其他事务提交的变更。<br>当隔离级别设置为Read committed时，避免了脏读，但是可能出现不可重复读、幻读，丢失修改。大多数数据库的默认隔离级别是Read committed，比如Sql Server , Oracle。<br>3. 可重复读（RR）<br>具有Repeatable read隔离级别的事务，可以确保多次从一个记录中读取相同的值，在这个事务持续期间，禁止其他事务对这条记录进行更新。隔离级别设置为Repeatable read时，可以避免脏读、不可重复读。但是可能出现幻读。MySQL的默认隔离级别就是Repeatable read。<br>4.串行化（S）<br>具有Serializable隔离级别的事务，<strong>可以确保从一个表中读取相同的行数，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，</strong>但性能十分低。<br><strong>Serializable是最高的事务隔离级别，提供了最高程度的隔离性，</strong>同时代价也花费最高，性能很低，这个隔离级别通常会降低并发性，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读和丢失修改。如果事务隔离级别设置为SERIALIZABLE，具有SERIALIZABLE隔离级别的事务开始之后，不会看到数据库中其它会话事务作出的任何修改，直到提交SERIALIZABLE事务为止</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>使用锁的原则：在满足完整性约束、业务需求，解决多事务并发冲突，保证数据正确性的前提下，尽可能<strong>减少阻塞和避免死锁</strong>，提高事务的并发性，保证程序的并发质量</p><p><strong>避免阻塞</strong>的手段：</p><ol><li>总原则是<strong>缩小锁粒度，尽可能减少共享数据；锁的模式尽可能弱，尽可能减少锁的互斥；互斥锁的持续时间尽可能短；</strong></li><li>尽可能减少共享数据，提高会话的并发性。锁的粒度尽可能小（行锁—&gt;表锁，加锁的范围逐渐大），封锁的粒度越大，并发性就越小，同时系统的开销也就越小；相反，封锁的粒度越小，并发就越高，系统开销也就越大。</li><li>尽可能减少锁的互斥，提高会话的并发性。锁的模式尽可能弱（不加锁—&gt;加S锁—&gt;加X锁，加锁的类逐渐加强）</li><li>在并发比较高的系统中，不要加显式锁，特别是在事务里加显式锁。例如，select…for update句。</li><li>尽可能减少阻塞。这里有两种方案：1.减少锁的持续时间，事务内部访问某对象的时机。一般多事要经常访问的表的引用放在事务的末尾，以便将控制锁的持续时间减至最短。2. 尽可能缩短事（事务本身要短），以便将长期锁减至最少，改善并发性。</li><li>进行事务的分解，分解的原则是事务业务是最小原子操作。对于数据量很大的操作，在保证数据一性/原子性的条件下，可以将其分成几组提交事务，这样可以避免长时间地占用资源。<br>7.在表中添加索引。查询会扫描更少的索引记录，并且因此也可以设置更少的锁定。</li><li>尽量按照主键/索引去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外计算工作。比如，用select…where…order by rand();这样的语句，由于类似这样的语句用不到引，因此将导致整个表的数据都被锁住。</li><li>优化SQL和表设计，减少同时占用太多资源的情况。比如，减少连接的表，将复杂SQL分解为多个简的SQL。</li></ol><p><strong>避免死锁</strong>：调整访问共享资源的SQL顺序，对于多个会话的事务内部要按相同的固定顺序访问共享资源（多个表对象，多条记录），避免出现死锁</p><h5 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h5><p>在商业数据库中，通过多版本，select不需要加锁，也不会读到脏数据，不存在读写依赖，写的排它锁不会阻塞读，加大了并发性。这属于<strong>乐观控制模型</strong></p><h3 id="MySQL锁的种类"><a href="#MySQL锁的种类" class="headerlink" title="MySQL锁的种类"></a>MySQL锁的种类</h3><p><img src="/img/posts/MySQL/mysql_lock.jpg" alt="OSI"></p><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>就是一次性会锁住多少<br>表锁会锁住一整个表<br>行锁是锁定行（容易发生死锁）<br>页锁–MySQL特有，介于表锁和行锁之间</p><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="共享锁（读锁）"><a href="#共享锁（读锁）" class="headerlink" title="共享锁（读锁）"></a>共享锁（读锁）</h5><p>是读取操作（SELECT）时创建的锁。其他用户可以并发读取数据，但在读锁未释放前，也就是查询事务结束前，任何事务都不能对数据进行修改（获取数据上的写锁），直到已释放所有读锁。</p><p>  如果事务A对数据B加上读锁后，则其他事务只能对数据B上加读锁，不能加写锁。获得读锁的事务只能读数据，不能修改数据。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> … <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE MODE</span><span class="token punctuation">;</span></code></pre><h5 id="排他锁（写锁）"><a href="#排他锁（写锁）" class="headerlink" title="排他锁（写锁）"></a>排他锁（写锁）</h5><p>如果事务A对数据B加上写锁后，则其他事务不能再对数据B加任何类型的锁。获得写锁的事务既能读数据，又能修改数据。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> … <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向锁属于表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。InnoDB 中的两个表锁：</p><blockquote><p>意向共享锁（IS）：表示事务<strong>准备</strong>给数据行加入共享锁，就是说一个数据行加共享锁前必须先取得该表的IS锁；<br>意向排他锁（IX）：类似上面，表示事务<strong>准备</strong>给数据行加排他锁，说明事务在一个数据行加排他锁前必须先取得该的IX锁。</p></blockquote><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p><strong>悲观锁</strong>：认为数据出现冲突的可能性更大，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。共享锁和排他锁都是悲观锁的实现</p><p><strong>乐观锁</strong>：更新数据库时认为操作不会导致冲突，在操作数据时不加锁，而在进行更新后再去判断是否有冲突了。</p><ul><li>通过添加版本号进行实现：<br>  先查询出那条记录，获取出version字段。<br>  如果要对那条记录进行更新操作，则先判断version的值是否与刚刚查询出来时的version的等。<br>  如果相等，则说明这段期间没有其他程序对其进作，则可以执行更新，将version字段的值加1。<br>  如果version值与刚刚获取出来的version的值不相则说明这段期 间已经有其他程序对其进行操作了，进行更新操作</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="使用锁机制来实现对账户余额的更新操作"><a href="#使用锁机制来实现对账户余额的更新操作" class="headerlink" title="使用锁机制来实现对账户余额的更新操作"></a>使用锁机制来实现对账户余额的更新操作</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 连接数据库</span>Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 关闭自动提交</span>conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置事务隔离级别</span>conn<span class="token punctuation">.</span><span class="token function">setTransactionIsolation</span><span class="token punctuation">(</span>Connection<span class="token punctuation">.</span>TRANSACTION_REPEATABLE_READ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查询账户余额</span>    PreparedStatement pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token string">"select balance from account where id = ? for update"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> accountId<span class="token punctuation">)</span><span class="token punctuation">;</span>    ResultSet rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> balance <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新账户余额</span>    PreparedStatement pstmt2 <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token string">"update account set balance = ? where id = ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt2<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> balance <span class="token operator">-</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt2<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> accountId<span class="token punctuation">)</span><span class="token punctuation">;</span>    pstmt2<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提交事务</span>    conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 回滚事务</span>    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关闭数据库连接</span>    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a>获取共享锁</h4><p>使用了FOR SHARE语句来获取共享锁。在多个事务同时访问该表时，只有其中一个事务可以获取共享锁，并且其他事务只能读取该行数据，不能修改该行数据。需要注意的是，获取共享锁的事务需要先获取到行级锁，否则会出现死锁等问题。</p><pre class=" language-java"><code class="language-java">Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM my_table WHERE id = ? FOR SHARE"</span><span class="token punctuation">;</span>PreparedStatement pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>ResultSet rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 处理查询结果</span>conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="获取排他锁"><a href="#获取排他锁" class="headerlink" title="获取排他锁"></a>获取排他锁</h4><p>使用了FOR UPDATE语句来获取排他锁。在多个事务同时访问该表时，只有其中一个事务可以获取排他锁，并且其他事务不能读取或修改该行数据。需要注意的是，获取排他锁的事务需要先获取到行级锁，并且需要在事务结束前释放锁，否则会出现死锁等问题。</p><pre class=" language-java"><code class="language-java">Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM my_table WHERE id = ? FOR UPDATE"</span><span class="token punctuation">;</span>PreparedStatement pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>ResultSet rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 处理查询结果</span>conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>通过索引的唯一性，可以保证数据库每一行数据的唯一性。索引的主要结构为B+树和哈希表，对于的索引分别为B+树索引和哈希索引，默认索引为B+树索引</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>数据都存在叶子节点中，叶子节点均为索引，要找到具体数据只需要扫描叶子节点。<br>B+树的优点在于它的查询和插入操作复杂度都为O(log n)，其中n为B+树中存储的数据个数。<br>B树要找到具体的数据需要进行中序遍历</p><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p><strong>主键索引</strong>:名为primary的唯一非空索引，不允许有空值。<br><strong>唯一索引</strong>：索引列中的值必须唯一，但可以为null<br><strong>组合索引</strong>：在表中多个字段上组合创建的索引，只有在查询条件中使用这些字段的坐标字段时，需要遵循最左前缀原则<br><strong>全文索引</strong>：</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-搜索算法</title>
      <link href="/2023/03/26/leetcode101-sou-suo-suan-fa/"/>
      <url>/2023/03/26/leetcode101-sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>DFS:深度优先搜索 (DFS)：DFS是通过<strong>递归</strong>搜索来实现的，它沿着树的深度搜索，直到找到目标节点或到达末端。<br>步骤，从初始节点-&gt;判断是否满足进入下一个节点的条件-&gt;进入下一个节点-&gt;进行遍历操作-&gt;在该节点继续dfs</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node n <span class="token operator">:</span> node<span class="token punctuation">.</span>adjacent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>visited <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>而广度有限BFS:是一种图形搜索算法，它在图中沿着宽度遍历，先找到所有与起点节点相邻的节点，然后再找到与它们相邻的节点，以此类推。广度优先中常使用<strong>队列</strong>存储</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node element <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">visit</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node n <span class="token operator">:</span> element<span class="token punctuation">.</span>adjacent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>visited <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                n<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="695-岛屿问题"><a href="#695-岛屿问题" class="headerlink" title="695.岛屿问题"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695.岛屿问题</a></h2><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿&nbsp;是由一些相邻的&nbsp;1&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设&nbsp;grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0</p><p><img src="/img/posts/Leetcode/leetcode695.jpg" alt="示例"></p><p>用dfs</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//可以看图理解，在加上记住这个模板。</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义一个表示岛屿的面积</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这两个for循环是来遍历整张二维格上的所有陆地的。</span>        <span class="token comment" spellcheck="true">//i 表示行，j表示列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//陆地的格</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//取出最大的面积</span>                    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>              <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回最大的陆地面积</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当超出岛屿边界（上下左右）的时候，就直接退出，特别要加上当遍历到海洋的时候也要退出，</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> i<span class="token operator">>=</span>grid<span class="token punctuation">.</span>length <span class="token operator">||</span> j<span class="token operator">>=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//定义一个变量表示岛屿的面积，就是包含几个陆地</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将陆地改为海洋，防止重复陆地重复遍历。</span>        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历上方元素，每遍历一次陆地就加一</span>        sum <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历下方元素</span>        sum <span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历右边元素</span>        sum <span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历左边元素</span>        sum <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/">547.省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p><img src="/img/posts/Leetcode/leetcode547.jpg" alt="示例"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> isConnected<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> province<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>isConnected<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//利用province来记录</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// province[0] = 1;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>isConnected<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>province<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 只有当province为0的时候才会进入新的一个省份，需要重新进行dfs</span>                province<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>isConnected<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>isConnected<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> province<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        province<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> province<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token function">dfs</span><span class="token punctuation">(</span>isConnected<span class="token punctuation">,</span> j<span class="token punctuation">,</span> province<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> province<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> province<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    province<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> province<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每次dfs将province[k]设成现在省份的index</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k <span class="token punctuation">,</span>province<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习4-图神经网络</title>
      <link href="/2023/03/21/ji-qi-xue-xi-4-tu-shen-jing-wang-luo/"/>
      <url>/2023/03/21/ji-qi-xue-xi-4-tu-shen-jing-wang-luo/</url>
      
        <content type="html"><![CDATA[<p>图神经网络是一种深度学习方法，用于处理图形数据结构。图形数据结构中的节点表示实体，边表示实体之间的关系。GNNs可以学习这些实体及其关系的复杂模式，用于各种任务，如节点分类、链接预测和图分类。</p><h2 id="图神经网络的组合优化"><a href="#图神经网络的组合优化" class="headerlink" title="图神经网络的组合优化"></a><a href="https://github.com/amazon-science/co-with-gnns-example">图神经网络的组合优化</a></h2><h3 id="什么是组织优化问题？"><a href="#什么是组织优化问题？" class="headerlink" title="什么是组织优化问题？"></a>什么是组织优化问题？</h3><p>同时面对许多决策，每一个决策只有yes/no两种取值，视为一个0-1变量。那么解空间就是全部0-1变量的所有组合。<br>每种不同的决策组合都会得到一个<strong>目标函数值</strong>（例如成本或收益），这个目标函数就是优化的对象</p><p>组合优化问题的两个相关例子是最大切割（maximum cut）与最大独立集（maximum independent set）。给定一个图，这两个问题可以简单理解为对每个节点进行一次二分类：<br><strong>最大切割</strong>：把这个图的节点分为两堆，使得这两堆节点之间的边数最多。两堆节点的标签分别是0和1。<br><strong>最大独立集</strong>：在这个图中找出尽可能多的节点，使得这些节点之间互相没有边相连。找出的节点标签为1，其余为0。</p><h3 id="用QUBO求解最大切割和最大独立集问题"><a href="#用QUBO求解最大切割和最大独立集问题" class="headerlink" title="用QUBO求解最大切割和最大独立集问题"></a>用QUBO求解最大切割和最大独立集问题</h3><p><a href="https://blog.csdn.net/econe_wei/article/details/103555430">最大切割与最大独立集问题的目标函数可以在QUBO（二次无约束二进制优化）</a></p><p>在说明什么是QUBO之前，需要先说明量子退火。量子退火法是模拟退火算法的量子实现，量子退火法都必须把问题映射成一个叫【哈密顿算符(Hamiltonian) 】的能量表达式。一般用H表示，然后求出让H值最小的变量组合。这个表达式是个二次多项式，里面的变量只能取0或1如：</p><p>$$ H = x_1^2 - x_2^2 + 2 $$</p><p>也就是x1和x2都只能取值0或1，我们要算出来，让H最小的x1和x2的值。因为x1和x2的取值组合和对应的H值，如下表所示：</p><p><img src="/img/posts/MachineLearning/gnn_qubo_table.jpg"></p><p>从上面的表格可以看出，(x1, x2) = (0, 1)的时候，H=2，是最小值。使用量子退火解决法，可以解决所有可以转变成二次多项式的，变量取值只能是0或1的问题。</p><p>上面的例子只有两个变量，所以很容易算出(x1, x2)的最优解，但是当有成千上万个x变量时，普通计算机就要花很久来计算，而量子退火机可以在数分钟内得出结果（计算时间依赖问题规模而定）</p><p><strong>QUBO</strong>就是将这个哈密顿算符表达式通过矩阵形式表示的中间矩阵，如该哈密顿算符的表达就是：<br><img src="/img/posts/MachineLearning/gnn_qubo_matrix.jpg" alt="矩阵形式"><br>中间的矩阵就是QUBO</p><h3 id="GNN是什么"><a href="#GNN是什么" class="headerlink" title="GNN是什么"></a>GNN是什么</h3><p>图神经网络的一般输入是一个图，它由节点集、边集、邻接矩阵等基本特征组成。对于节点集中的每一个节点，都可以用一个固定形状的张量来表示其特征，用邻接矩阵表征节点之间的关系，最简单的图神经网络认为边只代表邻接关系而没有节点那样的高维特征。</p><blockquote><p>作用：利用图的信息，<strong>进行节点或边的分类、节点或边的特征预测</strong>等。训练与预测的基本框架等与其他神经网络没有区别，只是处理的数据结构不同。</p></blockquote><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>在本研究中，提出了一个高度可扩展的基于 GNN 的求解器，以（大约）解决具有数百万个变量的组合优化问题</p><p>方法： 把组合优化问题<strong>转化为图上的最大切割或者最大独立集</strong>等QUBO问题，进一步转化为一个<strong>图节点二分类</strong>问题。然后用<strong>图神经网络处理节点间的邻接信息</strong>，把QUBO的<strong>目标函数松弛</strong>，用<strong>连续的分类概率</strong>代替离散的0-1变量，作为神经网络的loss函数，训练这个图神经网络（输出节点类别概率）。最后用阈值分割得到每个节点/变量的0-1值。</p><p>demo用d-regular方法生成了一个随机图，<br><img src="/img/posts/MachineLearning/gnn_org.jpg" alt="随机种子生成的随机图"><br>参数是n=100, d=3, seed=1，代表100节点，平均度3。共训练了13092轮，patience=100意味着最后100轮loss没有提升，达到耐心上限早停（提前停止）了<br><img src="/img/posts/MachineLearning/gnn_train_result.jpg" alt="训练结果"><br>这一部分见./utils.py下的run_gnn_training()函数。最佳的loss值是-40.85710144042969，也就是MIS问题松弛的QUBO目标函数的最好解。GNN找到的独立集节点数是41个，违背最大独立集限制条件的节点数为0。花费131.4s,其中 model training took 131.357s。<br><img src="/img/posts/MachineLearning/gnn_vis_result.jpg" alt="最终结果"></p><p>使用networkx的MIS求解器求解得到的独立集节点数是39个，违背最大独立集限制条件的节点数为0。<br><img src="/img/posts/MachineLearning/gnn_classical_optim.jpg" alt="MIS求解结果"></p><blockquote><p>结果:GNN求解器求解得到的最大独立集结果，好于networkx的MIS求解器求解得到的最大独立集。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 图神经网络 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-动态规划</title>
      <link href="/2023/03/20/leetcode101-dong-tai-gui-hua/"/>
      <url>/2023/03/20/leetcode101-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<p>动态规划（Dynamic Programming，简称 DP）是一种优化技巧，用于解决具有重叠子问题和最优子结构的问题。<br>它<strong>将问题分解为更小的子问题</strong>，将子问题的解存储在表中，然后<strong>使用这些子问题的解</strong>来构建<strong>原问题的解</strong>。</p><p>在动态规划中，有两种常见的方法：<strong>自顶向下</strong>（Top-down，也称为记忆化搜索）和<strong>自底向上</strong>（Bottom-up，也称为递推式方法）。</p><p>在斐波那契数列中的动态规划如下：</p><p>F(0) = 0<br>F(1) = 1<br>F(n) = F(n-1) + F(n-2)，当 n &gt; 1 时</p><p>自顶而下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FibonacciTopDown</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">fibTopDown</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fibTopDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memo<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            memo<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token function">fibTopDown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibTopDown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> memo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自底而上</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FibonacciBottomUp</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">fibBottomUp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fibBottomUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70.爬楼梯</a></h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢</p><blockquote><p>  输入：n = 2<br>    输出：2<br>    解释：有两种方法可以爬到楼顶。<br>    1. 1 阶 + 1 阶<br>    2. 2 阶</p></blockquote><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>dp最简单的方式，可以通过计算已知量，求解未知量</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="可以用递归，但会超时"><a href="#可以用递归，但会超时" class="headerlink" title="可以用递归，但会超时"></a>可以用递归，但会超时</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">climbStairsReverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">climbStairsReverse</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">climbStairsReverse</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><blockquote><p>示例 1：<br>    输入：[1,2,3,1]<br>    输出：4<br>    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p>该题的dp函数是 <strong>dp[n] = max(dp[n-1], dp[n-2]+num[n])</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对dp的初始化要注意上下界</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>max_index<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> max_index <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> max_index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>max_index<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// if (dp[len-1]==0) dp[len-1] = Math.max(dp[max_index-2] + nums[len-1], dp[max_index-1]);</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然这样解答成功，但代码略有冗余，可以进行优化如下（直接遍历，而不需要使用下标）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> curr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次循环，计算“偷到当前房子为止的最大金额”</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> prev <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> curr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a><a href="https://leetcode.cn/problems/arithmetic-slices/">413.等差数列划分</a></h3><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的子数组个数。</p><p>子数组是数组中的一个连续序列。</p><blockquote><p>  示例：<br>    输入：nums = [1,2,3,4]<br>    输出：3<br>    解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum_combin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_diff <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pre_diff <span class="token operator">=</span> cur_diff<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur_diff <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_diff <span class="token operator">==</span> pre_diff<span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                sum_combin <span class="token operator">+=</span> <span class="token function">getSum</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                pre_diff <span class="token operator">=</span> cur_diff<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        sum_combin <span class="token operator">+=</span> <span class="token function">getSum</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum_combin<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token operator">*</span>count<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h2><h3 id="60-最短路径和"><a href="#60-最短路径和" class="headerlink" title="60.最短路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">60.最短路径和</a></h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><img src="/img/posts/Leetcode/leetcode64.jpg" alt="示例"></p><blockquote><p>示例<br>    输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>    输出：7<br>    解释：因为路径 1→3→1→1→1 的总和最小 </p></blockquote><p>类Dijkstra，由于要求最短路径，只能接受从上或从左路径输入</p><p><strong>dp[a][b] = min(dp[a-1][b], dp[a][b-1]) + num[a][b]</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a><a href="https://leetcode.cn/problems/01-matrix/">542.01矩阵</a></h3><p>给定一个由 0 和 1 组成的矩阵 mat&nbsp;，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 </p><p><img src="/img/posts/Leetcode/leetcode542.jpg" alt="示例"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="/img/posts/Leetcode/leetcode542_formula.jpg" alt="dp公式"></p><p>第一步，先把dp[][]数组填满，原矩阵为0的地方，dp矩阵也为0，其余的为10001<br>第二步，从左上角开始迭代，对比</p><ol><li>自身和<strong>右侧元素+1</strong></li><li>自身和<strong>下方元素+1</strong></li></ol><p><img src="/img/posts/Leetcode/leetcode542_step1.jpg" alt="左上角开始迭代"></p><p>第三步，从右下角开始迭代，对比</p><ol><li>自身和<strong>左侧元素+1</strong></li><li>自身和<strong>上方元素+1</strong></li></ol><p><img src="/img/posts/Leetcode/leetcode542_step2.jpg" alt="右下角开始迭代"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution542</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mat<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> mat<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// initiate</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">?</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token number">10001</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// From left-top, compare left and top with self</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                   <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token punctuation">}</span>                               <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//From right-bottom, compare right and bottom with self</span>        <span class="token comment" spellcheck="true">// be careful about index, it is m-1 and n-1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221.最大正方形</a></h3><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p><img src="/img/posts/Leetcode/leetcode221.jpg" alt="示例"></p><p>可以观察到，当一个元素是1时，他的dp数组的值取决于<strong>左侧，左上，上方dp数组值的最小值</strong> </p><blockquote><p>当matrix[i][j] = 1时，dp[i][j] = 该元素min（左上，左侧，上方）+ 1</p></blockquote><p>我们可以先初始化dp数组的第一行与第一列，然后按照dp函数迭代<br><img src="/img/posts/Leetcode/leetcode221_step1.jpg"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第一列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">returnNum</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化第一行</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">returnNum</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当matrix[i][j] = 1时，dp[i][j] = 该元素min（左上，左侧，上方）+ 1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">returnNum</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getMin</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dp表达式</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token operator">*</span>max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> min_ab <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> min_ac <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min_ac<span class="token punctuation">,</span> min_ab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">returnNum</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">==</span><span class="token string">'0'</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h2><h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><blockquote><p>示例<br>    输入：n = 12<br>    输出：3<br>    解释：12 = 4 + 4 + 4</p></blockquote><blockquote><p>示例<br>    输入：n = 13<br>    输出：2<br>    解释：13 = 4 + 9</p></blockquote><p>转移方程: <strong>f(n) = 1 + min(f(n - j*j))</strong> (j小于n开方)</p><p>仍然是用<strong>数组来存每个状态</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 状态初态</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token operator">?</span><span class="token number">1</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token operator">:</span>min<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转移方程</span>            <span class="token punctuation">}</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">91.解码方法</a></h3><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为&nbsp; (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><blockquote><p>示例<br>    输入：s = “12”<br>    输出：2<br>    解释：它可以解码为 “AB”（1 2）或者 “L”（12）。</p></blockquote><p>分两种情况</p><blockquote><p>第一种情况是我们使用了一个字符，<strong>f[n] += f[n-1]</strong></p></blockquote><blockquote><p>第二种情况使用两个字符, <strong>f[n] += f[n-2]</strong></p></blockquote><p><img src="/img/posts/Leetcode/leetcode91_step1.jpg" alt="以三个字符为例"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isVaild</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">isVaild</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> num <span class="token operator">&lt;</span> <span class="token number">27</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">></span> <span class="token number">9</span><span class="token operator">?</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><blockquote><p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>    输出: true<br>    解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。注意，你可以重复使用字典中的单词。</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>此时用到异或之前的状态<br><strong>dp[i]=dp[i] ∣∣ dp[i−word.length()]</strong><br>比如 s = applepenapple, 当识别到 str[i-word.length, i]可以构成一个wordDict中的单词时，如果dp[i] = true，需要满足：<br>dp[i-word.length] = true</p><p>但不能粗暴的写成dp[i] = dp[i-strLen]==true?true:false;<br>因为如果wordDict时[apple,pen,le]，当识别到apple中的le时，会进行dp[i-word.length]的判断，但此时l并不满足条件，所以dp[i]会变成false，显然不对</p><p>我们需要找到一个只要dp[i]=true了，就不会再改变的方式<br>所以采用<strong>异或</strong>，<strong>dp[i] |= dp[i-strLen]</strong></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>String str<span class="token operator">:</span> wordDict<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> strLen <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>strLen<span class="token punctuation">)</span><span class="token punctuation">{</span>                    String substr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">-</span>strLen<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>substr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">// dp[i] = dp[i-strLen]==true?true:false;</span>                          dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>strLen<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// dp[i] = false;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>回文问题可以用dp来判定，假设boolean dp[1][3]记录了从1-&gt;3的子字符串是否为回文串，那么判断dp[0][4]是否为回文串可以根据</p><blockquote><p>dp[0][4] = (s.charAt(0)==s.charAt(4) &amp;&amp; dp[1][3])?true:false;</p></blockquote><p>整理为通用公式<strong>dp[start][end] = (s[start]==s[end] &amp;&amp; dp[start+1][end-1])</strong></p><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>right<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>left<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span><span class="token number">2</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>                        max <span class="token operator">=</span> right<span class="token operator">-</span>left<span class="token punctuation">;</span>                        start <span class="token operator">=</span> left<span class="token punctuation">;</span>                        end <span class="token operator">=</span> right<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>该题中判断回文的起始状态要分三种情况 <strong>dabac</strong>, <strong>dabbc</strong>, <strong>dbbac</strong>,也就是中心扩散，中心右扩散和中心左扩散<br>所以在判断条件处需要或一个(right-left&lt;=2),也就是任意满足一种扩散条件都可以</p><p>java类中substring的用法：s.substring(0,2)只包含s[0]和s[1]，所以如果要返回s[0-2],需要写作s.substring(0,3)</p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42.接雨水</a></h2><p><img src="/img/posts/Leetcode/leetcode42.jpg"></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>先左遍历，当最后一个子容器为[高，低]而非[高，低，高]时，也就是最后一个子容器没有封口时，再右遍历</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> subsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 先从左往右，把整个容器分为多个[高，低，高]容器，获得所有形如[高，低，高]的容器中的容量</span>        <span class="token comment" spellcheck="true">// 但此时需要注意几种特殊情况</span>        <span class="token comment" spellcheck="true">// 1. 结尾形如[2,4,3,2],此时最后三个并没有形成[高，低，高]，而是[高，低]，因此最后一个容器并没有封口</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>                subsum <span class="token operator">+=</span> max <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                max <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                sum <span class="token operator">+=</span> subsum<span class="token punctuation">;</span>                subsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 当最后一个容器没有封口时，也就是subsum!=0，此时有形如[高，低]的容器在尾部</span>        <span class="token comment" spellcheck="true">// 从右往左遍历，直到遇到[高，低]容器中的最高点</span>        <span class="token comment" spellcheck="true">// 注意边界， while的边界要 &lt; 最高点</span>        <span class="token comment" spellcheck="true">// 可能导致最后的submax仍然不为0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>subsum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            subsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right_max <span class="token operator">=</span> height<span class="token punctuation">[</span>height<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right_max<span class="token punctuation">)</span><span class="token punctuation">{</span>                    subsum <span class="token operator">+=</span> right_max <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    right_max <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    sum <span class="token operator">+=</span> subsum<span class="token punctuation">;</span>                    subsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当形如[4,2,3]时，由于从左往右遍历时，[高，低]没有封口</span>        <span class="token comment" spellcheck="true">// 从右往左遍历时，最后的subsum不为0</span>        <span class="token comment" spellcheck="true">// 所以在最后的返回值处要在sum的基础上加上subsum</span>        <span class="token keyword">return</span> sum<span class="token operator">+</span>subsum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>下标为i处的高度可以接到的最多的雨水等于<strong>其左边最大值与其右边最大值两者取小</strong>减去i处的高度，因为下标为i的柱子处在左边最大值与右边最大值围成的区域中，这个区域可以接到的雨水高度只取决于左边最大值的柱子，那么我们再用左边最大值的柱子减去i处的高度就得到了下标为i处的高度可以接到的最多的雨水</p><p>使用两个数组，leftMax[i], rightMax[i]分别表示包括柱子i的左边最大值，与右边最大值</p><p>初始状态为：</p><blockquote><p>leftMax[0] = height[0];<br>  rightMax[height.length - 1] = height[height.length - 1];</p></blockquote><p>递推公式为：</p><blockquote><p>leftMax[i] = max(leftMax[i - 1], height[i]);<br>  rightMax[i] = max(rightMax[i + 1], height[i]);</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> left_max<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>height<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right_max<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>height<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        right_max<span class="token punctuation">[</span>height<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>height<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> left_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left_max<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> right_max<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right_max<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边最大值或者右边最大值小于等于i处的柱子的高度，那么显然这个柱子本身作为了区域的边界</span>            <span class="token comment" spellcheck="true">//那么它可以接到的雨水显然为0</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> right_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> maxSize <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> right_max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101-贪心算法</title>
      <link href="/2023/03/09/leetcode101-tan-xin-suan-fa/"/>
      <url>/2023/03/09/leetcode101-tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h2><p>贪心算法是一种求解最优化问题的算法，它的核心思想是通过每一步选择局部最优解来达到全局最优解。</p><p>举一个简单的例子：假设你有一个背包，可以容纳重量为W的物品，现在有n个物品，每个物品的重量为wi，价值为vi。你想要在背包中装入尽可能多的价值，但是不能超过背包的容量。这个问题可以使用贪心算法来解决。</p><p>情景解释：<br>对于每个物品，我们可以计算其单位重量的价值，也就是vi/wi，然后按照这个值从大到小排序。然后我们依次将物品放入背包中，直到背包装满或者所有物品都放入为止。每次选择的物品都是当前剩余物品中单位重量价值最大的物品，这样可以保证我们在背包容量固定的情况下，放入的物品总价值最大。</p><p>具体实如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">knapsack</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> wt<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>val<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算每个物品的单位重量价值</span>    unit_val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>wt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> wt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 按照单位重量价值从大到小排序</span>    unit_val<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 初始化当前背包重量和价值</span>    curr_wt<span class="token punctuation">,</span> curr_val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 依次将物品放入背包中</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> curr_wt <span class="token operator">+</span> unit_val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> W<span class="token punctuation">:</span>            curr_wt <span class="token operator">+=</span> unit_val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            curr_val <span class="token operator">+=</span> unit_val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 如果背包已经装满了，则跳出循环</span>            <span class="token keyword">break</span>    <span class="token keyword">return</span> curr_val</code></pre><p>在这个代码中，我们首先计算每个物品的<strong>单位重量价值</strong>，并按照这个值从大到小<strong>排序</strong>。然后我们依次将物品放入背包中，直到背包装满或者所有物品都放入为止。<strong>每次选择的物品都是当前剩余物品中单位重量价值最大的物品</strong>。最后返回背包中物品的总价值。</p><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值&nbsp;g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>&nbsp;</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span></code></pre><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy">135. 分发糖果</a></h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>思路：因为若是ratings= [1,3,5,2,1], candy = [1,2,3,2,1], 因为rating[2] = 5&gt;rating[1]=3，所以ratings[2]=3</strong><br><strong>注意，该题需要左遍历一遍，再右遍历一遍</strong></p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scoreArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        scoreArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> child <span class="token operator">&lt;</span> ratings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> child<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> ratings<span class="token punctuation">[</span>child<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> scoreArr<span class="token punctuation">[</span>child <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        score <span class="token operator">=</span> scoreArr<span class="token punctuation">[</span>child <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        child <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>child <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> child<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> ratings<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">></span>scoreArr<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">?</span> scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">:</span><span class="token punctuation">(</span>scoreArr<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                score <span class="token operator">+=</span> scoreArr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> score<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals">435.无重叠区间</a></h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p>示例 1:</p><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p><p>输入: intervals = [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p><p>输入: intervals = [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><h3 id="解法一：按end快排"><a href="#解法一：按end快排" class="headerlink" title="解法一：按end快排"></a>解法一：按end快排</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">:</span> intervals<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>                end <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// System.out.println("i:"+i+" "+j);</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> pivot <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> i<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// System.out.println("j:"+i+" "+j);</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp_a <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp_b <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp_a<span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp_b<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解法二：直接调用Arrays-sort-不自己写快排"><a href="#解法二：直接调用Arrays-sort-不自己写快排" class="headerlink" title="解法二：直接调用Arrays.sort,不自己写快排"></a>解法二：直接调用Arrays.sort,不自己写快排</h3><p>由于此时是比较每个数组的第1位元素，也就是a[1]和b[1]</p><p>因此直接将解法一中的</p><pre class=" language-java"><code class="language-java"><span class="token function">QuickSort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>换为</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// QuickSort(intervals, 0, intervals.length-1);</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">:</span> intervals<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>                end <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode--双指针</title>
      <link href="/2023/02/11/leetcode-shuang-zhi-zhen/"/>
      <url>/2023/02/11/leetcode-shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="一些Java中指针的基本概念"><a href="#一些Java中指针的基本概念" class="headerlink" title="一些Java中指针的基本概念"></a>一些Java中指针的基本概念</h2><p>java“指针”就是对象的引用，是存放在堆中的，因为Java中对象是存放在堆中。我们知道java中的内存分为堆内存（heap）和栈内存（stack）。堆就是用来存放对象的，而栈则是存放一些数据基本类型的值，如int,float,double,char…….</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>JVM只有一个堆区，在虚拟机启动时创建，被所有线程共享，堆区不放基本类型（成员变量除外）和对象的引用，只存储对象本身（包括class对象和异常对象）和数组，堆是GC所管理的主要区域（对不需要的对象进行标记，而后进行清除）<br>堆是用来存放程序动态生成的数据。（<strong>new 出来的对象的实例存储在堆中</strong>，但是<strong>仅仅</strong>存储的是成员<strong>变量</strong>，也就是平时所说的实例变量，<strong>成员变量的值</strong>则存储在常量池中。成员方法是此类所实现实例共享的，并不是每一次new 都会创建成员方法。成员方法被存储在方法区，并不是存储在第一个创建的对象中，因为那样的话，第一个对象被回收，后面创建的对象也就没有方法引用了。静态变量也存储在方法区中。局部变量在栈内存中，JVM为每一个类分配一个栈帧，然后引用类型的局部变量指向堆内存中的地址），堆是内存中共享的区域，要考虑线程安全的问题。</p><h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>用来存放基本数据类型和引用数据类型的实例的（也就是实例对象的在堆中的首地址，Person p = new Person; p存贮在堆栈中,值为@23651dff。还有就是堆栈是线程独享的。每一个线程都有自己的线程栈。</p><h3 id="x3D-x3D-与equal"><a href="#x3D-x3D-与equal" class="headerlink" title="==与equal"></a>==与equal</h3><ul><li><p>‘==’比较的是地址</p></li><li><p>equals比较的是内容</p></li></ul><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h2><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">题目</a>:给你一个下标从 1 开始的整数数组&nbsp;numbers ，该数组已按 非递减顺序排列&nbsp; ，请你从数组中找出满足相加之和等于目标数&nbsp;target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。<br>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。<br>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。</p><p><img src="/img/posts/Leetcode/leetcode167.jpg" alt="Leetcode167图示"></p><h3 id="暴力解决法"><a href="#暴力解决法" class="headerlink" title="暴力解决法"></a>暴力解决法</h3><p>虽然不太聪明，但很暴力</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>直接用index1和index2， 如果</p><ol><li>number[index1]+number[index2]&lt;target，index2右移</li><li>number[index1]+number[index2]&gt;target, index1右移， 且index2归位，index2=index1+1</li><li>number[index1]+number[index2]=target, 返回该值</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> index_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>index_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> index_1 <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token operator">+</span>numbers<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token operator">&amp;&amp;</span>index_2 <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>                index_2<span class="token operator">++</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index_1<span class="token operator">++</span><span class="token punctuation">;</span>                index_2<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                index_1<span class="token operator">++</span><span class="token punctuation">;</span>                index_2 <span class="token operator">=</span> index_1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> results <span class="token operator">=</span> <span class="token punctuation">{</span>index_1<span class="token punctuation">,</span>index_2<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> results<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="双指针法（推荐）"><a href="#双指针法（推荐）" class="headerlink" title="双指针法（推荐）"></a>双指针法（推荐）</h3><p>注意该数组是一个有序的递增数组，所以可以用该方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="剑指offer18：-删除链表中的节点"><a href="#剑指offer18：-删除链表中的节点" class="headerlink" title="剑指offer18： 删除链表中的节点"></a>剑指offer18： 删除链表中的节点</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/509cy5/">题目</a><br>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><h3 id="单指针法"><a href="#单指针法" class="headerlink" title="单指针法"></a>单指针法</h3><p>构造一个虚拟链表 cur 以 0 开始，并让该链表指向头指针 cur.next = head; 假设 head 为 <strong>1-&gt;2-&gt;3-&gt;4</strong><br>此时 cur = 0-&gt;1-&gt;2-&gt;3-&gt;4</p><p>若要删除数字3，需要利用<strong>cur.next.val</strong>来判断是否与val相等, 当cur.next.val = 3时，此时cur = 2-&gt;3-&gt;4<br>删除3要求，cur-&gt;next = cur-&gt;next-&gt;next<br>cur = 2-&gt;4, 同时head中的3也被删去了</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> ListNode <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> ListNode <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>cur <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="88-合并两个数组"><a href="#88-合并两个数组" class="headerlink" title="88.合并两个数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88.合并两个数组</a></h2><p>给你两个按 非递减顺序 排列的整数数组&nbsp;nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n </p><blockquote><p>示例：<br> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br> 输出：[1,2,2,3,5,6]<br> 解释：需要合并 [1,2,3] 和 [2,5,6] 。<br> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p></blockquote><h3 id="双指针法（推荐）-1"><a href="#双指针法（推荐）-1" class="headerlink" title="双指针法（推荐）"></a>双指针法（推荐）</h3><p>需注意for的结束条件是j&gt;=0， 对于i的判断放入了for中的第一个if判断<br>当i &gt; 0且 nums1[i] &gt; nums2[j]时，才满足第一个条件</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> m<span class="token operator">+</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>虽然有点笨，但有用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> index_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token punctuation">;</span>                index_1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>                index_2<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>index_1 <span class="token operator">>=</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_2<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>index_2 <span class="token operator">>=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_1<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>index_1<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_1<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span><span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>index_2<span class="token punctuation">]</span><span class="token punctuation">;</span>                    index_2<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// System.out.println(nums1[j]);</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="尾部遍历法"><a href="#尾部遍历法" class="headerlink" title="尾部遍历法"></a>尾部遍历法</h3><p>从数组后面往前填，直接将nums2填入nums1，然后对nums1进行排序<br>要记得活用**Arrays.sort()**方法哇</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums1<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="142-环形链表-https-leetcode-cn-problems-linked-list-cycle-ii-submissions"><a href="#142-环形链表-https-leetcode-cn-problems-linked-list-cycle-ii-submissions" class="headerlink" title="(142.环形链表)[https://leetcode.cn/problems/linked-list-cycle-ii/submissions/]"></a>(142.环形链表)[<a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/]">https://leetcode.cn/problems/linked-list-cycle-ii/submissions/]</a></h2><p><img src="/img/posts/Leetcode/leetcode547.jpg"></p><p>假设从头节点走到入环节点需要a步， 每个环中有b个元素（也就是b步走完一个环）<br>核心在于确定当快慢指针相遇时的条件：</p><ol><li>当第一次slow和fast相遇：此时 <strong>fast=2 slow</strong><br> 但由于fast比slow多走了nb<br> 可以得出 **fast = 2 nb ** <strong>slow = nb</strong><br>但关键在于确定从从头节点走到入环点，由于从头节点走到入环点 = a， 走完这个环 = b，所以从此时slow再走a步就可以到达入环的节点，因为此时slow已经走了nb步了</li><li>所以此时将fast放到head，从head走到入环点需要a步，而在环中的slow要再度走到入环点也需要a步，当fast和slow相遇的时候就是入环点了</li></ol><p><img src="/img/posts/Leetcode/leetcode547_explanation.jpg" alt="图解"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>                        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>        fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">{</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> fast<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习笔记1--概述</title>
      <link href="/2022/10/05/ji-suan-ji-wang-luo-fu-xi-bi-ji-1/"/>
      <url>/2022/10/05/ji-suan-ji-wang-luo-fu-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p>复习计算机网络相关知识</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol><li>速率<br>网络技术中的速率指的是<strong>数据的传送速率</strong>，也称为<strong>数据率</strong>或<strong>比特率</strong>。单位是bit/s。<br>一般提到网络的速率指的是额定速率（标定速率），而非实际运行的速率。</li><li>带宽<br>贷款用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示再单位时间内网络中<strong>某信道</strong>所能通过的<strong>最高数据率</strong>。单位是bit/s</li><li>吞吐量<br>在单位时间内通过某个网络（或信道、接口）的<strong>实际数据量</strong>。吞吐量收网络带宽与网络额定速率的限制。接入网络主机的实际吞吐量取决于<strong>互联网的具体情况</strong>。</li><li>时延<br>数据（一个报文、分组甚至比特）从网络的一端到另一端所需的时间。<br>总时延 = 发送时延+传播时延+处理时延+排队时延<br>主要影响是<strong>发送时延</strong>和<strong>传播时延</strong><br>传播时延是比特在链路上传播的时延。</li><li>时延带宽积<br>时延带宽积 = 传播时延 x 带宽<br>等同在任何特定时间该网络线路上的<strong>最大数据量</strong>——已发送但尚未确认的数据。<br>链路像一个空心管道，时延是管道长，带宽是管道切面面积</li><li>往返时间RTT<br>大部分情况下，互联网上的信息不是单方传输而是双向交互的。</li></ol><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>协议</strong>: 网络协议是为进行网络中的数据交换而建立的规则。这些规则明确规定了数据的格式以及预期有关的同步问题。<br>协议主要由一下三个要素组成：语法（数据和控制信息的结构或者格式）、语义（需要发出何种控制信息）、同步（时间实现顺序的详细说明）。</p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="/img/posts/ComputerNetwork/OSI.jpg" alt="OSI"><br><img src="/img/posts/ComputerNetwork/TCP_IP.jpg" alt="TCP/IP"><br><img src="/img/posts/ComputerNetwork/OSI_TCPIP.jpg" alt="OSI与TCP/IP的对比"><br>OSI有七层<strong>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</strong><br>TCP/IP：<strong>网络接口层，网络层，传输层，应用层</strong>，TCP/IP的网络接口处覆盖率 OSI中的物理层和数据链路层</p><p><strong>网络层</strong></p><p>提供<strong>主机和主机</strong>之间的逻辑通信</p><p>协议有ARP协议、OSPF/RIP路由寻址协议、DHCP协议、ICMP协议、IGMP组播协议、IP协议、CIDR协议</p><p>设备有路由器（作用：转发分组）</p><p><strong>传输层</strong></p><p>提供端到端的可靠报文传递，负责将数据传送至对应端口，提供<strong>进程和进程</strong>之间的逻辑通信</p><p>协议有TCP UDP协议</p><p><strong>会话层</strong></p><p>负责建立、管理、终止进程之间的会话</p><p><strong>表示层</strong></p><p>对上层数据或者信息进行变换，以保证一个主机应用层信息可以被另一个主机应用层所理解，包括数据加密、格式转换、压缩等</p><p><strong>应用层</strong></p><p>为操作系统或者网络应用程序提供访问网络的接口 协议有HTTP FTP SMTP DNS协议</p><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>实现数据包的路由和转发，IP协议为每个数据包分配一个唯一的IP地址，以便数据包在网络中进行传输</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>用于网络设备之间传递错误信息和控制信息，例如ping命令就是通过ICMP协议实现的。</p><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>地址解析协议，将IP地址转为MAC地址</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>是开放式最短路径优先协议，用于实现路由协议，控制数据包在网络中的传输路径，以提高网络的可靠性和稳定性。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>用于实现可靠的数据传输和流量控制，确保数据包能够按照正确的顺序到达目的地。</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>用于实现不可靠的数据传输，适合实时数据传输，如视频和语音等。</p><h3 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h3><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>边界网关协议，用于控制Internet中的路由信息，管理自治系统之间的连接和数据流向</p><h4 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h4><p>多标签交换，用于在数据包传输过程中标记和识别数据包，提高网络的传输效率和可靠性。</p><h4 id="ISIS"><a href="#ISIS" class="headerlink" title="ISIS"></a>ISIS</h4><p>中间系统到中间系统，用于实现网络中的路由协议，控制数据包在网络中的传输路径，以提高网络的可靠性和稳定性。</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>路由信息协议，用于实现路由协议，控制数据包在网络中的传输路径，是一种基于距离向量算法的路由协议。</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP是面对<strong>连接的</strong>传输层协议，提供可靠的数据传世。TCP用<strong>检验和、标号、流量控制、拥塞控制、超时重传</strong>等机制保证TCP连接是可靠的，UDP则不保证可靠交付，只保证尽力交付。TCP的数据传输以<strong>字节流</strong>的形式，UDP的数据传输是以<strong>报文段</strong>的形式</p><p>UDP是<strong>无连接的</strong>的传输协议，提供不可靠的数据传输，通过UDP数据报进行数据传世不能保证数据可靠性。但UDP穿的较快，适用于对实时性要求较高的场景</p><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><p><strong>分段</strong> 将报文段分成适合转发的长度</p><p><strong>标号</strong> 按照序号判断中间的转发是否有缺失</p><p><strong>流量控制</strong> 根据双方的接收发送能力，动态地调整发送方发送窗口的大小，取发送窗口=min(拥塞窗口，接收窗口) （与数据链路层收不下的话返回一个信号告诉发送方自己收不下的流量控制机制不同）</p><p><strong>检验和</strong> TCP首部有检验和字段，目的是检验首部+数据部分的数据是否正确，是不是被人篡改或半路出现差错。</p><p><strong>超时重传</strong> 发出报文段之后启动定时器，如果重传时间RTT内没有收到确认的话，就重传该数据报，也可以采用冗余确认机制（三次接收到同一个ack=k的确认序号，就重传第k个报文段）（快重传中采用的也是冗余重传）</p><p>主要涉及的协议有两种（跟数据链路层的超时重传机制相同）：</p><p><strong>停止等待协议</strong> 每发送一个报文段就停止，直到收到确认才继续发送，否则超时重传<br><strong>滑动窗口协议</strong><br>后退N帧协议 GBN： 发送窗口&gt;1，接收窗口=1，即接收方必须按照顺序去接收数据，如果启用了超时重传机制的话，就会重传所有当前已经发送但是没有被确认的报文段<br>选择重传协议 SR： 发送窗口&gt;1，接收窗口&gt;1，即接收方无需按照顺序去接收数据，会按照任意顺序接收所有处于接收窗口内的数据。按照如果启用超时重传机制的话只需要重新发送没有收到确认的数据即可。<br><strong>拥塞控制 分为两种：①慢开始，拥塞避免 ②快重传、快恢复</strong></p><p><strong>检验和</strong>是TCP和UCP中都有的 要注意检验的是首部和数据字段的有效性</p><p>1.添上伪首部<br>2.首部检验和字段置为0<br>3.伪首部+首部+data部分用二进制反码求和，并将结果填入到检验和字段<br>4.去掉伪首部发送<br>5.发送方接受到该数据之后，首先添上伪首部<br>6.接着计算伪首部加首部加数据部分的二进制反码求和<br>7.如果全为1则无差错，去掉伪首部交给网络层，否则丢弃。</p><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><blockquote><p>三次握手（用于建立连接） 1. 客户端-&gt;服务器发送一个SYN，请求建立连接 2. 服务器接收到SYN后向客户端发送SYN+ACK，同意建立连接 3. 客户端接收到服务器的SYN+ACK后，向服务器发送一个ACK表示确认收到服务器的SYN+ACK。连接建立</p></blockquote><blockquote><p>四次挥手（用于断开连接） 1.<strong>客户端发送FIN报文给服务器端</strong>，并进入到FIN-WAIT1阶段，该FIN报文包括首部字段控制位FIN=1，序列号seq=u，告诉服务器我已完成我的数据传输工作，你这边如果还有数据可以继续传送(<strong>发送断开连接的请求</strong>) 2. <strong>服务器收到该FIN报文之后进入close-wait阶段，并返回一个ACK给客户端</strong>，该确认报文包括首部控制位ACK=1，seq=v，ack=u+1。客户端收到该确认报文后进入fin-wait2状态，关闭从客户端到服务器端的数据传送。服务器端仍可向客户端传送数据。 3. <strong>服务器接着发送一个FIN给客户端</strong>,该报文结构包括FIN=1,ACK=1,序列号为w，确认号为u+1，并进入Last-ACK状态 4. <strong>客户端接收到后发送一个ACK</strong>,该确认报文包括首部控制位ACK=1，序列号为u+1，确认号为w+1，并进入time-wait阶段，等待2MSL后确认服务器端收到ACK报文正常断开连接后，客户端关闭。服务器端收到该确认报文，进入closed状态。 至此连接断开</p></blockquote><p><strong>等待2MSL的原因</strong> 确认服务器端是否正常收到了客户端最后发出的确认报文，如果服务器端没有收到的话，过1MSL（报文在网络中的最大存活时间）会重新再发送一次FIN报文给客户端，如果过了2MSL还没有收到新发的FIN报文的话，证明服务器端已经收到确认报文并正常关闭连接，客户端也可以关闭连接。</p><h3 id="为什么三次握手？为什么四次挥手？"><a href="#为什么三次握手？为什么四次挥手？" class="headerlink" title="为什么三次握手？为什么四次挥手？"></a>为什么三次握手？为什么四次挥手？</h3><p><strong>三次握手的原因</strong></p><p><strong>确保双方间的连接正常建立</strong>，如果只有两次握手的话可能会出现一些异常情况，比如：①客户端的SYN连接请求失效(或者发去时间太久,导致了超时重传的发生)，但是服务器端接收到了该SYN报文，如果不经过第三次握手的话服务器端就会错误地开启一个连接；③如果只有两次握手地话，服务器端返回给客户端的确认报文丢失，会导致客户端因为没有收到确认所以关闭了该连接，但服务器端此时已做好了连接准备，造成资源的浪费</p><p><strong>四次挥手的原因</strong></p><p>因为建立连接时双方都处于closed状态，而释放连接时一方收到FIN报文但有<strong>可能还有数据要继续传输</strong>，不能马上释放连接，所以先返回一个确认报文，<strong>发送完数据后再断开连接</strong></p><h2 id="SYN洪泛攻击如何解决？"><a href="#SYN洪泛攻击如何解决？" class="headerlink" title="SYN洪泛攻击如何解决？"></a>SYN洪泛攻击如何解决？</h2><p><strong>SYN洪范攻击</strong>攻击者伪装成客户端发送TCP的SYN报文, 当服务器返回ACK确认报文之后, 攻击者不再进行确认, 即不回复确认的确认报文, 这个连接就处于一个挂起的状态, 服务器收不到确认报文的话, 会启用超时重传机制, 重复发送ACK给攻击者</p><p>这样的话,如果攻击者开启大量这种TCP连接, 导致服务器端有很多个挂起的连接, 并且需要重复发送很多ACK给攻击者, 这样就会消耗服务器的内存 可能导致最后服务器死机, 无法正常工作</p><p>解决方法</p><p><strong>降低SYN timeout时间</strong> 使得服务器在没收到确认报文后尽快释放半连接的占用<br><strong>采用SYN cookie设置</strong> 给每一个请求连接的ip地址分配一个cookie,短时间内如果连续收到某个IP的重复的SYN报文,就认定收到了攻击,以后会自动丢弃该ip地址传送过来的包</p><h2 id="TCP拥塞控制的原理"><a href="#TCP拥塞控制的原理" class="headerlink" title="TCP拥塞控制的原理"></a>TCP拥塞控制的原理</h2><ol><li>慢开始，在开始传播数据时，TCP会以指数级别增加传输速率，直到发现网络拥塞</li><li>拥塞避免：一旦发现网络拥塞，TCP会以线性级别的速度降低传输速率，以避免网络拥塞进一步加剧。</li><li>快重传和快恢复：当发现数据包丢失时，TCP会进行快速重传，避免等待超时后再进行重传。</li></ol><p><strong>快重传</strong>：当发生包文丢失时，为了让发送方尽早知道发生了个别报文段的丢失，因此立即发送确认，怎样让发送方知道是哪个报文段丢失的方法就是连读发送三个确认。<br><strong>快恢复</strong>：发送方知道现在只是丢失了个别的报文段。于是不执行慢开始，而是执行快恢复算法。</p><h2 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h2><p>在传输过程中，出现<strong>多个数据包合在一起</strong>（粘包），或<strong>一个数据包被拆分成多个数据包</strong>（拆包）传输</p><p>粘包/拆包都可能导致数据传输的混乱，解决方案：</p><ol><li>定长包处理：将<strong>数据按照固定长度</strong>进行分割，每个数据包长度相同，接收方按照固定长度介绍数据，避免了粘包和拆包问题<br>2.分隔符处理：将数据包<strong>按照特定的分隔符</strong>进行分割，每个数据包的长度不同，<strong>接收方</strong>根据<strong>分隔符来判断数据包的边界</strong>，避免了粘包和拆包问题。</li><li>增加<strong>消息头</strong>处理：在<strong>每个数据包的头部</strong>增加<strong>一个固定长度的消息头</strong>，用于描述<strong>数据包的长度、类型等信息</strong>，接收方根据消息头来接收数据，避免了粘包和拆包问题。</li></ol><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><p>HTTP：明文传输，不使用SSL/TLS协议加密。用于传输一些不敏感的信息</p><p>HTTPS：使用SSL/TLS加密传输，保证数据的安全性和可靠性</p><h3 id="HTTP中的长连接和短连接"><a href="#HTTP中的长连接和短连接" class="headerlink" title="HTTP中的长连接和短连接"></a>HTTP中的长连接和短连接</h3><p>长连接和短连接是指客户端和服务器之间TCP连接持续的师姐</p><ul><li><p>短连接：每次请求和响应都会建立一个新的TCP连接，完成后客户端立即关闭连接，同时服务器也<strong>立即</strong>释放连接。短连接节省资源，但建立连接的开销较大，对于频繁请求会有较大的延迟，不适合长时间通信。</p></li><li><p>长连接：客户端和服务器建立一个TCP连接后，可以重复使用该链接进行多次请求和响应，直到客户端/服务器发送终止连接的请求/响应。长连接可以减少建立连接的开销和延迟，适合长时间通信，但会占用一定的资源和带宽。</p></li></ul><p>在HTTP/1.1之前，HTTP协议默认使用短连接。在HTTP/1.1中，HTTP协议默认使用长连接，但客户端和服务器可以通过在请求头或响应头中添加”Connection: close”字段来关闭连接。</p><h2 id="http协议的发展历程（1-0-1-1-2-0-3-0）"><a href="#http协议的发展历程（1-0-1-1-2-0-3-0）" class="headerlink" title="http协议的发展历程（1.0 1.1 2.0 3.0）"></a>http协议的发展历程（1.0 1.1 2.0 3.0）</h2><p><strong>http1.0和http 1.1的主要区别是什么？</strong></p><p>1.<strong>连接</strong> HTTP1.0默认使用短连接，每次请求不同的资源都需要重新建立一次连接；HTTP1.1起默认使用长连接，默认开启keep-alive，即同一个TCP连接可以发送和接收多个http请求/响应，这种长连接由流水线方式和非流水线方式，流水线方式是指客户在收到http响应报文之前就能够接着发送新的请求报文，非流水线方式是指客户在收到http响应报文后才能接着发送下一个请求</p><p>2.<strong>状态码</strong> HTTP1.1新增24个状态码，409表示请求的资源与资源当前状态发生冲突，410Gone指的是服务器上某个资源被永久删除</p><p>3.<strong>带宽优化及网络连接使用</strong> ——http1.1支持断点续传，HTTP1.0中不支持只显示对象的一部分（只能显示全部）、且不支持断点续传功能，浪费带宽；HTTP1.1在请求头中引入了range头域，允许只请求资源的某个部分，返回码是206（partial content）</p><p><strong>http2.0的改进</strong></p><p>1.<strong>头部压缩</strong> 减少冗余头信息，用了首部表来跟踪、存储之前的键值对，相同的数据就无需再每次重复请求和响应了</p><p>2.<strong>多路复用</strong> 实现由一个tcp连接并发请求。http1.1多个请求的响应之间会被阻塞</p><p>3.<strong>服务器推送</strong>：可以主动将资源推送给客户端缓存中</p><p>4.<strong>二进制格式</strong>：采用二进制而非文本格式，将所有传输的信息分割为更小的消息和帧（二进制帧）</p><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>域名解析：浏览器根据URL中的域名，向本地DNS服务器发送域名解析的请求<br>本地DNs解析：本地DNS服务器收到请求后，1.在DNS缓存中查找是否有对应的IP，若有，直接返回。 2. 若没有本地DNs服务器向互联网上的root 服务器发送请求<br>根DNS解析：根服务器收到请求后，转发给顶级域名服务器<br>顶级域名服务器解析：转发给对应的刺激域名服务器<br>次级域名服务器：收到请求后，在自己的DNS缓存中查找对应的IP，若有，返回；否则向下一级域名发送请求直到找到。</p><h2 id="输入URL到显示网页发生了什么"><a href="#输入URL到显示网页发生了什么" class="headerlink" title="输入URL到显示网页发生了什么"></a>输入URL到显示网页发生了什么</h2><p><strong>浏览器解析URL对应的IP地址</strong><br>​ 1. 首先，浏览器会将URL分解为三个部分：协议（例如http或https），主机名（例如<a href="http://www.example.com)和资源路径(例如/index.html%EF%BC%89%E3%80%82">www.example.com）和资源路径（例如/index.html）。</a><br> 2. 浏览器会检查本地缓存，看是否存在与该URL相对应的缓存文件。如果存在，浏览器会从缓存中加载网页，并跳转到第9步。如果不存在，则会进行下一步。<br> 3. 浏览器会使用DNS（域名系统）将主机名解析为IP地址。</p><p><strong>浏览器会建立一个与服务器的TCP（传输控制协议）连接。</strong><br>这是通过在浏览器和服务器之间发送和接收数据包来实现的。</p><p><strong>浏览器向服务器发送一个HTTP请求报文</strong><br>​ 传输层上建立TCP连接，网络层用到了IP协议(负责在网络层传输数据），还会用到RIP或者OSPF进行路由选择，然后用ARP协议解析IP地址对应的MAC地址，使得数据能够在数据链路层上进行传输（不应该是最后到物理层传输吗）。</p><p>​ HTTP请求方法有哪些（post/get/head/put/delete）</p><p><strong>服务器请求处理并返回一个HTTP响应报文</strong><br>​ HTTP响应报文的结构，状态码<br>浏览器收到响应并解析响应头，然后检查状态码。如果状态码是200 OK，表示请求成功。如果状态码是301或302，表示需要重定向到另一个URL。如果状态码是404，表示请求的资源不存在。如状态码是500，表示服务器出现错误。</p><p><strong>服务器返回一个HTML响应，浏览器收到HTML响应并渲染界面</strong><br>浏览器根据响应头和响应体渲染网页并显示在屏幕上。<br>如果网页中有其他资源（例如图片、CSS文件或JavaScript文件），则浏览器会执行类似的步骤来获取这些资源并在网页中显示。</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>注意存放在请求行和请求体的不是方法 而是请求/提交的数据啊喂 post和get方法都是在请求行中啦</p><p>1.get数据明文存放在http请求行的url之后，post则是将提交的数据放在http请求报文的请求体中</p><p>2.受浏览器对url长度的限制，get传送数据量应不超过2KB。post传送数据量则一般无此限制</p><p>3.get只接受acsii字符，post没有限制，get只支持url编码，post没有限制</p><p>4.get不能改变服务器的数据，一般用于从服务器获取数据，是幂等的；post可以改变服务器的数据，不是幂等的。</p><p>5.get请求可以被浏览器主动缓存，下一次若传输数据相同，则优先返回缓存中的内容，以加快显示速度。post请求不会，除非手动设置一下</p><p>6.get请求参数会被完整地保存在浏览器历史记录中，post请求参数则不会保留</p><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p><strong>1xx 表示正在处理</strong></p><p>100 continue 一切正常 可以继续发送（据说是http报文中如果有post方法的话 会先把请求行发送过去，然后返回100，然后再发送请求头部和请求体给服务器端）<br><strong>2xx 成功 表示请求已经正常处理</strong></p><p>200 OK 一切正常返回数据<br>204 No content 请求正常处理，但是没有数据返回<br>206 指定范围返回（http1.1以上支持的断点续传功能相关）<br><strong>3xx 重定向 浏览器需要一些额外的操作才能完成请求</strong></p><p>301 永久性重定向<br>302 暂时性重定向（跟http劫持有关，运营商可以通过DNS劫持和http劫持两种，返回一个302，然后让用户跳转到处理好的携带广告的页面）<br>303 暂时性重定向 但是服务器端明确说明希望浏览器用get方法来请求资源<br>304 浏览器附带了请求的条件，服务器端允许访问，但是不满足请求条件<br><strong>4xx 客户端错误</strong></p><p>400 客户端的请求有语法错误<br>403 forbidden 客户端申请访问的资源被禁止访问<br>404 Not found 客户端申请访问的资源不存在<br>405 Method not allowed 客户端请求方法被禁止<br><strong>5xx 服务器端错误</strong></p><p>500 服务器在请求处理时内部出错<br>501 服务器不具备完成请求的功能，如无法识别请求方法<br>502 服务器作为网关或代理，从上游服务器获得无效响应<br>503 Bad Gateway 服务器处于停机维护/超负荷状态<br>504 Gateway timeout服务器作为网关或代理，没有及时从上游服务器获得响应</p><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><p>首先它们都是用于给无连接的http提供身份认证的功能</p><p>cookie是服务器在<strong>本机</strong>存放的小段文本，并随每一个请求发送至同一服务器。cookie分为<strong>会话cookie</strong>（不设置过期时间，关闭浏览器窗口cookie即失效，保存在内存中）和<strong>持久cookie</strong>（设置过期时间，关闭再打开浏览器cookie仍存在，直至达到过期时间）。类似于检查通行证（即请求报文中附带的cookie）来确定用户身份</p><p>session则一般是利用session id实现的（session id是浏览器第一次发送请求时服务器自动生成的唯一标识，并返回给浏览器），cookie中携带该session id，客户端根据该session id将session检索出来。类似于在<strong>服务器</strong>上建立一个客户档案，客户来访时需要查询客户档案</p><p>1.cookie是存放在客户端，用于记录用户信息的，比如自动填充用户名和密码；session是存放在服务器端的，用于记录用户的状态，比如购物车的实现。</p><p>2.cookie不太安全，可以分析存放在本地的cookie进行cookie欺骗，（也可以用加密算法加密后进行存放），session存放于服务器的内存中，所以安全性高</p><p>3.单个cookie保存数据不能超过4k，session没有对存储数据量的限制</p><p>禁掉cookie的话session仍然可以使用，但是需要使用其他方法获取session id，比如在url后面或者以表单的形式提交给服务器端</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码适用于指定IP地址的网络部分和主机部分组成<br>子网掩码也由32位二进制数表示，它的作用是将IP地址分为网络部分和主机部分，<strong>用于确定网络中的设备是否属于同一子网</strong>。通常，子网掩码与IP地址一起使用，可以将一个大的IP地址空间划分为多个子网，从而更有效地管理网络中的设备。</p><p>例如，假设一个公司拥有一个IP地址段为192.168.1.0/24的网络。这个IP地址段中包含的IP地址范围为192.168.1.1~192.168.1.254，其中，/24表示子网掩码为255.255.255.0。这个IP地址段中的每个IP地址的前三个数（即192.168.1）都是网络部分，最后一个数则是主机部分。子网掩码中为1的位表示网络部分，为0的位表示主机部分。在这个例子中，子网掩码中前24位都是1，表示网络部分，后8位都是0，表示主机部分。这样，我们可以将这个IP地址段划分为256个子网，每个子网最多包含254个IP地址。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡是一种常用的网络技术，用于<strong>将网络流量分配到多个服务器</strong>上，以实现更高的性能。<br>负载均衡的实际应用非常广泛，包括以下几个方面：</p><p>网站和应用服务器的负载均衡：负载均衡可以将网络流量分配到多个Web服务器和应用服务器上，以提高网站和应用程序的性能、可靠性和可扩展性。<br>数据库服务器的负载均衡：负载均衡可以将数据库流量分配到多个数据库服务器上，以提高数据库的性能、可靠性和可扩展性。<br>文件服务器的负载均衡：负载均衡可以将文件流量分配到多个文件服务器上，以提高文件共享的性能和可靠性。<br>DNS服务器的负载均衡：负载均衡可以将DNS查询流量分配到多个DNS服务器上，以提高DNS服务的性能和可靠性。</p><h2 id="防火墙是什么"><a href="#防火墙是什么" class="headerlink" title="防火墙是什么"></a>防火墙是什么</h2><p>防火墙是指一种网络安全设备，用于对网络流量进行监控和过滤，保护网络免受恶意攻击和威胁。防火墙可以通过过滤规则来控制网络流量的进出，对恶意流量进行拦截和阻止，从而保护网络的安全性和稳定性。</p><h2 id="IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址"><a href="#IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址" class="headerlink" title="IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址"></a>IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址</h2><p>MAC地址是网络中<strong>每个设备都有的唯一网络标识</strong>，全世界唯一。</p><p>IP地址只是<strong>逻辑上</strong>的标识，任何人都能随意修改，因此不能具体标识一个用户，但MAC地址固化在网卡里，防止被盗用。</p><p>但是如果只用MAC地址的话，因为MAC地址无序杂乱，没有明显规则，难以查找。但是IP是分层的，类似通讯地址，可以根据其网络号找到子网再定义主机，逐级查找，每个设备需要存储的信息较少</p><p>MAC地址与IP地址的区别：</p><p>①<strong>长度不同</strong>，IP地址一般为32位（IPv6 128位），MAC地址则是48位</p><p>②<strong>分配依据不同</strong>，IP地址分配基于网络拓扑，能够根据需要改动设备的IP地址，但是MAC地址的分配是基于制造商，在网卡中烧录好，一般不轻易改变</p><p>③<strong>寻址协议层不同</strong>，IP地址应用于<strong>网络层</strong>，MAC地址应用于<strong>数据链路层</strong>（数据链路层基于MAC地址转发数据帧，数据链路层的交换机根据其MAC地址记录表中的MAC地址及其对应的端口，将其发送到MAC地址对应的端口，否则广播；网络层则根据IP地址转发报文，路由器根据路由表转发到对应端口，否则发送默认路由）</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>作用：<strong>实现IP地址到MAC地址的映射</strong>（由IP地址获得MAC地址）</p><p>流程：根据主机A路由表的内容查找B的IP地址，再从A的ARP高速缓存中寻找是否有B的MAC地址，如果没有则广播ARP请求帧（构成为Aip+Bip+A_MAC+全1）至该局域网内所有的主机。如果主机发现该请求帧中的IP地址与自己的相同则返回一个单播ARP帧（构成为Bip+B_MAC)返回给主机A，并且AB均更新自己的ARP高速缓存。</p><h2 id="客户端故障检测方法？"><a href="#客户端故障检测方法？" class="headerlink" title="客户端故障检测方法？"></a>客户端故障检测方法？</h2><p>客户端故障检测方法—-<strong>保活计时器</strong></p><p>目的:在长连接的情况下,检测没有响应的连接并且将其断开(即客户端出现了故障), 防止占用过多的连接资源</p><p>客户端打开服务器的连接传送数据后,就保持沉默了,此时有可能客户端出了故障.</p><p>解决方法就是使用保活计时器, 每当服务器收到客户端的信息的话,该计时器就复位, 如果两个小时之内还没有收到客户信息,就发送探测报文段,如果发送了10个探测报文段还没有响应的话, 就认为客户端出了故障,终止该连接</p>]]></content>
      
      
      <categories>
          
          <category> -计算机网络 -面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习学习笔记1</title>
      <link href="/2022/08/31/qiang-hua-xue-xi-xue-xi-bi-ji-1/"/>
      <url>/2022/08/31/qiang-hua-xue-xi-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p><strong>强化学习（reinforcement learning)是在与环境的互动中为了达成一个目标而进行的学习</strong><br>强化学习基本元素 <strong>Agent</strong>，<strong>Environment</strong>,<strong>goal</strong><br>强化学习主要元素 <strong>state</strong>,<strong>action</strong>,<strong>reward</strong><br>强化学习核心元素 <strong>policy</strong>,<strong>value</strong><br>强化学习学习的是一个好的价值函数，而一个好的价值函数决定了一个好的策略 </p><p><strong>试错</strong>与<strong>延时奖励</strong>是强化学习中主要特点。</p><p>价值是将来能够获得的所有奖励之和的期望值。</p><p>由于随机性，不能一直做贪婪选择。可以再大多数情况下做出贪婪的选择，再一定几率下做出随机的选择。 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路4-HQL的应用1-建表与show语句</title>
      <link href="/2022/08/22/hive-xue-xi-zhi-lu-4-hql-de-ying-yong-1-jian-biao-yu-show-yu-ju/"/>
      <url>/2022/08/22/hive-xue-xi-zhi-lu-4-hql-de-ying-yong-1-jian-biao-yu-show-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>SQL中DDL(Data Defeinition Language)语言，主要是Create，ALter，DROP。DDL并不涉及表内部操作。</p><h2 id="Hive中的数据库"><a href="#Hive中的数据库" class="headerlink" title="Hive中的数据库"></a>Hive中的数据库</h2><p>在默认情况下，Hive的默认数据库default ,位于HDFS的/user/hive/warehouse目录下<br>用户自己创建的数据库位于/user/hive/warehouse/databse_name.db下</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>create databse用于创建新的数据库<br>COMMENT: 数据库的注释说明语句<br>LOCATION: 指定数据库再HDFS存储位置，默认为/user/hive/warehouse/dbname.db<br>With DBPROPERTIES: 用于指定一些数据库的属性配置</p><pre class=" language-SQL"><code class="language-SQL">CREATE (DATABASE|SCHEMA)[IF NOT EXISTS]database_name[COMMENT database_comment][LOCATION hdfs_path][WITH DBPROPERTIES(property_name=property_value,...)];</code></pre><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>use database 进行切换</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>要求数据库下没有标，为空时才可以删除</p><pre class=" language-SQL"><code class="language-SQL">DROP (DATABSE|SCHEMA)[IF EXSITS]database_name;</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>同理SQL</p><p>[可选内容]</p><pre class=" language-SQL"><code class="language-SQL">CREATE TABLE[IF NOT EXSITS][db_name.]table_name(col_name datatype [COMMENT col_comment],...)[COMMENT table_comment][ROW FORMAT DELIMITED...];</code></pre><p>最低限度</p><pre class=" language-SQL"><code class="language-SQL">CREATE TABLE table_name (col_name datatype,...);</code></pre><p>例</p><pre class=" language-SQL"><code class="language-SQL">create table test.t_archar(    id int comment "ID编号",    name string,    hp_max int,    mp_max int,    attack_max int,    defense_max int,    attack_range string,    role_main string,    role_assist string)row format delimitedfields terminated by "\t";</code></pre><h3 id="show语法"><a href="#show语法" class="headerlink" title="show语法"></a>show语法</h3><p>用于查看schemas，tables和databases</p><p>show tables;<br>show databases;<br>show schemas;<br>show tables in database1; // 此处表示展示database1中的表<br>show tables in schema1; // 此处表示展示schema1中的表</p><p>查看元数据类型<br>desc formatted table1;</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路3-Hive客户端的使用</title>
      <link href="/2022/08/21/hive-xue-xi-zhi-lu-3-hive-ke-hu-duan-de-shi-yong/"/>
      <url>/2022/08/21/hive-xue-xi-zhi-lu-3-hive-ke-hu-duan-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>推荐使用第二代客户端$HIVE_Home/bin/beeline，是一个JDBC客户端<br>官方强烈推荐的Hive命令行工具，和第一代客户端相比，性能安全性提高</p><p><img src="/img/posts/DataRepos/hive%E5%AE%A2%E6%88%B7%E7%AB%AF1&amp;2.jpg" alt="Hive客户端与服务的关系"><br>图源：<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=62&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">https://www.bilibili.com/video/BV1CU4y1N7Sh?p=62&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad</a></p><h2 id="HiveServer2服务"><a href="#HiveServer2服务" class="headerlink" title="HiveServer2服务"></a>HiveServer2服务</h2><p>在远程模式下，启动HiveServer2必须先启动mtastore服务<br>Beeline客户端只能通过HiveServer2服务访问Hive问bin/hive是通过一代服务(metastore)访问的</p><pre class=" language-shell"><code class="language-shell">nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service metastore &nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service hiveserver2 &</code></pre><h3 id="其他机器连接一代客户端-metastore"><a href="#其他机器连接一代客户端-metastore" class="headerlink" title="其他机器连接一代客户端(metastore)"></a>其他机器连接一代客户端(metastore)</h3><p>将客户端拷贝到其他机器上，此处以node3为例</p><pre class=" language-shell"><code class="language-shell">scp -r /export/server/apache-hive-3.1.2-bin root@node3:/export/server/</code></pre><p>再在node3的finalshell中输入</p><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive</code></pre><p>但此时连接的是metastore， 是第一代客户端<br>进入hive&gt;<br>可以用show dtabases; show tables;分别查看数据库和表</p><p>ctrl+c退出hive</p><h3 id="其他机器连接二代客户端-HiveServer2"><a href="#其他机器连接二代客户端-HiveServer2" class="headerlink" title="其他机器连接二代客户端(HiveServer2)"></a>其他机器连接二代客户端(HiveServer2)</h3><p>将beeline客户端连接到hive服务器</p><p>在node3的finalshell中输入</p><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/beeline</code></pre><ul><li><p>进入beeline</p></li><li><p>输入 beeline&gt; ! connect jdbc:hive2://node1:10000<br>  连接到hive服务<br>  输入用户名：root<br>  密码直接回车</p></li><li><p>连接成功<br>  可以直接输入 show databases;<br>          show tables;<br>  进行基本查询</p></li></ul><h2 id="Hive可视化客户端"><a href="#Hive可视化客户端" class="headerlink" title="Hive可视化客户端"></a>Hive可视化客户端</h2><p><strong>DataGrip</strong>,Dbeaver, Squirrel SQL client等</p><h3 id="DataGrip的使用"><a href="#DataGrip的使用" class="headerlink" title="DataGrip的使用"></a>DataGrip的使用</h3><ul><li><p>创建项目</p></li><li><p>attach directory to project<br>  这样之后写的sql文件都存在这个目录下</p></li><li><p>关联数据库<br>  选择右边栏database-&gt; 点击+号 -&gt; data source -&gt; Apache Hive</p><p>  点开后，左边选择栏再选择Hive，配置Hive启动jar，配置好后，点击上方localhost，更改host为node1，user名为root，之后测试connection，，显示ok后，点击apply</p></li></ul><h3 id="测试是否连接成功"><a href="#测试是否连接成功" class="headerlink" title="测试是否连接成功"></a>测试是否连接成功</h3><ul><li><p>在node1机器的finalshell中输入jps<br>runjar在运行</p></li><li><p>在datagrip中右侧的hive连接，此处是node1_hive，点击后按住（Fn+f4)或直接(f4)，进入命令行输入模式，输入show databases;选中后点击左上方绿色按钮进行运行。</p></li></ul><p>成功后和说明环境配置成功。</p><h3 id="正式写sql文件"><a href="#正式写sql文件" class="headerlink" title="正式写sql文件"></a>正式写sql文件</h3><p>将结构化语句映射到表中</p><ul><li><p>新建文件“1.create_table.sql”</p></li><li><p>写建表语句</p></li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> test<span class="token punctuation">.</span>t_archar<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name string<span class="token punctuation">,</span>    hp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    mp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_max <span class="token keyword">int</span><span class="token punctuation">,</span>    defense_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_range string<span class="token punctuation">,</span>    role_main string<span class="token punctuation">,</span>    role_assist string<span class="token punctuation">)</span></code></pre><ul><li>指定字段之间的分隔符</li></ul><p>若不用分隔符，只有create table，会采用默认分隔符’\001’<br>\001是打不出来的，在vim编辑器的输入模式下是^A<br>用空格(\t)表示分隔符</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">row</span> format delimited<span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">"\t"</span></code></pre><p>完整语句</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> test<span class="token punctuation">.</span>t_archar<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name string<span class="token punctuation">,</span>    hp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    mp_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_max <span class="token keyword">int</span><span class="token punctuation">,</span>    defense_max <span class="token keyword">int</span><span class="token punctuation">,</span>    attack_range string<span class="token punctuation">,</span>    role_main string<span class="token punctuation">,</span>    role_assist string<span class="token punctuation">)</span><span class="token keyword">row</span> format delimited<span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">"\t"</span><span class="token punctuation">;</span></code></pre><ul><li>切换到对应的schema</li></ul><p><img src="/img/posts/DataRepos/Datagrip_switchSchema.jpg" alt="切换"></p><h3 id="上传原数据"><a href="#上传原数据" class="headerlink" title="上传原数据"></a>上传原数据</h3><ol><li>暴力上传</li></ol><p>进入node1:9870， browse file-&gt; user-&gt;hive -&gt;warehouse -&gt;test.db -&gt;upload</p><p>之后进入datagrip用select 语句进行查看</p><ol start="2"><li>通过将本地文件再finalshell中</li></ol><pre class=" language-shell"><code class="language-shell">hadoop fs -put 1.txt /user/hive/warehouse/test.db/t_1/</code></pre><p>此处是将1.txt的淑君放到test数据库下的t_1表中</p><p>然后再beeline/datagrip中用select语句可以查看</p><ol start="3"><li>用load加载（推荐）<br>load命令是一个纯复制纯移动的树，hive不会对数据做任何形式的改变<br>语句格式如下</li></ol><pre class=" language-SQL"><code class="language-SQL">LOAD DATA[LOCAL] INOATH 'filepath' [OVERWRITE] INTO TABLE tablename;</code></pre><ul><li>Local的本地–如果是对Hiveserver2服务器所在的机器使用此命令，local本地文件系统指的是Hiveserver2服务所在机器的本地linux文件系统，而非Hive客户端所在的本地文件系统。<br>也就是node1上的本地文件系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路2--安装部署</title>
      <link href="/2022/08/19/hive-xue-xi-zhi-lu-2-an-zhuang-bu-shu/"/>
      <url>/2022/08/19/hive-xue-xi-zhi-lu-2-an-zhuang-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=60&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">https://www.bilibili.com/video/BV1CU4y1N7Sh?p=60&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad</a> </p><p>在Linux环境下，保证Hadoop集群健康可用<br>在启动Hive之前必须先启动Hadoop集群，<strong>需等待HDFS安全模式关闭之后再运行Hive</strong></p><pre class=" language-shell"><code class="language-shell">start-dfs.shstart-yarn.sh</code></pre><p>Hive不是分布式安装运行的软件，其分布式特效主要借助于Hadoop完成，包括分布式存储，分布式计算</p><h2 id="Hadoop与Hive"><a href="#Hadoop与Hive" class="headerlink" title="Hadoop与Hive"></a>Hadoop与Hive</h2><p>需要在Hadoop中添加相关配置属性，以满足Hive在Hadoop上运行<br>修改Hadoop中core-site.xml,并且Hadoop集群同步配置文件重启生效</p><!--整合Hive代理设置 --><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.proxyuser.root.hosts<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.proxyuser.root.groups<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><ol><li>卸载Centos7自带的mariadb</li></ol><pre class=" language-shell"><code class="language-shell">rpm -qa|grep mariadb# 结果mariadb-libs-5.5.64-1.el7.x86_64rpm -e mariadb-libs-5.5.64-1.el7.x86_64 --nodeps# 进行删除rpm -qa|grep mariadb                            # 再次查询，无结果</code></pre><ol start="2"><li>安装mysql</li></ol><pre class=" language-shell"><code class="language-shell"># 创建目录mkdir /export/software/mysql# 选择finalShell，找到/export。software/mysql 拖拽文件上传mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar#到上述文件夹下  解压tar xvf mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar#执行安装依赖yum -y install libaio# 进行mysql的安装rpm -ivh mysql-community-common-5.7.29-1.el7.x86_64.rpm    mysql-community-libs-5.7.29-1.el7.x86_64.rpm    mysql-community-client-5.7.29-1.el7.x86_64.rpm      mysql-community-server-5.7.29-1.el7.x86_64.rpm warning: mysql-community-common-5.7.29-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:mysql-community-common-5.7.29-1.e################################# [ 25%]   2:mysql-community-libs-5.7.29-1.el7################################# [ 50%]   3:mysql-community-client-5.7.29-1.e################################# [ 75%]   4:mysql-community-server-5.7.29-1.e################                  ( 49%)</code></pre><ol start="3"><li>mysql初始化设置</li></ol><pre class=" language-shell"><code class="language-shell">#初始化mysqld --initialize#更改所属组chown mysql:mysql /var/lib/mysql -R#启动mysqlsystemctl start mysqld.service#查看生成的临时root密码cat  /var/log/mysqld.log[Note] A temporary password is generated for root@localhost: o+TU+KDOm004</code></pre><ol start="4"><li>修改root密码 授权远程访问 设置开机自启动</li></ol><pre class=" language-shell"><code class="language-shell"># 登录mysqlmysql -u root -p# Enter password:     #这里输入在日志中生成的临时密码# Welcome to the MySQL monitor.  Commands end with ; or \g.# Your MySQL connection id is 3# Server version: 5.7.29Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql> #更新root密码  设置为hadoopmysql> alter user user() identified by "hadoop";Query OK, 0 rows affected (0.00 sec)#授权mysql> use mysql;mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'hadoop' WITH GRANT OPTION;mysql> FLUSH PRIVILEGES; # ctrl+D 结束 退出mysql#mysql的启动和关闭 状态查看 （这几个命令必须记住）systemctl stop mysqldsystemctl status mysqldsystemctl start mysqld#建议设置为开机自启动服务systemctl enable  mysqld    #Created symlink from /etc/systemd/system/multi-user.target.wants/mysqld.service to /usr/lib/systemd/system/mysqld.service.#查看是否已经设置自启动成功systemctl list-unit-files | grep mysqld# mysqld.service enabled </code></pre><h2 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h2><ul><li><p>上传安装包 解压</p><pre class=" language-shell"><code class="language-shell">tar zxvf apache-hive-3.1.2-bin.tar.gz</code></pre></li><li><p>解决Hive与Hadoop之间guava版本差异</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.3.0/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</code></pre></li><li><p>修改配置文件</p><ul><li><p>hive-env.sh</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/confmv hive-env.sh.template hive-env.shvim hive-env.sh## 大G小o 跳转到最后一行export HADOOP_HOME=/export/server/hadoop-3.3.0export HIVE_CONF_DIR=/export/server/apache-hive-3.1.2-bin/confexport HIVE_AUX_JARS_PATH=/export/server/apache-hive-3.1.2-bin/lib# Esc(退出输入模式)+shift+zz 快速保存</code></pre></li></ul></li><li><p>hive-site.xml</p><pre class=" language-shell"><code class="language-shell">vim hive-site.xml</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 存储元数据mysql相关配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionURL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>jdbc:mysql://node1:3306/hive3?createDatabaseIfNotExist=true<span class="token entity" title="&amp;">&amp;amp;</span>useSSL=false<span class="token entity" title="&amp;">&amp;amp;</span>useUnicode=true<span class="token entity" title="&amp;">&amp;amp;</span>characterEncoding=UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionDriverName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>com.mysql.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionUserName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionPassword<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- H2S运行绑定host --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.server2.thrift.bind.host<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>node1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 远程模式部署metastore metastore地址 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.metastore.uris<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>thrift://node1:9083<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 关闭元数据存储授权  --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hive.metastore.event.db.notification.api.auth<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre></li><li><p>上传mysql jdbc驱动到hive安装包lib下</p><pre class=" language-shell"><code class="language-shell">mysql-connector-java-5.1.32.jar</code></pre></li><li><p>初始化元数据</p></li></ul><p>检验安装是否正确</p><pre class=" language-shell"><code class="language-shell">cd /export/server/apache-hive-3.1.2-bin/bin/schematool -initSchema -dbType mysql -verbos#初始化成功会在mysql中创建74张表</code></pre><ul><li><p>在hdfs创建hive存储目录（如存在则不用操作）</p><pre class=" language-shell"><code class="language-shell">hadoop fs -mkdir /tmphadoop fs -mkdir -p /user/hive/warehousehadoop fs -chmod g+w /tmphadoop fs -chmod g+w /user/hive/warehouse</code></pre><h2 id="metastore启动"><a href="#metastore启动" class="headerlink" title="metastore启动"></a>metastore启动</h2><h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><p>进程会一直占据终端，ctrl+c结束进程</p><ul><li>启动前台</li></ul><pre class=" language-shell"><code class="language-shell">/export/server/appache-hive-3.1.2-bin/bin/hive --service metastore</code></pre><ul><li>前台启动开启debug日志</li></ul><pre class=" language-shell"><code class="language-shell">/export/server/apache-hive-3.1.2-bin/bin/hive --service metastore --hiveconf hive.root.logger=DEBUG,console </code></pre><h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><ul><li>把程序当成一个进程</li></ul><pre class=" language-shell"><code class="language-shell">nohup /export/server/apache-hive-3.1.2-bin/bin/hive --service metastore &</code></pre><p>回车后再按一次回车，就成功启动在后台了</p><p>之后通过jps 查看进程</p><p>使用kill -9杀死进程</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习之路1--基本概念</title>
      <link href="/2022/08/19/hive-xue-xi-zhi-lu-1-ji-ben-gai-nian/"/>
      <url>/2022/08/19/hive-xue-xi-zhi-lu-1-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive的优点"><a href="#Hive的优点" class="headerlink" title="Hive的优点"></a>Hive的优点</h2><p>1.接口操作采用类SQL语法，提供快速开发的能力，简单且容易上手<br>2.擅长存储分析海量数据，与Hadoop相似<br>3.避免直接写MapReduce，减少开发人员学习成本</p><p>Hive利用HDFS存储数据，利用MapResuce查询分析数据</p><h2 id="Hive功能的实现"><a href="#Hive功能的实现" class="headerlink" title="Hive功能的实现"></a>Hive功能的实现</h2><ol><li><p>Hive能将结构化文件映射成一张表，Hive并不承担存储数据功能，存储数据是由HDFS实现(将元数据信息描述清楚，转化成一个表)</p></li><li><p>用户写完sql后，Hive对sql进行校验，并且更具元数据信息解读sql背后的含义，最后将执行计划转换成MApReduce程序来具体执行</p></li></ol><p>有点类JDBC？<br>Hive是基于Hadoop的数仓工具 <img src="/%5Cimg%5Cposts%5CDataRepos%5CHive1.jpg" alt="Hive工作原理"></p><h2 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h2><p><img src="/%5Cimg%5Cposts%5CDataRepos%5CHive2.jpg" alt="Hive架构"></p><p>用户接口：包括CLI。JDBC/ODBC，WebGUI</p><p>元数据(metadata)存储 mysql/derby Hive中的元数据(描述数据的数据)包括表明，列的分区及属性，表的属性（是否为外部表等），表的数据所在的目录等</p><p>Driver驱动程序：包括语法解析器，计划编译器，优化器，执行器</p><p>执行引擎：MapReduce/Tez/Spark，Hive并不直接处理数据，而是通过执行引擎处理数据</p><p>Hadoop Yarn</p><p>HDFS/HBase</p><h2 id="Hive与元数据"><a href="#Hive与元数据" class="headerlink" title="Hive与元数据"></a>Hive与元数据</h2><p>Hive的安装模式与元数据服务(metastore)有关</p><p>metasore服务器配置有三种模式内嵌模式、本地模式、<strong>远程模式</strong></p><p><img src="/%5Cimg%5Cposts%5CDataRepos%5CHive3.jpg" alt="metastore"></p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓基本概念</title>
      <link href="/2022/08/19/shu-cang-ji-ben-gai-nian/"/>
      <url>/2022/08/19/shu-cang-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>数据仓库是构建面向分析的集成化数据环境，是一个用于存储、<strong>分析</strong>、报告的环境</p><h2 id="联机事务处理系统-OLTP"><a href="#联机事务处理系统-OLTP" class="headerlink" title="联机事务处理系统(OLTP)"></a>联机事务处理系统(OLTP)</h2><p>特征：前台接收的用户数据可以立即传送到后台进行处理，并在很短的时间内给出处理结果<br>关系型数据库是典型的OLTP应用，如MySQL，Oracle</p><p>数据库可以开展分析，但没必要。数据库一般读取压力明显大于写入的压力，如果直接再OLTP进行各种分析，会导致数据库读取压力倍增。</p><p><img src="/img/posts/DataRepos/01.jpg" alt="数仓例子"></p><h2 id="数仓主要特征"><a href="#数仓主要特征" class="headerlink" title="数仓主要特征"></a>数仓主要特征</h2><h3 id="Subject-Oriented"><a href="#Subject-Oriented" class="headerlink" title="Subject-Oriented"></a>Subject-Oriented</h3><p>主题是一个抽象概念，是较高层次上的<strong>数据综合</strong>、归类、并进行分析利用的抽象。再抽象层次上对数据进行完整、一致和准确的描述</p><h3 id="Non-Volatile"><a href="#Non-Volatile" class="headerlink" title="Non-Volatile"></a>Non-Volatile</h3><p>非易变性。数仓是分析数据的平台，而不是创造数据的平台。<br>书擦干的数据反应的是一段长时间内的历史数据的内容<br>数仓一般有<strong>大量的查询</strong>操作，但修改和删除很少</p><h3 id="Integrated"><a href="#Integrated" class="headerlink" title="Integrated"></a>Integrated</h3><p>主题相关的数据通常会分布在多个操作系统中，彼此分散、独立、异构。需要集成到数仓主题之下。</p><p>要统一源数据中的矛盾：包括字段的同名异义、单位不同、格式不同等</p><p>ETL：抽取、转换、加载</p><h3 id="Time-Variant"><a href="#Time-Variant" class="headerlink" title="Time-Variant"></a>Time-Variant</h3><p>时变性。数仓的数据需要随着时间更新，以适应决策的需要。</p><h2 id="数仓主流语言-SQL"><a href="#数仓主流语言-SQL" class="headerlink" title="数仓主流语言-SQL"></a>数仓主流语言-SQL</h2><p>结构化数据（行与列）–二维表结构来逻辑表达和实现的数据，严格遵循数据格式和长度规范</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop中Yarn的概述</title>
      <link href="/2022/08/19/hadoop-zhong-yarn-de-gai-shu/"/>
      <url>/2022/08/19/hadoop-zhong-yarn-de-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>学习参考<a href="https://www.bilibili.com/video/BV1CU4y1N7Sh?p=49&amp;spm_id_from=pageDriver&amp;vd_source=f618be285e44e05f2b481fa28b9fe6ad">Hadoop入门</a></p><h2 id="Yarn的简介"><a href="#Yarn的简介" class="headerlink" title="Yarn的简介"></a>Yarn的简介</h2><p>Hdfsd大数据存储系统中的资源管理器主要为MapReduce与Yarn，是一个通用的<strong>资源管理系统</strong>和<strong>调度</strong>平台，可为上层应用提供统一的资源管理和调度，为集群再利用率，资源统一管理和数据共享等方面带来了巨大好处</p><p><strong>资源管理系统</strong>: 管理集群的硬件资源，包括内存，CPU等<br><strong>调度平台</strong>： 多个程序同时申请资源，如何进行合理的分配与调度<br>Yarn作为一个通用平台，说明它不仅仅支持MR（MapReuce）程序，理论上支持各种计算程序（Spark，HBase，Storm…）</p><p>可以把Yarn理解为一个分布式的操作系统平台，HDFS是应用最广泛的大数存储系统，Yarn功不可没</p><h2 id="Yarn中的组件"><a href="#Yarn中的组件" class="headerlink" title="Yarn中的组件"></a>Yarn中的组件</h2><p>主要是三大组件</p><p>集群物理层面：   ResourceManager<br>                NodeManager<br>APP层面：       ApplicationMaster</p><h3 id="ResourceManager-RM"><a href="#ResourceManager-RM" class="headerlink" title="ResourceManager(RM)"></a>ResourceManager(RM)</h3><p>Yarn集群中的著角色，决定系统中所有应用程序之间的资源分配器的<strong>最终</strong>权限，接收用户的作业提交，并通过NM分配，管理机器上的计算资源</p><h3 id="NodeManager-NM"><a href="#NodeManager-NM" class="headerlink" title="NodeManager(NM)"></a>NodeManager(NM)</h3><p>Yarn中的从角色，一个机器上一个，负责管理本机器上的计算资源使用情况<br>根据RM命令，启动Container容器，监视容器的资源使用情况，并且向RM著角色汇报资源使用情况</p><h3 id="ApplicationMaster-AM"><a href="#ApplicationMaster-AM" class="headerlink" title="ApplicationMaster(AM)"></a>ApplicationMaster(AM)</h3><p>用户提交的每个应用程序均包含一个AM<br>应用程序中的“老大”，负责程序内部个资源的申请，监督程序的执行情况<br>AM程序是应用程序内部启动的第一个程序</p><h2 id="Yarn程序提交流程"><a href="#Yarn程序提交流程" class="headerlink" title="Yarn程序提交流程"></a>Yarn程序提交流程</h2><p>核心交互流程主要有四步：<br>MR作业提交  Client -&gt; RM<br>资源的申请  MRAppMaster -&gt; RM<br>MR作业状态汇报 Container(Map | Reduce Task) -&gt; Container (MRAppMaster)<br>节点的状态汇报(Yarn集群内布)  NM -&gt;RM </p><h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>当用户向YARN中提交一个应用程序后，YARN将分为了两个阶段运行该应用程序<br>第一个阶段：客户端申请资源启动运行被刺程序的AppMaster<br>第二个阶段有AppMaster更具本次程序内部具体具体情况为她申请资源，并健康它的整个运行过程，知道运行完成</p><p><img src="/img/posts/Yarn/Yarn%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.jpg" alt="Yarn程序提交流程"></p><p>第一步:用户通过客户端向Yarn中的ResourceManager提交应用程序（如Hadoop，jar提交MR程序）</p><p>第二步：RM为该应用程序分配第一个container，并于对应的NM同学，要求它再这个container中启动该应用的AM</p><p>第三步：AM启动成功后，向RM注册并保持同学，这样用户可以直接通过RM查看应用程序的运行状态</p><p>第四步：AM为本次程序内部的各个Task向RM申请资源</p><p>第五步：一旦<strong>AM</strong>申请到资源，便于对应的NM通信，要求他启动任务</p><p>第六版：NM为任务设置好运行环境之后，将任务启动命令写入到一个脚本之中，并通过运行该脚本启动任务</p><p>第七步：各个人物通过某个<a href="https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE/5019569?fr=aladdin">RPC协议</a>向AM汇报自己的状态和进度，以让AM随时掌握各个人物的运行状态，可以再任务失败时重新启动任务。<br>在应用程序运行过沉重，用户可随时通过RPC向AM查询应用程序当前运行状态</p><p>第八步：应用程序运行完成后，AM向RM注销并关闭自己</p><h2 id="Yarn的资源调度器Scheduler"><a href="#Yarn的资源调度器Scheduler" class="headerlink" title="Yarn的资源调度器Scheduler"></a>Yarn的资源调度器Scheduler</h2><p>在Yarn中，负责给应用分配资源的是schduler，是RM的内部核心组件之一。Schduler完全用于调度作业，无法跟踪应用程序的状态。Yarn提供了多种调度器和可配置的策略供选择，可在yarn-sit.xml中的yarn.resourcemanager.schduler.class进行配置</p><h3 id="FIFO-Schduler"><a href="#FIFO-Schduler" class="headerlink" title="FIFO Schduler"></a>FIFO Schduler</h3><p>先入先出，拥有一个控制全局的队列Queue<br>不适合共享集群</p><h3 id="Capacity-Scheduler"><a href="#Capacity-Scheduler" class="headerlink" title="Capacity Scheduler"></a>Capacity Scheduler</h3><p>Apache版本一般默认Capacity Scheduler<br><strong>允许多个组织共享集群资源</strong>，每个组织都可以获得一部分集群计算能力。通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源，整个集群可以通过设置多个队列给多个组织提供服务。</p><p>Capacity 可以理解为一个个的资源队列，这个资源队列是用户自行分配。<br>再在队列内部进行垂直划分，使得一个组织内部分多个成员共享这个队列资源。<br><strong>在一个队列内部，资源调度是FIFO的</strong></p><p><img src="/img/posts/Yarn/Scheduler_task_div.jpg" alt="文件划分"></p><h3 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h3><p>提供了yarn应用程序中共享大型资源的方式</p><hr><p>例如：<br>用户A、B都有自己的队列 -&gt; A启动一个作业，而B还没有，此时A分配了集群中所有可用的资源 -&gt; B在A仍在运行时启动了一个作业，一段时间后，A、B各自作业都使用了一半的资源 -&gt; 若B此时再开启第二个作业，它将于B的另一个作业共享资源。A的一个作业仍占有1/2的资源，而B的两个作业各自占有1/4的资源</p><hr><p>Fair Scheduler支持资源抢占、基于用户的映射</p>]]></content>
      
      
      <categories>
          
          <category> 数仓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode部分汇总</title>
      <link href="/2022/08/02/leetcode-bu-fen-hui-zong/"/>
      <url>/2022/08/02/leetcode-bu-fen-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><hr><h2 id="96-不同的二叉搜索树-DP"><a href="#96-不同的二叉搜索树-DP" class="headerlink" title="96. 不同的二叉搜索树:DP"></a>96. 不同的二叉搜索树:DP</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP、卡特兰公式</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                 dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="95-不同的二叉搜索树2-DFS"><a href="#95-不同的二叉搜索树2-DFS" class="headerlink" title="95.不同的二叉搜索树2:DFS"></a>95.不同的二叉搜索树2:DFS</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br>（不只返回数字）</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>DFS</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h2 id="516-最长回文子序列-DP"><a href="#516-最长回文子序列-DP" class="headerlink" title="516. 最长回文子序列:DP"></a>516. 最长回文子序列:DP</h2><p>给定一个字符串s，找到其中最长的回文子序列（的长度）。<br>注意：子序列可以不连续的，可以跳过某些单词，子串是必须连续的</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>DP</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"></code></pre><h2 id="714-买卖股票的最佳时机含手续费-DP"><a href="#714-买卖股票的最佳时机含手续费-DP" class="headerlink" title="714. 买卖股票的最佳时机含手续费:DP"></a>714. 买卖股票的最佳时机含手续费:DP</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">,</span> <span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hold <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cash <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cash<span class="token punctuation">,</span> hold <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee<span class="token punctuation">)</span><span class="token punctuation">;</span>            hold <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>hold<span class="token punctuation">,</span> cash <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cash<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="139-单词拆分-DP-x2F-BST"><a href="#139-单词拆分-DP-x2F-BST" class="headerlink" title="139. 单词拆分:DP/BST"></a>139. 单词拆分:DP/BST</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><pre class=" language-java"><code class="language-java">Javapublic <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="516-最长回文子序列-DP-1"><a href="#516-最长回文子序列-DP-1" class="headerlink" title="516. 最长回文子序列:DP"></a>516. 最长回文子序列:DP</h2><h3 id="DP-步骤版"><a href="#DP-步骤版" class="headerlink" title="DP 步骤版"></a>DP 步骤版</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq2nd</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="300-最长上升子序列-DP、二分法插入"><a href="#300-最长上升子序列-DP、二分法插入" class="headerlink" title="300.最长上升子序列:DP、二分法插入"></a>300.最长上升子序列:DP、二分法插入</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这个数组实际上的长度，就是最后所求</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end<span class="token operator">++</span><span class="token punctuation">;</span>                tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用二分搜索法来做这件事情，二分法实现nlogn的时间复杂度</span>                <span class="token comment" spellcheck="true">// 修改目前tail中比target小的最大数为target</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>                <span class="token keyword">int</span> target <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">+</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//int mid = left + (right - left) / 2;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 只要比目标值要小，要找的位置就至少是当前位置 + 1</span>                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">assert</span> tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 大于目标值，不能盲目向前走，因为向前走很可能，值会变得比目标值小</span>                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                tail<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="494-目标和-DP-背包问题"><a href="#494-目标和-DP-背包问题" class="headerlink" title="494. 目标和:DP+背包问题"></a>494. 目标和:DP+背包问题</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/**     * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合     * 所以题目可以转化为     * sum(P) - sum(N) = target      * => sum(nums) + sum(P) - sum(N) = target + sum(nums)     * => 2 * sum(P) = target + sum(nums)      * => sum(P) = (target + sum(nums)) / 2     * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> S <span class="token operator">||</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>w <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">;</span> j <span class="token operator">>=</span> num<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="638-大礼包-DP"><a href="#638-大礼包-DP" class="headerlink" title="638. 大礼包:DP"></a>638. 大礼包:DP</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shoppingOffers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> price<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> special<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> needs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//统计不使用大礼包的总价</span>        <span class="token keyword">int</span> noSpecial <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>needs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            noSpecial <span class="token operator">+=</span> price<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> noSpecial<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历每一个大礼包</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sp <span class="token operator">:</span> special<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当前大礼包超过购买数量，跳过</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span>needs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用当前大礼包后，还有多少剩下的</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> newNeeds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Integer i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    newNeeds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//剩下的购买数量递归调用本方法，获取最低价格</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">shoppingOffers</span><span class="token punctuation">(</span>price<span class="token punctuation">,</span>special<span class="token punctuation">,</span>newNeeds<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//使用当前大礼包和不使用相比，选价格最低的</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>left <span class="token operator">+</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> special<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> needs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>needs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>special<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> needs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="651-4键键盘-DP-贪心算法"><a href="#651-4键键盘-DP-贪心算法" class="headerlink" title="651. 4键键盘:DP+贪心算法"></a>651. 4键键盘:DP+贪心算法</h2><p>复制粘贴还是直接输入，得到最长字符串</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxA</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token operator">></span>b <span class="token operator">?</span> a<span class="token operator">:</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="983-最低票价-DP"><a href="#983-最低票价-DP" class="headerlink" title="983. 最低票价:DP"></a>983. 最低票价:DP</h2><p>买火车票：1天、7天、30天</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> days<span class="token punctuation">,</span> costs<span class="token punctuation">;</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> durations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mincostTickets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> days<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>days <span class="token operator">=</span> days<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>costs <span class="token operator">=</span> costs<span class="token punctuation">;</span>        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>days<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> days<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> days<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> days<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> days<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> durations<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">dp</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目-DFS"><a href="#323-无向图中连通分量的数目-DFS" class="headerlink" title="323. 无向图中连通分量的数目:DFS"></a>323. 无向图中连通分量的数目:DFS</h2><pre class=" language-c++"><code class="language-c++">class Solution {public:    int countComponents(int n, vector<vector<int>>& edges) {        vector<int>a(n, 0);        vector<vector<int>>arr(n, a);        for (auto it : edges) {            arr[it[0]][it[1]] = 1;            arr[it[1]][it[0]] = 1;        }        int res = 0;        vector<int>mark(n, 0);        for (int i = 0; i < n; i++) {            if (mark[i] == 0) {                DFS(arr, mark, i);                res++;            }        }        return res;            }private:    void DFS(vector<vector<int>>&arr, vector<int>& mark,int b) {            mark[b] = 1;            for (int i = 0; i < arr.size(); i++) {                if (arr[i][b] == 1&&mark[i] == 0) {                    DFS(arr, mark,i);                }            }            mark[b] = 2;    }};</code></pre><h2 id="529-扫雷游戏-BFS-x2F-DFS"><a href="#529-扫雷游戏-BFS-x2F-DFS" class="headerlink" title="529. 扫雷游戏:BFS/DFS"></a>529. 扫雷游戏:BFS/DFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateBoard</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> click<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token function">visit</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>click<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>click<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>      <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> board<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span>                   count<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">else</span> <span class="token punctuation">{</span>           board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span><span class="token punctuation">)</span>                       <span class="token function">visit</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>       <span class="token punctuation">}</span>              <span class="token keyword">return</span> board<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="127-单词接龙：BFS"><a href="#127-单词接龙：BFS" class="headerlink" title="127. 单词接龙：BFS"></a>127. 单词接龙：BFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javafx<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Pair<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Since all words are of same length.</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> beginWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dictionary to hold combination of words that can be formed,</span>    <span class="token comment" spellcheck="true">// from any given word. By changing one letter at a time.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span> allComboDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        word <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Key is the generic word</span>            <span class="token comment" spellcheck="true">// Value is a list of words which have the same intermediate generic word.</span>            String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> transformations <span class="token operator">=</span>                allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            transformations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            allComboDict<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> transformations<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Queue for BFS</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Visited to make sure we don't repeat processing same word.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String word <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> level <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Intermediate words for current word</span>        String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Next states are all the words which share the same intermediate state.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String adjacentWord <span class="token operator">:</span> allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// If at any point if we find what we are looking for</span>          <span class="token comment" spellcheck="true">// i.e. the end word - we can return with the answer.</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>adjacentWord<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// Otherwise, add it to the BFS Queue. Also mark it visited</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双向广度优先搜索</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javafx<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Pair<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> L<span class="token punctuation">;</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span> allComboDict<span class="token punctuation">;</span>  <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dictionary to hold combination of words that can be formed,</span>    <span class="token comment" spellcheck="true">// from any given word. By changing one letter at a time.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>      Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q<span class="token punctuation">,</span>      HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visited<span class="token punctuation">,</span>      HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> othersVisited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String word <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Intermediate words for current word</span>      String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Next states are all the words which share the same intermediate state.</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>String adjacentWord <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If at any point if we find what we are looking for</span>        <span class="token comment" spellcheck="true">// i.e. the end word - we can return with the answer.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>othersVisited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> level <span class="token operator">+</span> othersVisited<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Save the level as the value of the dictionary, to save number of hops.</span>          visited<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>adjacentWord<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wordList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Since all words are of same length.</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>L <span class="token operator">=</span> beginWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        word <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Key is the generic word</span>            <span class="token comment" spellcheck="true">// Value is a list of words which have the same intermediate generic word.</span>            String newWord <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'*'</span> <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> transformations <span class="token operator">=</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            transformations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>allComboDict<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newWord<span class="token punctuation">,</span> transformations<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Queues for birdirectional BFS</span>    <span class="token comment" spellcheck="true">// BFS starting from beginWord</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q_begin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// BFS starting from endWord</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> Q_end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q_begin<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q_end<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>endWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Visited to make sure we don't repeat processing same word.</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visitedBegin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> visitedEnd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedBegin<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedEnd<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>endWord<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q_begin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Q_end<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// One hop from begin word</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>Q_begin<span class="token punctuation">,</span> visitedBegin<span class="token punctuation">,</span> visitedEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// One hop from end word</span>      ans <span class="token operator">=</span> <span class="token function">visitWordNode</span><span class="token punctuation">(</span>Q_end<span class="token punctuation">,</span> visitedEnd<span class="token punctuation">,</span> visitedBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="139-单词拆分：BFS-x2F-DP"><a href="#139-单词拆分：BFS-x2F-DP" class="headerlink" title="139. 单词拆分：BFS/DP"></a>139. 单词拆分：BFS/DP</h2><p>BFS</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>DP</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDictSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDictSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="279-完全平方数-BST"><a href="#279-完全平方数-BST" class="headerlink" title="279. 完全平方数:BST"></a>279. 完全平方数:BST</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token keyword">int</span> step<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">=</span> step<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将问题转化成图论</span>    <span class="token comment" spellcheck="true">// 该算法在往队列里面添加节点的时候会 add 很多重复的节点，导致超时，</span>    <span class="token comment" spellcheck="true">// 优化办法是，加入 visited 数组，检查要 add 的数据是否已经出现过了，防止数据重复出现，从而影响图的遍历</span>    <span class="token comment" spellcheck="true">// 同时优化：num - i * i 表达式，只让他计算一次</span>    <span class="token comment" spellcheck="true">// 同时在循环体里面判断退出或返回的条件，而不是在循环体外</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 其实一个真正的图的 BSF 是一定会加上 visited 数组来过滤元素的</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">int</span> step <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>step<span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> a <span class="token operator">=</span> num <span class="token operator">-</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 若 a 已经计算到 0 了，就不必再往下执行了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    visited<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="515-在每个树行中找最大值-BFS"><a href="#515-在每个树行中找最大值-BFS" class="headerlink" title="515. 在每个树行中找最大值:BFS"></a>515. 在每个树行中找最大值:BFS</h2><p>在二叉树的每一行中找到最大的值。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">largestValues</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> rlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> rlist<span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> nodeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> nodeList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> nodeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            rlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rlist<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="994-腐烂的橘子-BFS"><a href="#994-腐烂的橘子-BFS" class="headerlink" title="994. 腐烂的橘子:BFS"></a>994. 腐烂的橘子:BFS</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">orangesRotting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> R <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">,</span> C <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// queue : all starting cells with rotten oranges</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> depth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> C<span class="token punctuation">;</span> <span class="token operator">++</span>c<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> code <span class="token operator">=</span> r <span class="token operator">*</span> C <span class="token operator">+</span> c<span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>                    depth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> code <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> code <span class="token operator">/</span> C<span class="token punctuation">,</span> c <span class="token operator">=</span> code <span class="token operator">%</span> C<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nr <span class="token operator">=</span> r <span class="token operator">+</span> dr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nc <span class="token operator">=</span> c <span class="token operator">+</span> dc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nr <span class="token operator">&amp;&amp;</span> nr <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> nc <span class="token operator">&amp;&amp;</span> nc <span class="token operator">&lt;</span> C <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    grid<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> ncode <span class="token operator">=</span> nr <span class="token operator">*</span> C <span class="token operator">+</span> nc<span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ncode<span class="token punctuation">)</span><span class="token punctuation">;</span>                    depth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ncode<span class="token punctuation">,</span> depth<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans <span class="token operator">=</span> depth<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ncode<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row<span class="token operator">:</span> grid<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span> row<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a>646. 最长数对链</h2><p>按end排序 然后每次选择能放的end最小的一个数对加入当前的数对链</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLongestChain</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pairs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pairs<span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>tmp <span class="token operator">=</span> pairs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> pairs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>                 res<span class="token operator">++</span><span class="token punctuation">;</span>                 tmp <span class="token operator">=</span> pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="547-省份数量：无向图最小连通数：并查集-x2F-DFS"><a href="#547-省份数量：无向图最小连通数：并查集-x2F-DFS" class="headerlink" title="547.省份数量：无向图最小连通数：并查集/DFS"></a>547.省份数量：无向图最小连通数：并查集/DFS</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//无向图最小连通数</span><span class="token comment" spellcheck="true">// //并查集</span><span class="token comment" spellcheck="true">// class Solution {</span><span class="token comment" spellcheck="true">//     public int findCircleNum(int[][] M) {</span><span class="token comment" spellcheck="true">//         int s = M.length;</span><span class="token comment" spellcheck="true">//         UnionFind uf = new UnionFind(s);</span><span class="token comment" spellcheck="true">//         for(int i = 0;i&lt;s-1;i++)</span><span class="token comment" spellcheck="true">//             for(int j = i+1;j&lt;s;j++)</span><span class="token comment" spellcheck="true">//                 if(M[i][j] == 1) </span><span class="token comment" spellcheck="true">//                     uf.union(i,j);</span><span class="token comment" spellcheck="true">//         return uf.getSetCount();</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">// }</span>    <span class="token comment" spellcheck="true">//     public class UnionFind {</span><span class="token comment" spellcheck="true">// private int[] id; // 表示当前下标是父亲是谁，如in[3] = 1, 3的父亲是1。</span><span class="token comment" spellcheck="true">// private int[] size; </span><span class="token comment" spellcheck="true">// private int setCount; //连通个数</span><span class="token comment" spellcheck="true">// private int maxSetSize; //最大的size</span>        <span class="token comment" spellcheck="true">//         //初始化</span><span class="token comment" spellcheck="true">// public UnionFind(int n) {</span><span class="token comment" spellcheck="true">// id = new int[n];</span><span class="token comment" spellcheck="true">// size = new int[n];</span><span class="token comment" spellcheck="true">//             //父节点以及size的初始化</span><span class="token comment" spellcheck="true">// for (int i = 0; i &lt; n; i++) {</span><span class="token comment" spellcheck="true">// id[i] = i; // self-loop</span><span class="token comment" spellcheck="true">// size[i] = 1;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// setCount = n;</span><span class="token comment" spellcheck="true">// maxSetSize = 1;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// // O(logN)</span><span class="token comment" spellcheck="true">// public void union(int i, int j) {</span><span class="token comment" spellcheck="true">// int ri = root(i);</span><span class="token comment" spellcheck="true">// int rj = root(j);</span><span class="token comment" spellcheck="true">// if (ri == rj)</span><span class="token comment" spellcheck="true">// return;</span><span class="token comment" spellcheck="true">//             //将个数小的合并到个数大的集合中</span><span class="token comment" spellcheck="true">// if (size[ri] >= size[rj]) {</span><span class="token comment" spellcheck="true">// id[rj] = id[ri];</span><span class="token comment" spellcheck="true">// size[ri] += size[rj];</span><span class="token comment" spellcheck="true">// maxSetSize = Math.max(maxSetSize, size[ri]);</span><span class="token comment" spellcheck="true">// } else {</span><span class="token comment" spellcheck="true">// id[ri] = id[rj];</span><span class="token comment" spellcheck="true">// size[rj] += size[ri];</span><span class="token comment" spellcheck="true">// maxSetSize = Math.max(maxSetSize, size[rj]);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// setCount--;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// // O(logN)</span><span class="token comment" spellcheck="true">// public boolean find(int i, int j) {</span><span class="token comment" spellcheck="true">// return root(i) == root(j);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// public int getMaxSetSize() {</span><span class="token comment" spellcheck="true">// return maxSetSize;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// public int getSetCount() {</span><span class="token comment" spellcheck="true">// return setCount;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// private int root(int i) { // 不停向上寻找父节点</span><span class="token comment" spellcheck="true">// while (id[i] != i) { // keep checking for the self-loop</span><span class="token comment" spellcheck="true">// id[i] = id[id[i]]; // set grand-parent as parent (path compression)</span><span class="token comment" spellcheck="true">// i = id[i]; // go up to parent</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// return i;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">//DFS</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> N <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>i<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> si<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>si<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目-dfs"><a href="#323-无向图中连通分量的数目-dfs" class="headerlink" title="323. 无向图中连通分量的数目:dfs"></a>323. 无向图中连通分量的数目:dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countComponents</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> mark<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> map<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="934-最短的桥-dfs-x2F-bfs"><a href="#934-最短的桥-dfs-x2F-bfs" class="headerlink" title="934. 最短的桥:dfs/bfs"></a>934. 最短的桥:dfs/bfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//dfs寻找第一个岛屿，bfs寻找最断桥</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shortestBridge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix <span class="token operator">=</span> A<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//让A变成一个全局变量</span>        queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//控制dfs只寻找一个岛屿</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>found<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>found<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    found <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//cur[1]表示当前步数</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span>n<span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">%</span>n<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dir<span class="token operator">:</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> x <span class="token operator">=</span> i <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> y <span class="token operator">=</span> j <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">>=</span> n <span class="token operator">||</span> y <span class="token operator">>=</span> n <span class="token operator">||</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cur<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>x<span class="token operator">*</span>n<span class="token operator">+</span>y<span class="token punctuation">,</span>cur<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dir<span class="token operator">:</span>dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> i<span class="token operator">+</span>dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> j<span class="token operator">+</span>dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>x<span class="token operator">>=</span>n<span class="token operator">||</span> y<span class="token operator">>=</span>n<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>n<span class="token operator">*</span>x<span class="token operator">+</span>y<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="207-课程表-有向图是否有环：拓扑排序-x2F-dfs"><a href="#207-课程表-有向图是否有环：拓扑排序-x2F-dfs" class="headerlink" title="207. 课程表:有向图是否有环：拓扑排序/dfs"></a>207. 课程表:有向图是否有环：拓扑排序/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*拓扑排序    *每一次都输出入度为0的结点，并移除它、修改它指向的结点的入度    *依次得到的结点序列就是拓扑排序的结点序列    *如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。    *拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面    *并且可以完成所有活动。拓扑排序的结果不唯一。    *拓扑排序还可以用于检测一个有向图是否有环    *拓扑排序实际上应用的是贪心算法    */</span>    <span class="token comment" spellcheck="true">// public boolean canFinish(int numCourses, int[][] prerequisites) {</span>    <span class="token comment" spellcheck="true">//     if (numCourses &lt;= 0) </span>    <span class="token comment" spellcheck="true">//         return false;</span>    <span class="token comment" spellcheck="true">//     int plen = prerequisites.length;</span>    <span class="token comment" spellcheck="true">//     if (plen == 0) </span>    <span class="token comment" spellcheck="true">//         return true;</span>    <span class="token comment" spellcheck="true">//     int[] inDegree = new int[numCourses]; //保存入度</span>    <span class="token comment" spellcheck="true">//     for (int[] p : prerequisites) </span>    <span class="token comment" spellcheck="true">//         inDegree[p[0]]++;</span>    <span class="token comment" spellcheck="true">//     LinkedList&lt;Integer> queue = new LinkedList&lt;>(); //保存入度为0的队列</span>    <span class="token comment" spellcheck="true">//     // 首先加入入度为 0 的结点</span>    <span class="token comment" spellcheck="true">//     for (int i = 0; i &lt; numCourses; i++) {</span>    <span class="token comment" spellcheck="true">//         if (inDegree[i] == 0) {</span>    <span class="token comment" spellcheck="true">//             queue.addLast(i);</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     // 拓扑排序的结果</span>    <span class="token comment" spellcheck="true">//     List&lt;Integer> res = new ArrayList&lt;>();</span>    <span class="token comment" spellcheck="true">//     while (!queue.isEmpty()) {</span>    <span class="token comment" spellcheck="true">//         Integer num = queue.removeFirst();</span>    <span class="token comment" spellcheck="true">//         res.add(num);</span>    <span class="token comment" spellcheck="true">//         // 把邻边全部遍历一下</span>    <span class="token comment" spellcheck="true">//         for (int[] p : prerequisites) {</span>    <span class="token comment" spellcheck="true">//             if (p[1] == num) {</span>    <span class="token comment" spellcheck="true">//                 inDegree[p[0]]--;</span>    <span class="token comment" spellcheck="true">//                 if (inDegree[p[0]] == 0) {</span>    <span class="token comment" spellcheck="true">//                     queue.addLast(p[0]);</span>    <span class="token comment" spellcheck="true">//                 }</span>    <span class="token comment" spellcheck="true">//             }</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return res.size() == numCourses;</span>    <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">/*深度优先遍历    *其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完    */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canFinish</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numCourses <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> prerequisites<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化有向图</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 有向图的 key 是前驱结点，value 是后继结点的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            graph<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span>        <span class="token comment" spellcheck="true">// 所有课程任务可以完成，应该返回 true</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span>    <span class="token comment" spellcheck="true">//return true 表示图中存在环，false 表示访问过了，不用再访问了</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果访问过了，就不用再访问了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从正在访问中，到正在访问中，表示遇到了环</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表示在访问的过程中没有遇到环，这个节点访问过了</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 走到这里，是因为初始化呢，此时 marked[i] == 0</span>        <span class="token comment" spellcheck="true">// 表示正在访问中</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后继结点的集合</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> successorNodes <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer successor <span class="token operator">:</span> successorNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>successor<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 层层递归返回 true ，表示图中存在环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>        <span class="token comment" spellcheck="true">// 状态设置为 2</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// false 表示图中不存在环</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="210-课程表-II：返回有向图路径：拓扑排序-x2F-dfs"><a href="#210-课程表-II：返回有向图路径：拓扑排序-x2F-dfs" class="headerlink" title="210. 课程表 II：返回有向图路径：拓扑排序/dfs"></a>210. 课程表 II：返回有向图路径：拓扑排序/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//拓扑排序</span><span class="token comment" spellcheck="true">//     public int[] findOrder(int numCourses, int[][] prerequisites) {</span><span class="token comment" spellcheck="true">//         if (numCourses &lt;= 0)</span><span class="token comment" spellcheck="true">//             return new int[0];</span>        <span class="token comment" spellcheck="true">//         // 邻接表表示</span><span class="token comment" spellcheck="true">//         HashSet&lt;Integer>[] graph = new HashSet[numCourses];</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//             graph[i] = new HashSet&lt;>();</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         // 入度表</span><span class="token comment" spellcheck="true">//         int[] inDegree = new int[numCourses];</span>        <span class="token comment" spellcheck="true">//         // 遍历 prerequisites 的时候，把 邻接表 和 入度表 都填上</span><span class="token comment" spellcheck="true">//         for (int[] p : prerequisites) {</span><span class="token comment" spellcheck="true">//             graph[p[1]].add(p[0]);</span><span class="token comment" spellcheck="true">//             inDegree[p[0]]++;</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         LinkedList&lt;Integer> queue = new LinkedList&lt;>();</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//             if (inDegree[i] == 0) {</span><span class="token comment" spellcheck="true">//                 queue.addLast(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         ArrayList&lt;Integer> res = new ArrayList&lt;>();</span><span class="token comment" spellcheck="true">//         while (!queue.isEmpty()) {</span><span class="token comment" spellcheck="true">//             Integer inDegreeNode = queue.removeFirst();</span><span class="token comment" spellcheck="true">//             res.add(inDegreeNode);</span><span class="token comment" spellcheck="true">//             HashSet&lt;Integer> nextCourses = graph[inDegreeNode];</span><span class="token comment" spellcheck="true">//             for (Integer nextCourse : nextCourses) {</span><span class="token comment" spellcheck="true">//                 inDegree[nextCourse]--;</span><span class="token comment" spellcheck="true">//                 // 马上检测该结点的入度是否为 0，如果为 0，马上加入队列</span><span class="token comment" spellcheck="true">//                 if (inDegree[nextCourse] == 0) {</span><span class="token comment" spellcheck="true">//                     queue.addLast(nextCourse);</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         // 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span><span class="token comment" spellcheck="true">//         int resLen = res.size();</span><span class="token comment" spellcheck="true">//         if (resLen == numCourses) {</span><span class="token comment" spellcheck="true">//             int[] ret = new int[numCourses];</span><span class="token comment" spellcheck="true">//             for (int i = 0; i &lt; numCourses; i++) {</span><span class="token comment" spellcheck="true">//                 ret[i] = res.get(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             //返回的是数组而不是ArrayList</span><span class="token comment" spellcheck="true">//             return ret;</span><span class="token comment" spellcheck="true">//         } else {</span><span class="token comment" spellcheck="true">//             return new int[0];</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">//DFS</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numCourses <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> prerequisites<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没有有向边，则表示不存在课程依赖，任务一定可以完成</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 初始化有向图 </span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 有向图的 key 是前驱结点，value 是后继结点的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            graph<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 使用 Stack 或者 List 记录递归的顺序，这里使用 Stack</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回空数组</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">assert</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> numCourses<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>                        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span>                        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">,</span>                        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从正在访问中，到正在访问中，表示遇到了环</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 表示在访问的过程中没有遇到环，这个节点访问过了</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> successorNodes <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer successor <span class="token operator">:</span> successorNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>successor<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> marked<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 层层递归返回 true ，表示图中存在环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>        <span class="token comment" spellcheck="true">// 状态设置为 2</span>        marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//拓扑排序</span><span class="token comment" spellcheck="true">//     private int[] inDegree;</span><span class="token comment" spellcheck="true">//     private boolean[][] graph;</span><span class="token comment" spellcheck="true">//     private boolean[] onQueue;</span><span class="token comment" spellcheck="true">//     private Queue&lt;Integer> queue;</span><span class="token comment" spellcheck="true">//     public int[] findOrder(int numCourses, int[][] prerequisites) {</span><span class="token comment" spellcheck="true">//         inDegree=new int[numCourses];</span><span class="token comment" spellcheck="true">//         graph=new boolean[numCourses][numCourses];</span><span class="token comment" spellcheck="true">//         onQueue=new boolean[numCourses];</span><span class="token comment" spellcheck="true">//         queue=new LinkedList&lt;>();</span><span class="token comment" spellcheck="true">//         //初始化</span><span class="token comment" spellcheck="true">//         for(int i=0;i&lt;prerequisites.length;i++){</span><span class="token comment" spellcheck="true">//             graph[prerequisites[i][1]][prerequisites[i][0]]=true;</span><span class="token comment" spellcheck="true">//             inDegree[prerequisites[i][0]]++;</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         int[] rt=new int[numCourses];</span><span class="token comment" spellcheck="true">//         int count=0;</span><span class="token comment" spellcheck="true">//         findNextInDegreeZero();</span><span class="token comment" spellcheck="true">//         while(!queue.isEmpty()){</span><span class="token comment" spellcheck="true">//             int v =queue.poll();</span><span class="token comment" spellcheck="true">//             rt[count++]=v;</span><span class="token comment" spellcheck="true">//             for(int i=0;i&lt;graph[v].length;i++){</span><span class="token comment" spellcheck="true">//                 if(graph[v][i]){</span><span class="token comment" spellcheck="true">//                     inDegree[i]--;</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             findNextInDegreeZero();</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         if(count==numCourses){</span><span class="token comment" spellcheck="true">//          return rt;   </span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return new int[]{};</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">//     public void findNextInDegreeZero(){</span><span class="token comment" spellcheck="true">//         for(int i=0;i&lt;inDegree.length;i++){</span><span class="token comment" spellcheck="true">//             if(inDegree[i]==0&amp;&amp;!onQueue[i]){</span><span class="token comment" spellcheck="true">//                 onQueue[i]=true;</span><span class="token comment" spellcheck="true">//                 queue.add(i);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="5-最长回文子串-中心扩展算法-x2F-DP-x2F-Manacher-算法-马拉车"><a href="#5-最长回文子串-中心扩展算法-x2F-DP-x2F-Manacher-算法-马拉车" class="headerlink" title="5. 最长回文子串:中心扩展算法/DP/Manacher 算法(马拉车)"></a>5. 最长回文子串:中心扩展算法/DP/Manacher 算法(马拉车)</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 中心扩展算法</span>    <span class="token comment" spellcheck="true">// 2n-1个中心（偶数+奇数）</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//奇数长度</span>            <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//偶数长度</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> L <span class="token operator">=</span> left<span class="token punctuation">,</span> R <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            L<span class="token operator">--</span><span class="token punctuation">;</span>            R<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// //动态规划</span>    <span class="token comment" spellcheck="true">// public String longestPalindrome(String s) {</span>    <span class="token comment" spellcheck="true">//     int len = s.length();</span>    <span class="token comment" spellcheck="true">//     if(len&lt;=1)</span>    <span class="token comment" spellcheck="true">//         return s;</span>    <span class="token comment" spellcheck="true">//     int longest = 1;</span>    <span class="token comment" spellcheck="true">//     String str = s.substring(0,1);</span>    <span class="token comment" spellcheck="true">//     boolean[][] dp = new boolean[len][len];</span>    <span class="token comment" spellcheck="true">//     for(int r=1;r&lt;len;r++) {</span>    <span class="token comment" spellcheck="true">//         for(int l=0;l&lt;r;l++) {</span>    <span class="token comment" spellcheck="true">//             if(s.charAt(l)==s.charAt(r) &amp;&amp; (r-l&lt;=2 || dp[l+1][r-1])) {</span>    <span class="token comment" spellcheck="true">//                 dp[l][r]=true;</span>    <span class="token comment" spellcheck="true">//                 if(r-l+1>longest) {</span>    <span class="token comment" spellcheck="true">//                     longest = r-l+1;</span>    <span class="token comment" spellcheck="true">//                     str = s.substring(l,r+1);</span>    <span class="token comment" spellcheck="true">//                 }</span>    <span class="token comment" spellcheck="true">//             }</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return str;</span>    <span class="token comment" spellcheck="true">// }</span>    <span class="token comment" spellcheck="true">//     //Manacher 算法(马拉车)</span><span class="token comment" spellcheck="true">//     //本质上还是中心扩散法</span><span class="token comment" spellcheck="true">//     int len;</span><span class="token comment" spellcheck="true">//     //插入字符，使长度始终未奇数，且不改变回文子串</span><span class="token comment" spellcheck="true">//     private String generateSDivided(String s, char divide) {</span><span class="token comment" spellcheck="true">//         if (s.indexOf(divide) != -1) {</span><span class="token comment" spellcheck="true">//             throw new IllegalArgumentException("参数错误，您传递的分割字符，在输入字符串中存在！");</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         StringBuilder sBuilder = new StringBuilder();</span><span class="token comment" spellcheck="true">//         sBuilder.append(divide);</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; len; i++) {</span><span class="token comment" spellcheck="true">//             sBuilder.append(s.charAt(i));</span><span class="token comment" spellcheck="true">//             sBuilder.append(divide);</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return sBuilder.toString();</span><span class="token comment" spellcheck="true">//     }</span><span class="token comment" spellcheck="true">//     public String longestPalindrome(String s) {</span><span class="token comment" spellcheck="true">//         len = s.length();</span><span class="token comment" spellcheck="true">//         if (len == 0) {</span><span class="token comment" spellcheck="true">//             return "";</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         String sDivided = generateSDivided(s, '#');</span><span class="token comment" spellcheck="true">//         int slen = sDivided.length();</span><span class="token comment" spellcheck="true">//         int[] p = new int[slen];</span><span class="token comment" spellcheck="true">//         int mx = 0;</span><span class="token comment" spellcheck="true">//         // id 是由 mx 决定的，所以不用初始化，只要声明就可以了</span><span class="token comment" spellcheck="true">//         int id = 0;</span><span class="token comment" spellcheck="true">//         int longestPalindrome = 1;</span><span class="token comment" spellcheck="true">//         String longestPalindromeStr = s.substring(0, 1);</span><span class="token comment" spellcheck="true">//         for (int i = 0; i &lt; slen; i++) {</span><span class="token comment" spellcheck="true">//             if (i &lt; mx) {</span><span class="token comment" spellcheck="true">//                 // 这一步是 Manacher 算法的关键所在，一定要结合图形来理解</span><span class="token comment" spellcheck="true">//                 // 这一行代码是关键，可以把两种分类讨论的情况合并</span><span class="token comment" spellcheck="true">//                 p[i] = Integer.min(p[2 * id - i], mx - i);</span><span class="token comment" spellcheck="true">//             } else {</span><span class="token comment" spellcheck="true">//                 // 走到这里，只可能是因为 i = mx</span><span class="token comment" spellcheck="true">//                 if (i > mx) {</span><span class="token comment" spellcheck="true">//                     throw new IllegalArgumentException("程序出错！");</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//                 p[i] = 1;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             // 老老实实去匹配，看新的字符</span><span class="token comment" spellcheck="true">//             //以i为中心，进行中心扩散</span><span class="token comment" spellcheck="true">//             while (i - p[i] >= 0 &amp;&amp; i + p[i] &lt; slen &amp;&amp; sDivided.charAt(i - p[i]) == sDivided.charAt(i + p[i])) {z</span><span class="token comment" spellcheck="true">//                 p[i]++;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             // 我们想象 mx 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span><span class="token comment" spellcheck="true">//             // 写到这里，我们发现，如果 mx 的值越大，</span><span class="token comment" spellcheck="true">//             // 进入上面 i &lt; mx 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span><span class="token comment" spellcheck="true">//             if (i + p[i] > mx) {</span>        <span class="token comment" spellcheck="true">//                 id = i;</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//             if (p[i] - 1 > longestPalindrome) {</span><span class="token comment" spellcheck="true">//                 longestPalindrome = p[i] - 1;</span><span class="token comment" spellcheck="true">//                 longestPalindromeStr = sDivided.substring(i - p[i] + 1, i + p[i]).replace("#", "");</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return longestPalindromeStr;</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//         int n = s.length();</span><span class="token comment" spellcheck="true">//         int[][] dp = new int[n][n];</span>        <span class="token comment" spellcheck="true">//         //00, 11, 22, 33, 44</span><span class="token comment" spellcheck="true">//         for(int i=0; i&lt;n; i++){</span><span class="token comment" spellcheck="true">//             dp[i][i] = 1;//从i到j的最长回文子序列长度</span><span class="token comment" spellcheck="true">//         }</span>        <span class="token comment" spellcheck="true">//         //01, 12, 23, 34</span><span class="token comment" spellcheck="true">//         //02,13,24</span><span class="token comment" spellcheck="true">//         //03,14</span><span class="token comment" spellcheck="true">//         //04</span><span class="token comment" spellcheck="true">//         for(int l=2; l&lt;=n; l++){//l是子序列长度</span><span class="token comment" spellcheck="true">//             for(int i=0; i&lt;n-l+1; i++){//i是start</span><span class="token comment" spellcheck="true">//                 int j = i+l-1;//j是end</span><span class="token comment" spellcheck="true">//                 if(l==2 &amp;&amp; s.charAt(j) == s.charAt(i)) dp[i][j] = 2;//长度为2</span><span class="token comment" spellcheck="true">//                 else if (s.charAt(j) == s.charAt(i)) dp[i][j] = 2 + dp[i+1][j-1];</span><span class="token comment" spellcheck="true">//                 else dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return dp[0][n-1];//从0到n-1</span>                <span class="token comment" spellcheck="true">//改进 从后往前（应该和从前往后一样）</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> current<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            current<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    current<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>pre<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    current<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>current<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>current<span class="token punctuation">;</span>            current<span class="token operator">=</span>tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//     //回溯</span><span class="token comment" spellcheck="true">//     public boolean isMatch(String text, String pattern) {</span><span class="token comment" spellcheck="true">//         if (pattern.isEmpty())</span><span class="token comment" spellcheck="true">//             return text.isEmpty();</span><span class="token comment" spellcheck="true">//         boolean first_match = (!text.isEmpty() &amp;&amp;</span><span class="token comment" spellcheck="true">//                                (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));</span><span class="token comment" spellcheck="true">//         if (pattern.length() >= 2 &amp;&amp; pattern.charAt(1) == '*'){</span><span class="token comment" spellcheck="true">//             return (isMatch(text, pattern.substring(2)) ||</span><span class="token comment" spellcheck="true">//                     (first_match &amp;&amp; isMatch(text.substring(1), pattern)));</span><span class="token comment" spellcheck="true">//         } else {</span><span class="token comment" spellcheck="true">//             return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">//动态规划 自顶向下</span>    <span class="token comment" spellcheck="true">//其实只是想回溯的结果记录，即备忘录</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不能用boolean,无法判断是否已保存结果（==null）</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> String text<span class="token punctuation">,</span> String pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans <span class="token operator">=</span> i <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">boolean</span> first_match <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                                   <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">||</span>                                    pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token operator">||</span>                       first_match <span class="token operator">&amp;&amp;</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                ans <span class="token operator">=</span> first_match <span class="token operator">&amp;&amp;</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//     //动态规划 自底向上</span><span class="token comment" spellcheck="true">//     public boolean isMatch(String text, String pattern) {</span><span class="token comment" spellcheck="true">//         boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];</span><span class="token comment" spellcheck="true">//         dp[text.length()][pattern.length()] = true;</span><span class="token comment" spellcheck="true">//         for (int i = text.length(); i >= 0; i--){</span><span class="token comment" spellcheck="true">//             for (int j = pattern.length() - 1; j >= 0; j--){</span><span class="token comment" spellcheck="true">//                 boolean first_match = (i &lt; text.length() &amp;&amp;</span><span class="token comment" spellcheck="true">//                                        (pattern.charAt(j) == text.charAt(i) ||</span><span class="token comment" spellcheck="true">//                                         pattern.charAt(j) == '.'));</span><span class="token comment" spellcheck="true">//                 if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j+1) == '*'){</span><span class="token comment" spellcheck="true">//                     dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];</span><span class="token comment" spellcheck="true">//                 } else {</span><span class="token comment" spellcheck="true">//                     dp[i][j] = first_match &amp;&amp; dp[i+1][j+1];</span><span class="token comment" spellcheck="true">//                 }</span><span class="token comment" spellcheck="true">//             }</span><span class="token comment" spellcheck="true">//         }</span><span class="token comment" spellcheck="true">//         return dp[0][0];</span><span class="token comment" spellcheck="true">//     }</span><span class="token punctuation">}</span></code></pre><h2 id="44-通配符匹配：双指针-x2F-动态规划"><a href="#44-通配符匹配：双指针-x2F-动态规划" class="headerlink" title="44. 通配符匹配：双指针/动态规划"></a>44. 通配符匹配：双指针/动态规划</h2><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><blockquote><ul><li>‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符串（包括空字符串）。</li></ul></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//双指针</span>    <span class="token comment" spellcheck="true">// public boolean isMatch(String s, String p) {</span>    <span class="token comment" spellcheck="true">//     int sn = s.length();</span>    <span class="token comment" spellcheck="true">//     int pn = p.length();</span>    <span class="token comment" spellcheck="true">//     int i = 0;</span>    <span class="token comment" spellcheck="true">//     int j = 0;</span>    <span class="token comment" spellcheck="true">//     int start = -1;</span>    <span class="token comment" spellcheck="true">//     int match = 0;</span>    <span class="token comment" spellcheck="true">//     while (i &lt; sn) {</span>    <span class="token comment" spellcheck="true">//         if (j &lt; pn &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {</span>    <span class="token comment" spellcheck="true">//             i++;</span>    <span class="token comment" spellcheck="true">//             j++;</span>    <span class="token comment" spellcheck="true">//         } else if (j &lt; pn &amp;&amp; p.charAt(j) == '*') {</span>    <span class="token comment" spellcheck="true">//             start = j;</span>    <span class="token comment" spellcheck="true">//             match = i;</span>    <span class="token comment" spellcheck="true">//             j++;</span>    <span class="token comment" spellcheck="true">//         } else if (start != -1) { //还没到*匹配结束的位置</span>    <span class="token comment" spellcheck="true">//             j = start + 1;</span>    <span class="token comment" spellcheck="true">//             match++;</span>    <span class="token comment" spellcheck="true">//             i = match;</span>    <span class="token comment" spellcheck="true">//         } else {</span>    <span class="token comment" spellcheck="true">//             return false;</span>    <span class="token comment" spellcheck="true">//         }</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     while (j &lt; pn) { //i=sn 即i指针已结束，但j指针还没结束</span>    <span class="token comment" spellcheck="true">//         if (p.charAt(j) != '*') return false;</span>    <span class="token comment" spellcheck="true">//         j++;</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">//     return true;</span>    <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">//动态规划</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//*为任意字符或空字符</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目要求-2"><a href="#题目要求-2" class="headerlink" title="题目要求"></a>题目要求</h3><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    bool isHappy(int n) {        unordered_set<int> bobo;        while(!bobo.count(n)){            int sum = 0;            bobo.insert(n);            while(n != 0){                sum = sum + (n%10) * (n%10);                n /= 10;            }            n = sum;        }        return n == 1;    }};//递归class Solution {public:    unordered_set<int> bobo;    bool isHappy(int n) {        int sum = 0;        if(n == 1) return true;        else if(bobo.count(n))  return false;        else{            bobo.insert(n);            while(n != 0){                sum = sum + (n%10) * (n%10);                n /= 10;            }            n = sum;        }        return isHappy(n);    }};</code></pre><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><h3 id="题目要求-3"><a href="#题目要求-3" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断无向图是否有换，以及是否为单连通分量</span>    <span class="token comment" spellcheck="true">//当只有n-1条边，且连通数为1时，符合条件</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只应该有n-1条边</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> par <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> par1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>par2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            par<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//并查集，每个点的父节点是自己</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            par1 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            par2 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不断向上寻找得到par1和par2的祖先节点</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">)</span>                par1 <span class="token operator">=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">while</span><span class="token punctuation">(</span>par2 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">)</span>                par2 <span class="token operator">=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par2<span class="token punctuation">)</span><span class="token punctuation">{</span>                par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span> <span class="token operator">=</span> par1<span class="token punctuation">;</span>                n<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="695-岛屿的最大面积-最大的无向连通图-x2F-dfs"><a href="#695-岛屿的最大面积-最大的无向连通图-x2F-dfs" class="headerlink" title="695. 岛屿的最大面积:最大的无向连通图/dfs"></a>695. 岛屿的最大面积:最大的无向连通图/dfs</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//最大的无向连通图 模板</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        c <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>c<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//直接返回当前dfs的数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> i<span class="token operator">>=</span>r <span class="token operator">||</span> j<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">>=</span>c <span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//grid[i][j]==0一定要放在最后面，避免下标越界</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="394-字符串解码-栈"><a href="#394-字符串解码-栈" class="headerlink" title="394. 字符串解码:栈"></a>394. 字符串解码:栈</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">decodeString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>String<span class="token operator">></span> strStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String tempStr <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i用来控制指针坐标</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> numStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String nowStr <span class="token operator">=</span> <span class="token function">repeatStr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>numStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   StringBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//将后面不需要重复的字符（遇到下一个]和数字之前的字符）加到builder后面</span>                   <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       m<span class="token operator">++</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                   builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    tempStr <span class="token operator">=</span> null<span class="token punctuation">;</span>                    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//可能是个多位数</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    m<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                numStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//得到下一个字符串</span>                <span class="token keyword">int</span> k <span class="token operator">=</span>  i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'9'</span> <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>                    k<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">repeatStr</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//两遍哈希</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> i<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一遍哈希</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-无重复字符的最长子串：滑动窗口"><a href="#3-无重复字符的最长子串：滑动窗口" class="headerlink" title="3. 无重复字符的最长子串：滑动窗口"></a>3. 无重复字符的最长子串：滑动窗口</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Character<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化：使用 HashMap</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// current index of character</span>        <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化：假设字符集为 ASCII 128</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// current index of character</span>        <span class="token comment" spellcheck="true">// try to extend the range [i, j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>index<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="20-有效的括号：栈"><a href="#20-有效的括号：栈" class="headerlink" title="20. 有效的括号：栈"></a>20. 有效的括号：栈</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Hash table that takes care of the mappings.</span>  <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span> mappings<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Initialize hash map with mappings. This simply makes the code easier to read.</span>  <span class="token keyword">public</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Initialize a stack to be used in the algorithm.</span>    Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// If the current character is a closing bracket.</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Get the top element of the stack. If the stack is empty, set a dummy value of '#'</span>        <span class="token keyword">char</span> topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'#'</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// If the mapping for this bracket doesn't match the stack's top element, return false.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topElement <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If it was an opening bracket, push to the stack.</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If the stack still contains elements, then it is an invalid expression.</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//大顶堆</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// init heap 'the smallest element first'</span>        PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> heap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> n1 <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// keep k largest elements in the heap</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>          heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>            heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// output</span>        <span class="token keyword">return</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//快速选择（类似快排）</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. move pivot to end</span>    <span class="token function">swap</span><span class="token punctuation">(</span>pivot_index<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> store_index <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. move all smaller elements to the left</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>store_index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        store_index<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3. move pivot to its final place</span>    <span class="token function">swap</span><span class="token punctuation">(</span>store_index<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> store_index<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">quickselect</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k_smallest<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    Returns the k-th smallest element of list within left..right.    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If the list contains only one element,</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// return that element</span>    <span class="token comment" spellcheck="true">// select a random pivot_index</span>    Random random_num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot_index <span class="token operator">=</span> left <span class="token operator">+</span> random_num<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>         pivot_index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> pivot_index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the pivot is on (N - k)th smallest position</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_smallest <span class="token operator">==</span> pivot_index<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>k_smallest<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// go left side</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k_smallest <span class="token operator">&lt;</span> pivot_index<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> pivot_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// go right side</span>    <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span>pivot_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// kth largest is (N - k)th smallest</span>    <span class="token keyword">return</span> <span class="token function">quickselect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="703-数据流中的第K大元素-最小堆"><a href="#703-数据流中的第K大元素-最小堆" class="headerlink" title="703. 数据流中的第K大元素:最小堆"></a>703. 数据流中的第K大元素:最小堆</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">KthLargest</span> <span class="token punctuation">{</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxHeap<span class="token punctuation">;</span>     <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//维护一个大小为k的最小堆 堆顶即是第k大的元素</span>    <span class="token keyword">public</span> <span class="token function">KthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        length <span class="token operator">=</span> k<span class="token punctuation">;</span>        maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;=</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                maxHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//最小堆</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历map，用最小堆保存频率最大的k个元素</span>        PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">,</span> Integer b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取出最小堆中的元素</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//桶排序法</span><span class="token comment" spellcheck="true">//基于桶排序求解「前 K 个高频元素」</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//桶排序</span>        <span class="token comment" spellcheck="true">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取出现的次数作为下标</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>               list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 倒序遍历数组获取出现顺序从大到小的排列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//官方题解</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// build hash map : character and how often it appears</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      count<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// init heap 'the less frequent element first'</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> heap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">-</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// keep k top frequent elements in the heap</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>        heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// build output list</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> top_k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      top_k<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>top_k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> top_k<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习</title>
      <link href="/2022/05/31/shu-ju-jie-gou-fu-xi/"/>
      <url>/2022/05/31/shu-ju-jie-gou-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul><li><p>线式存储结构： 结构地址空间连接，可随机访问，但顺序存储插入操作需要移动之后的元素，要耗费许多时间。</p></li><li><p>链式存储：不要求逻辑上相邻的元素在物理上相连，元素之间的逻辑关系通过指针表示。</p></li><li><p>顺序存储： 逻辑上相邻物理也相邻</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈： 先入后出，在表的末端（栈顶）进行插入删除，栈的存储结构分为<strong>基于数组的存储表示和顺序存储结构</strong>和<strong>基于链表的链式存储结构</strong><br>    - 顺序栈的内存结构：存放栈中元素的数组、栈顶指针、最大容纳元素个数<br>    - 链式栈的内存结构：栈顶指针  </p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列：先入先出，队尾插入队首删除。<ul><li><p>队列的顺序存储结构利用一个<em>一维数组</em>作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。</p></li><li><p>队列的链式队列由队首指针和队尾指针构成。</p></li><li><p>循环队列元素个数 = （尾 - 头 + 表长） % 表长</p><ol><li>当尾 &gt; 头， 元素个数 = 尾 - 头</li><li>因为是循环队列，可能出现头&gt;尾的情况， 此时元素个数 = 尾 - 头 + 表长<br>  为了得到一个统一的公式–循环队列元素个数 = （尾 - 头 + 表长） % 表长</li></ol></li><li><p>判断循环队列队空、队满的方法：<br>  front表示队头指针（指向队列内首元素）,rear表示队尾指针（指向队列内尾元素的下一个位置）,m表示队列的容量（包括那个留空的位置）</p><p>  <strong>队列内元素个数：(rear - front + m) % m</strong></p><p>  <img src="/img/posts/DataStructure/cycle_queue3.jpg"></p><p>  当队列为空时条件：<strong>rear == front</strong>，当队列满时条件为：<strong>（rear+1）% maxsize == front</strong></p></li></ul></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>hash表的实现主要包括构造哈希和处理哈希冲突两个方面：</p><p>对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。</p><p>对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>保持原图的n个系节点，并且有保持图联通的最少边。简单来说是有钱仅有n个点n-1条边的连通图。</p></li><li><p>最小生成树就是最小权重生成树的简称，即所有边的权值之和最小的生成树。</p></li></ul><p>求解最小生成树的方法有一下两种</p><h5 id="Kruskal算法（克鲁斯卡）"><a href="#Kruskal算法（克鲁斯卡）" class="headerlink" title="Kruskal算法（克鲁斯卡）"></a>Kruskal算法（克鲁斯卡）</h5><p>Kruskal是一种贪心算法</p><ul><li><p>核心思想：每次选择一条最小的边，使这两条边两头连通 </p></li><li><p>将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树。</p></li><li><p>如果两个顶点在同一个集合内，说明已经通过其他边相连，如果将这条边加入生成树，就会形成环，因此不可取</p></li></ul><p>Kruskal算法时间复杂的：O(mlogm),Kruskal算法的简单实现</p><pre class=" language-Java"><code class="language-Java">//Kruskal算法简单实现void Kruskal(V,T){    T = V; //初始化树T，仅含顶点    numS = n; //连通分量数    while(numS > 1) //若连通分量数大于1    {        从E中取出权值最小的边(v,u);        if(v和u属于T中不同的连通分量)        {            T=T∪{(v,u)}; //将此边加入生成树中            numS--; //连通分量数减1        }    }}</code></pre><p><img src="/img/posts/DataStructure/kruskal0.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法汇总</title>
      <link href="/2022/05/01/pai-xu-suan-fa-hui-zong/"/>
      <url>/2022/05/01/pai-xu-suan-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<ul><li>为了方便表示,提前定义swap(num[],i,j)<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>从左到右不断交换相邻的逆序的元素，复杂度为O(N^2)</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isSorted<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            isSorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    isSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    </code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>左侧是以及排好序的涉猎，每次排序都将当前元素插入左侧已经排序的数组中，是的插入之后左侧数组依然有序。</p></li><li><p>以数组[3,4,1,5,2]为例，逆序的对有(3,1),(3,2)(4,1)(4,2)(5,2)，插入排序每次交换逆序元素，因此插入排序交换的次数为逆序的数量插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要交换的次数也少，时间复杂度较低</p></li><li><p>Worst case:数组倒序</p></li><li><p>Best case:数组有序</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 这一步会把左边的都排好序 */</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>时间复杂度：*<em>最坏情况下为O(N</em>N)**，此时待排序列为逆序，或者说接近逆序最好情况下为O(N)，此时待排序列为升序，或者说接近升序。<br>空间复杂度：O(1)</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>插入排序不适用于，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的难以处理大规模数组的问题，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><ul><li><p>先将待排序数组进行与排序，是的待排序数组接近于有序，再对该序列进行一次插入排序</p></li><li><p>eg:<br>  3 2 5 4 1 6(gap = 6)<br>  3 2 5 4 1 6(gap = 6/2 = 3) (3,4)是正序，不需要改变<br>  3 1 5 4 2 6(gap = 3) (2,1)变成（1,2）<br>  3 1 5 4 2 6(gap = 3) (5,6)是正序不需要改变<br>  3/2 = 1,此时用插入排序（若gap = 10，10/2 = 5， 5/2 =2&gt;1,则在以gap = 2进行排序</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 4, 13, 40, ...</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> h <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>时间复杂度平均：O(N^1.3)</strong><br><strong>空间复杂度：O(1)</strong></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>时间复杂度：最坏情况：<strong>O(N^2)</strong><br>            最好情况：O(N^2)<br>空间复杂度：O(1)</p><ul><li>改进：我们可以一次性选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是一种树形选择排序，它利用堆这种数据结构，将待排序列构造成一个大根堆或小根堆，然后将堆顶元素（最大或最小元素）与最后一个元素交换，再重新调整堆，直到排序完成。时间复杂度为 O(nlogn)。</p><p><strong>堆是一颗完全二叉树</strong>，可以用数组来表示，因为完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。</p><ul><li>大根堆：所有父节点大于子节点<br>  小根堆：所有父节点小于子节点</li></ul><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>maxN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T t <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="堆的上浮与下沉"><a href="#堆的上浮与下沉" class="headerlink" title="堆的上浮与下沉"></a>堆的上浮与下沉</h4><ul><li>一般采用大根堆–当一个节点比父节点大时，需要交换这两个节点。交换后可能还比它的新的父节点大，因此需要不断地进行比较和交换，这就是上浮操作。</li></ul><p>k/2是父节点</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> j<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h4><ul><li><p>插入：将新元素放到数组末尾，然后上浮到合适的位置</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        heap<span class="token punctuation">[</span><span class="token operator">++</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token function">swim</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>删除：从堆顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> T <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        T max <span class="token operator">=</span> heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul><h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>它的主要思想是<strong>选取一个基准元素，通过一趟排序将待排序列分成两部分</strong>，其中一部分比基准元素小，另一部分比基准元素大。然后再分别对这两部分递归地进行快速排序，最终完成排序。时间复杂度为 O(nlogn)</p><p>参考<a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/p57uhr/">Leetcode图解算法结构–快速排序</a><br>快速排序算法有两个核心点，分别为 哨兵划分 和 递归 .</p><h4 id="哨兵划分："><a href="#哨兵划分：" class="headerlink" title="哨兵划分："></a>哨兵划分：</h4><p>以数组某个元素（一般选取首元素）为 基准数 ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p><p>如数组 [3,2,5,1,0,4]<br>选取最左元素arr[0] = 3作为 l， 最右元素arr[5] = 4 作为r，假设以arr[0] = 3作为哨兵，那么令 i 从 l 开始向左移动，令 j 从 r 开始向右移动<br>[3,2,5,1,0,4]<br> i         j<br> 此时arr[j]=4&gt;3,所以j左移<br>[3,2,5,1,0,4]<br> i       j<br> 此时arr[j] = 0 &lt; 3, j不动， i开始移动<br>[3,2,5,1,0,4]<br>     i   j<br>此时arr[i] = 5 &lt; 3，所以<strong>此时arr[i]与arr[j]元素交换位置</strong>，原数组变为[3,2,0,1,5,4]， j继续左移<br>[3,2,0,1,5,4]<br>     i j<br> 此时arr[j] = 1 &lt; 3, j不动， i开始移动</p><p>[3,2,0,1,5,4]<br>       ij<br>此时i,j相遇，将该元素与最左元素，也就是<strong>哨兵元素</strong>换位，原数组变为<br>[1,2,0,3,5,4]</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>以哨兵元素作为划分标准，哨兵元素左侧的数组为左子数组，哨兵元素右侧的数组为右子数组。<br>快排后数组[1,2,0,3,5,4],左子数组为[1,2,0] 哨兵：3 右子数组为[5,4]<br>然后对左右子数组重复快排<br>左子数组[1,2,0] -&gt; [1,0,2] -&gt; [0,1,2]<br>右子数组[5,4] -&gt; [4,5]</p><p>[0,1,2] 3 [4,5]</p><p>排序完成</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 分类，其中每次返回的i其实正是哨兵的数字     * @param arr     * @param l     * @param r     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> sentry <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token operator">+</span>r<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义哨兵</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> r<span class="token punctuation">,</span>i <span class="token operator">=</span> l<span class="token punctuation">;</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 递归，多次快排     * @param arr     * @param l     * @param r     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SortInRecurse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">Sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num:"</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SortInRecurse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SortInRecurse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>它的主要思想是将<strong>待排序列分成若干个子序列</strong>，然后将每个子序列进行排序，最后将排好序的子序列合并成一个有序序列。时间复杂度为 O(nlogn)。</p><blockquote><p><strong>归并和快排的区别</strong>：快速排序是一种交换排序，它在排序过程中直接交换元素位置，<strong>通过一次排序将待排序序列分成两个子序列，递归地对两个子序列进行排序</strong>。而归并排序是一种合并排序，它将<strong>待排序序列分成两个子序列，递归地对两个子序列进行排序，</strong>然后将排好序的两个子序列合并成一个有序序列。</p></blockquote><blockquote><p>归并、快排和堆排序：快速排序和归并排序都是递归算法，适用于大规模数据的排序；而堆排序则是一种非递归算法，适用于内存有限的排序场景</p></blockquote><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/p5l0js/">算法解析</a><br>归并排序体现了 “分而治之” 的算法思想，具体为：</p><p>「分」： 不断将数组从 中点位置 划分开，将原数组的排序问题转化为子数组的排序问题；<br>「治」： 划分到子数组长度为 1 时，开始向上合并，不断将 左右两个较短排序数组 合并为 一个较长排序数组，直至合并至原数组时完成排序；</p><p><img src="/img/posts/DataStructure/merge_sort.jpg" alt="Merge"></p><p>该算法可以分为划分子数组和合并子数组两步</p><p>如数组[4,2,3,1]<br>先分为[4,2],[3,1]<br>再分为[4][2][3][1]</p><p>合并：对于原数组[4，2，3，1]，构建一个tmp数组，存放每次递归中的<strong>arr子数组</strong>。如第一次<strong>递归tmp[] = [4,2]</strong>,m为原数组中间数 = (r+l)/2 = 0，l为最左侧 = 0，r为最右侧 = 1。<br> 令i = 0, j = m-l+1 = 1, tmp[i] = 4, tmp[j] = 2 , 因为2&lt;4， 令arr[0]2，然后j++, 发现右数组遍历完成，由此原数组 **arr = [2,2,3,1]**<br>在arr[1] = tmp[j], 原数组 **arr[] = [2，4，3，1]**, j++, tmp[j] = 3 &gt; tmp[i] = 2</p><p>[1，3]同理（此时是新一轮为递归）, 此时原数组为[2，4，3，1],tmp[] = [3,1], l = 2, r = 3, m = 2, 重新令i = 0, j = m-l+1 = 1。 tmp[i] = 1 &gt; tmp[j] = 3, 因此arr[2] = tmp[j] = 1，原数组 <strong>arr[] = [2,4,1,1]</strong>,j++,发现j&gt;=r-l, 开始直接将tmp[i]加入数组，此时原数组 <strong>arr[] = [2,4,1,3]</strong>,归并结束 </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// partition</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>r<span class="token operator">+</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// merge</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        注意因为每次递归都会更新一部分的arr        比如原arr[3,1,4,2]        第一次递归对3,1排序， 排完后arr变成[1,3,4,2]        第二次递归需要对4,2排序,所以要求arr的下标从arr[2]也就是4开始,因此int k = l 而不是 0         */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> m<span class="token operator">-</span>l<span class="token punctuation">)</span>  <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// if left approch the end</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> r<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="对链表归并"><a href="#对链表归并" class="headerlink" title="对链表归并"></a>对链表归并</h5><p><a href="https://leetcode.cn/problems/sort-list/">Leetcode148</a><br>148. 排序链表<br>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>如4-&gt;1-&gt;3 返回 1-&gt;3-&gt;4</p><p>注意链表和数组的不同，链表由于没有下标，在划分的时候，用快慢指针，fast每次移动两步，而slow每次移动一步</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> ListNode <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            fast <span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode mid <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode left <span class="token operator">=</span> <span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode right <span class="token operator">=</span>  <span class="token function">sortList</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode res <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">></span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> right<span class="token punctuation">;</span>                right <span class="token operator">=</span> right<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> left<span class="token punctuation">;</span>                left <span class="token operator">=</span> left<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> left <span class="token operator">==</span> null<span class="token operator">?</span> right<span class="token operator">:</span> left<span class="token punctuation">;</span>          <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter使用指北</title>
      <link href="/2022/03/17/jupyter-shi-yong-zhi-bei/"/>
      <url>/2022/03/17/jupyter-shi-yong-zhi-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用pip进行安装，为了避免可能产生的配置错误，这里直接进入conda虚拟环境进行安装</p><pre class=" language-cmd"><code class="language-cmd">    conda activate jupyter    pip install jupyter</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre class=" language-cmd"><code class="language-cmd">    jupyter notebook</code></pre><p>注意使用该命令所在的目录，如果直接在user目录下运行该指令，打开jupyter会出现<br><img src="/img/posts/config/Jupyter_desktop.jpg" alt="C:\Users> jupyter notebook"><br>如果有要直接打开的项目，可cd到指定的目录下在运行jupyter notebook命令</p><h2 id="Kernel-内核配置"><a href="#Kernel-内核配置" class="headerlink" title="Kernel 内核配置"></a>Kernel 内核配置</h2><ul><li><p>查看内核</p><pre class=" language-cmd"><code class="language-cmd">    jupyter kernelspec list</code></pre><p>可以查看指定目录下的kernel.json文件，看python解释器的位置是否正确</p></li><li><p>添加内核(在该虚拟环境下)</p><pre class=" language-cmd"><code class="language-cmd">    python -m ipykernel install --name jupyerEnv --display-name jupyterEnv --prefix=E:\Software\Anaconda\Anaconda\envs\unity\</code></pre><p>  会添加到E:\Software\Anaconda\Anaconda\share\jupyter\kernels\jupyterEnv目录下</p></li><li><p>删除内核</p><pre class=" language-cmd"><code class="language-cmd">    jupyter kernelspec remove jupyterEnv</code></pre></li></ul><h2 id="jupyter与python环境"><a href="#jupyter与python环境" class="headerlink" title="jupyter与python环境"></a>jupyter与python环境</h2><p>一般jupyter会默认使用anaconda默认的python环境，也就是说，在某个虚拟环境中pip的包，在jupyter中不一定能成功地import<br>所有如果要在某个环境下使用jupyter<br>先 conda activate 该环境<br>再在该环境下jupyter notebook</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本知识</title>
      <link href="/2022/03/16/linux-ji-ben-zhi-shi/"/>
      <url>/2022/03/16/linux-ji-ben-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-环境"><a href="#linux-环境" class="headerlink" title="linux 环境"></a>linux 环境</h2><p>Linux内核的源码开源网站(<a href="http://www.kernel.org/">http://www.kernel.org</a>)<br>Linux常用的发行版本： Ubuntu， CentOs， RedHat</p><h2 id="Linux-目录"><a href="#Linux-目录" class="headerlink" title="Linux 目录"></a>Linux 目录</h2><p>~ home目录<br>/ root目录<br>/lib 系统使用的函数库的沐浴露<br>/etc 系统配置文件村对方的目录<br>/bin 二进制文件存放目录</p><h2 id="Linux-指令"><a href="#Linux-指令" class="headerlink" title="Linux 指令"></a>Linux 指令</h2><h3 id="目录指令"><a href="#目录指令" class="headerlink" title="目录指令"></a>目录指令</h3><p>ls 列出目录下的文件 ls -a 显示包括隐藏目录 ls -l 显示文件的详细信息</p><p>mkdir 创建新的目录 /文件 mkdir -p</p><pre class=" language-Linux"><code class="language-Linux">mkdir test/test01.txt -p</code></pre><p>若不存在test文件夹，会创建test文件夹后创建你test01文件</p><p>touch创建空白文件</p><pre class=" language-Linux"><code class="language-Linux">touch 01.txt</code></pre><p>rm 删除 rm -f强制删除 rm -r删除目录及其下面的子文件</p><p>pwd 查询当前位置</p><p>cd 切换目录</p><p>mv 移动文件</p><p>cp 复制文件，若要同时移动该文件下的子文件要用cp -r<br>cp t.txt Document/t<br>该命令将把文件t.txt复制到Document目录下，并命名为t。</p><h3 id="查看文件中内容"><a href="#查看文件中内容" class="headerlink" title="查看文件中内容"></a>查看文件中内容</h3><p>cat 查看文件内容</p><pre class=" language-Linux"><code class="language-Linux">Cat 1.txt</code></pre><p>查看1文件中的内容</p><p>more 查看大文件内容</p><pre class=" language-Linux"><code class="language-Linux">More 1.txt</code></pre><p>当1为大文件时，可以用more查看，more支持分页查看（space切换下一页，b返回上一页）</p><p>tail 查看追加内容， 其中tail -f可以查看实时更新的结果（ctrl+c结束）<br>可以同时开两个窗口，在第一个窗口输入</p><pre class=" language-Linux"><code class="language-Linux">tail 1.txt</code></pre><p>在第二各窗口输入</p><pre class=" language-Linux"><code class="language-Linux">date >> 1.txt</code></pre><p>查看1文件中新追加的内容(当下时间)</p><p>echo 追加新的内容<br>echo a &gt; 1.txt  直接覆盖于<br>Echo a &gt;&gt; 1.txt 将a插入1.txt 文件的末端<br>echo a会直接将结果打印到控制台上</p><p>Date &gt;&gt; 1.txt 将当前时间插入文件中 date本身用于时间chakan</p><p>Cal 查看日历 cal &gt;&gt; 1.txt 将日历添加到1.txt中</p><h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>将一个命令的执行的结果作为内容提交给下一个命令处理， 类似嵌套</p><pre class=" language-Linux"><code class="language-Linux">    ps -ef | grep 1001</code></pre><h3 id="文件与进程交互命令"><a href="#文件与进程交互命令" class="headerlink" title="文件与进程交互命令"></a>文件与进程交互命令</h3><p><strong>grep 搜索</strong></p><p>grep命令是一种强大的文本搜索工具</p><p>使用实例：</p><p>ps -ef | grep sshd  查找指定ssh服务进程<br>ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身<br>ps -ef | grep sshd -c 查找指定进程个数 </p><p><strong>find</strong>：在目录结构总搜索文件，并对搜索结果进行指定的操作<br>ind 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p><p>使用实例：</p><p>find . -name “<em>.log” -ls  在当前目录查找以.log结尾的文件，并显示详细信息。<br>find /root/ -perm 600   查找/root/目录下权限为600的文件<br>find . -type f -name “</em>.log”  查找当目录，以.log结尾的普通文件<br>find . -type d | sort   查找当前所有目录并排序<br>find . -size +100M  查找当前目录大于100M的文件</p><p>find和grep都是在Linux系统中用于查找文件或字符串的命令，但它们的用途和功能是不同的。</p><p>find命令用于在指定的目录中查找文件，可以根据文件名、文件类型、文件大小、权限等属性进行过滤搜索。例如，可以使用以下命令在当前目录及其子目录中查找所有名为filename的文件：</p><pre class=" language-linux"><code class="language-linux">find . -name filename</code></pre><p>grep命令用于在指定的文件中查找包含指定字符串的行，可以根据字符串、正则表达式等进行过滤搜索。例如，可以使用以下命令在文件filename中查找包含字符串”searchtext”的行：</p><pre class=" language-linux"><code class="language-linux">grep "searchtext" filename</code></pre><h3 id="压缩和解压文件"><a href="#压缩和解压文件" class="headerlink" title="压缩和解压文件"></a>压缩和解压文件</h3><p>tar 解压<br>-c 创建一个新归档</p><p>-f 当与-c选项一起使用时，创建的tar文件使用该选项指定的文件名；当与-x选项一起使用时，则解除该选项指定的归档</p><p>-t 显示包括在tar文件中的文件列表</p><p>-v 显示文件的归档进度</p><p>-x 从归档中抽取文件</p><p>-z 使用gzip压缩tar文件</p><p>-j 使用bzip2压缩tar文件</p><p><strong>要创建一个tar文件，输入命令</strong>：tar –cvf filename.tar directory/file/home/mine ： 将directory/file、/home/mine放入归档文件中。</p><p>要列出tar文件的内容，输入命令：</p><p>tar –tvf filename.tar</p><p>要抽取tar文件的命令，输入命令：</p><p>tar –xvf filename.tar</p><p>这个命令不会删除tar文件，但会把解除归档的内容复制到当前工作目录下，并保留归档文件所使用的任何目录结构。</p><p><strong>压缩文件</strong>：tar默认不压缩文件。<strong>要创建一个使用tar和bzip2来归档压缩的文件，使用-j选项</strong>：</p><p>tar –cvfj filename.tbz file</p><p><strong>解压tbz格式</strong>: tar -xvfj file.tar.tbz example.cpp //解压形成example.cpp的格式<br><strong>解压gz格式</strong>：tar -zxvf  file.tar.gz  //解压到当前的文件夹</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看网络状态</p><p>查看系统上的网络状态。<br>选项：<br>-a 显示所有正在或不在侦听的套接字<br>-n 显示数字形式地址而不是去解析主机、端口或用户名<br>-p 显示套接字所属进程的PID和名称</p><p>示例：<br>netstat -anp<br>netstat -anp | grep “进程名”<br>netstat -anp | grep “端口号” </p><h3 id="挂载后台"><a href="#挂载后台" class="headerlink" title="挂载后台"></a>挂载后台</h3><pre class=" language-linux"><code class="language-linux">nohup command &</code></pre><h3 id="查找进程"><a href="#查找进程" class="headerlink" title="查找进程"></a>查找进程</h3><pre class=" language-linux"><code class="language-linux">ps -ef</code></pre><p>可以显示用户所有进程</p><pre class=" language-linux"><code class="language-linux">ps-ef | grep firefox</code></pre><p>查找所有有火狐的进程</p><pre class=" language-linux"><code class="language-linux">pkill firefox </code></pre><p>or</p><pre class=" language-linux"><code class="language-linux">kill 12345</code></pre><p>都可以杀死进程</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON配置</title>
      <link href="/2022/01/14/json-pei-zhi/"/>
      <url>/2022/01/14/json-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-项目中以来的配置"><a href="#Maven-项目中以来的配置" class="headerlink" title="Maven 项目中以来的配置"></a>Maven 项目中以来的配置</h2><p>在maven项目中的pom.xml<br>该项目有<br><groupid>com.example</groupid>  //一般是公司名<br><artifactid>project</artifactid>  //一般是项目名<br><version>1.0</version>  </p><p>如果要配置依赖，需要在所有依赖外面先加dependencies，如</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>jdk15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>若配置了依赖，maven install时仍然报错，勾选settings-&gt;buid,execution,deployment中buol tolls下的maven下的runner，勾选嘴上的delegate IDE build/run action to Maven</p><p><img src="/img/posts/config/trust_maven.jpg" alt="Delegate IDE build/run action to Maven"></p><p>记得配置maven的setting file和repository</p><h2 id="配置JSON"><a href="#配置JSON" class="headerlink" title="配置JSON"></a>配置JSON</h2><p>在maven项目中的pom文件中先配置相关依赖</p><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后到java程序中</p><pre class=" language-JAVA"><code class="language-JAVA">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协同过滤推荐算法</title>
      <link href="/2021/12/01/xie-tong-guo-lu-tui-jian-suan-fa/"/>
      <url>/2021/12/01/xie-tong-guo-lu-tui-jian-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>协同过滤(collaborative filtering)算法</p><h2 id="基于内容的推荐系统"><a href="#基于内容的推荐系统" class="headerlink" title="基于内容的推荐系统"></a>基于内容的推荐系统</h2><p><img src="/img/posts/MachineLearning/recommend_system0.jpg" alt="4人对于5门电影的打分表，x1,x2表示电影的特征"></p><p>把每个用户的评分看作一个线性回归问题，对用户评分进行预测，不同的用户与不同的参数$\theta$相关</p><h2 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h2><ul><li>特征学习：可以自动学习所要使用的特征</li></ul><p>用户有一定的特征变量，并且已知用户对部分商品的兴趣</p><p>仍然是这个例子</p><p><img src="/img/posts/MachineLearning/recommend_system1.jpg" alt="现在不知道x1，x2的倾向"></p><p>但是已知用户对于romance和action电影的喜爱度，$\theta^{(1)}$是Alice的特征，由此可知她对于romance电影的喜爱度为5，action的喜爱程度为0，$\theta^{(3)}$是Carol的特征，由此可知她对于romance电影的喜爱度为0，action的喜爱程度为5。</p><p><img src="/img/posts/MachineLearning/recommend_system2.jpg" alt="用户特征"></p><p>由此我们得出，需要满足以下条件：<br>$$(\theta^{(1)})x^{(1)} = 5$$<br>$$(\theta^{(2)})x^{(1)} = 5$$<br>$$(\theta^{(3)})x^{(1)} = 0$$<br>$$(\theta^{(4)})x^{(1)} = 0$$</p><p>所以<br>$$ x^{(1)}  =  \begin{bmatrix}1 &amp; 1.0 &amp; 0.0 \end{bmatrix}$$<br>第一项是截距项</p><h3 id="算法推导过程"><a href="#算法推导过程" class="headerlink" title="算法推导过程"></a>算法推导过程</h3><p>如果用户已经给了我们偏好–特征$\theta^{(1)}$,$\theta^{(2)}$…$\theta^{(n)}$对$x^{(i)}$进行学习，我们要做的是求出：</p><p>$$\min \frac{1}{2} \displaystyle \sum_{j:r(i,j)=1}({(\theta^{(j)})}^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)})^2$$</p><p>这一步要做的是选择一个特征$x^{(i)}$，算法根据所有评价过电影的用户计算出一个值来预测某个用户会如何评价这部电影<br>$\frac {\lambda}{2} \displaystyle \sum_{k=1}^n(x_k^{(i)}$是一个正则项，防止特征值过大</p><p>为了学习所有电影的所有特征，也就是学习$x^{(1)},x^{(2)}…x^{(n_m)}$\，需要求出<br><img src="/img/posts/MachineLearning/recommend_system_equation.jpg"></p><p>$\displaystyle \sum_{i=1}^{n_m}$是对所有电影求和</p><h3 id="算法作用"><a href="#算法作用" class="headerlink" title="算法作用"></a>算法作用</h3><ul><li><p>可以通过用户喜爱程度$\theta^{(1)},\theta^{(2)}…\theta^{(n_u)}$来预测电影的特征$x^{(1)}…x^{(n_m)}$</p></li><li><p>也可以通过电影特征$x^{(1)}…x^{(n_m)}$来预测用户喜爱程度$\theta^{(1)},\theta^{(2)}…\theta^{(n_u)}$</p></li></ul><p>可以通过先随机地选取一些$\theta$地值来学习出不同电影地特征，在得到电影特征之后，再通过这些特征来预测另外的$\theta$值（用户喜爱程度，再根据这些$\theta$来预测电影特征…如此反复，最终将会收敛到一组合理的电影特征以及合理的对用户地预测</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>将$x^{(1)},x^{(2)}…x^{(n_m)}$,$\theta^{(1)},\theta^{(2)}…\theta{(n_u)}$初始化为一些小地随机出</p></li><li><p>使用梯度下降将代价函数最小化，</p></li></ol><p><img src="/img/posts/MachineLearning/recommend_system3.jpg" alt="括号内的内容是对代价函数地偏导"></p><ol start="3"><li>用一些有参数$\theta$的用户和有特征$x$的电影，来预测用户评分$\theta^Tx$</li></ol><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><p>用户对电影评分可以写成如图所示评分矩阵<br><img src="/img/posts/MachineLearning/recommend_system4.jpg"></p><p>该评分矩阵的实质是$\theta^{(j)}*x^{(i)}$</p><p><img src="/img/posts/MachineLearning/recommend_system5.jpg"></p><p>如果要给用户推荐相似的电影，可以通过两个电影之间的距离来判断，如果电影$x^{(i)}$与$x^{(j)}$非常相近，那么可以把$x^{(j)}$推荐给喜欢$x^{(i)}$的人</p><h2 id="协同过滤算法中的均值归一化"><a href="#协同过滤算法中的均值归一化" class="headerlink" title="协同过滤算法中的均值归一化"></a>协同过滤算法中的均值归一化</h2><p>对于没有看过电影的人，或者那些给所有电影都打分为零分的人，很难推荐电影给他们。可以通过已知用户对于电影的打分，计算出该电影的均分，最后生成均分矩阵<br>$$\mu = \begin {bmatrix} \mu_1 &amp; \mu_2 &amp; …&amp; \mu_n \end {bmatrix} $$</p><p><img src="/img/posts/MachineLearning/recommend_system6.jpg" alt="5个电影的评分矩阵如图，但不知道最后一个人对于每个电影的打分"></p><p><img src="/img/posts/MachineLearning/recommend_system7.jpg" alt="通过计算均值，得到了每个电影的均分矩阵"></p><p><img src="/img/posts/MachineLearning/recommend_system8.jpg" alt="原评分矩阵中的元素减去对应的均值后，德奥新的评分矩阵"></p><p>将均一化后的矩阵作为额数据集进行$\theta^{(j)}$参数的学习，预测函数为：<br>$${(\theta^{(j)})}^T{(X^{(i)})}+\mu_i$$</p><p>对于没有打分的用户5<br>$$\theta^{(5)} = \begin {bmatrix}0 &amp; 0 \end {bmatrix}$$</p><p>最终用户5的打分为 $\mu_i$</p><p><strong>可用于解决用户冷启动问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 协同过滤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python实现的PING功能</title>
      <link href="/2021/11/28/ji-yu-python-shi-xian-de-ping-gong-neng/"/>
      <url>/2021/11/28/ji-yu-python-shi-xian-de-ping-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是PING"><a href="#什么是PING" class="headerlink" title="什么是PING"></a>什么是PING</h2><p>ping通常用于测试网络连通，再命令行输入ping 目标主机地址， 得到回复如下：</p><p><img src="/img/posts/Ping/ping_cmd.jpg" alt="ping"></p><p>其中的数据内容如下：</p><p>bytes值：字节数，也就是数据包大小。</p><p>time值：响应时间，这个时间越小，说明连接速度越快。</p><p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p><p>默认情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255。</p><p>因此一般TTL值：</p><p>100~130ms之间，Windows系统 ；</p><p>240~255ms之间，UNIX/Linux系统。</p><h2 id="ping的步骤"><a href="#ping的步骤" class="headerlink" title="ping的步骤"></a>ping的步骤</h2><p>完整代码见：<a href="https://github.com/ClaireYuj/PING-Traceroute/blob/main/ICMPPing.py">PING</a></p><p>解析主机并，进行多次ping操作，输出结果，判断最终结果并输出四个步骤<br>ping的代码如下</p><pre class=" language-Python"><code class="language-Python">def ping(host, timeout=1):    """    do the ping use doOnePing method in a while loop, and show the details    :param host:    :param timeout:    :return:    """    # 1. Look up hostname, resolving it to an IP address    # 2. Call doOnePing function, approximately every second    # 3. Print out the returned delay    # 4. Continue this process until stopped    try:        destinationAddress = socket.gethostbyname(host)    except Exception as e:        print(e)        print(" Error on extract the hostname")        return    print(" Ping {0} [{1}] with 32 bytes of data:".format(host, destinationAddress))    lost = 0    accept = 0    timesum = 0.0    count = 4    times = []    ttl = 0    for i in range(count):        sequence = i        delay, ttl = doOnePing(destinationAddress, timeout)        if delay < 0:            if delay == -1:                print(" %s The request is overtime ...... can not receive the icmpPacket " % delay)                lost += 1                times.append(delay * 1000)            elif delay == -3:                print("3 The destination is unreachable")            elif delay == -11:                print("11 Overtime")            else:                print("%s failed......." %delay)        else:            delay = delay * 1000            print("reply from {0} : byte=32 seq = {1} time={2:.2f}ms ttl = {3} ".format(destinationAddress, sequence, delay, ttl))            accept += 1            timesum += delay            times.append(delay) # all the time        time.sleep(1)    print('packet: send = {0}，received = {1}，loss= {2} ({3}% loss) \n\    Estimated round trip time: min = {4:.2f}ms，max = {5:.2f}ms，average = {6:.2f}ms'.format(        count, accept, lost, lost / (lost + accept) * 100, min(times),        max(times), sum(times) // (lost + accept)    ))</code></pre><h3 id="进行一次ping"><a href="#进行一次ping" class="headerlink" title="进行一次ping"></a>进行一次ping</h3><p>ping命令共输出四次ping的结果，其中一次ping的结果如下</p><pre class=" language-Python"><code class="language-Python">def doOnePing(destinationAddress, timeout):    """    create the ICMP socket, then call the sendOnePing and receiveOnePing method in sequence    :param destinationAddress:    :param timeout:    :return totalDelay, ttl:    """    # 1. Create ICMP socket    icmpSocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.getprotobyname("icmp"))    dataID = os.getpid() & 0xFFFF    # 2. Call sendOnePing function    icmpPacket, sendtime = sendOnePing(icmpSocket, destinationAddress, dataID)    # 3. Call receiveOnePing function    totalDelay, ttl = receiveOnePing(icmpSocket, destinationAddress, dataID, timeout, sendtime)    # 4. Close ICMP socket    icmpSocket.close()    # 5. Return total network delay    return totalDelay, </code></pre><h3 id="发出ping请求"><a href="#发出ping请求" class="headerlink" title="发出ping请求"></a>发出ping请求</h3><p>每次ping需要发出请求以及接收请求两个步骤</p><pre class=" language-Python"><code class="language-Python">  """    build the icmp header, and pack the checksum in header    record the time to send packet    :param icmpSocket:    :param destinationAddress:    :param ID:    :return icmpPacket, sendTime:    """def sendOnePing(icmpSocket, destinationAddress, ID):      # 1. Build ICMP header    ip = socket.gethostbyname(destinationAddress)    icmpChecksum = 0    icmpHeader = struct.pack(">BBHHH", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1) #htons - trans the byte sequence of host nto network byte order    # 2. Checksum ICMP packet using given function    data = struct.pack(">d", time.time())    icmpChecksum = checksum(icmpHeader + data)    # 3. Insert checksum into packet    # icmpHeader = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1)    icmpHeader = struct.pack(">BBHHH", ICMP_ECHO_REQUEST, 0, socket.htons(icmpChecksum), ID, 1) # B-unsigned char h -short    icmpPacket = icmpHeader + data    # 4. Send packet using socket    icmpSocket.sendto(icmpPacket, (ip, 80))    #  5. Record time of sending    sendTime = time.time()    return icmpPacket, sendTime</code></pre><p>checksum是checksum意思是较验和，就是将一段已有长度的数据按照某种整数类型(通常是16位无符号整数)进行累加(进位部分再继续加到低位)，累加后的结果再取反以用于校验。具有校验合的数据包再次进行校验后结果则为0。</p><pre class=" language-Python"><code class="language-Python">def checksum(string):    csum = 0    countTo = (len(string) // 2) * 2    count = 0    while count < countTo:        thisVal = string[count + 1] * 256 + string[count]        csum = csum + thisVal        csum = csum & 0xffffffff        count = count + 2    if countTo < len(string):        csum = csum + string[len(string) - 1]        csum = csum & 0xffffffff    csum = (csum >> 16) + (csum & 0xffff)    csum = csum + (csum >> 16)    answer = ~csum    answer = answer & 0xffff    answer = answer >> 8 | (answer << 8 & 0xff00)    answer = socket.htons(answer)    return answer</code></pre><h3 id="接收ping请求"><a href="#接收ping请求" class="headerlink" title="接收ping请求"></a>接收ping请求</h3><pre class=" language-Python"><code class="language-Python">"""    wait the socket to receive the reply by select.select, calculate the time to receive the packet    :param icmpSocket:    :param destinationAddress:    :param ID:    :param timeout:    :param startTime:    :return delay, ttl:    """def receiveOnePing(icmpSocket, destinationAddress, ID, timeout, startTime):        # 1. Wait for the socket to receive a reply    while True:        what_ready = select.select([icmpSocket], [], [], timeout)        receivedTime = time.time()        # 2. Once received, record time of receipt, otherwise, handle a timeout        if what_ready[0] == []:            return -1, 0        # 3. Compare the time of receipt to time of sending, producing the total network delay        else:            delay = receivedTime - startTime        # 4. Unpack the packet header for useful information, including the ID        recPacket, addr = icmpSocket.recvfrom(1024)        icmpHeader = recPacket[20: 28]        # ip_type, code, checksum, packet_ID, sequence = struct.unpack("<bbHHh", icmpHeader)        icmpType, icmpCode, icmpChecksum, icmpPacketID, icmpSequence = struct.unpack(">BBHHH", icmpHeader)        ipversion, iptype, iplength, ipid, ipflags, ipttl, ipprotocol, ipchecksum, ipsrc_ip, ipdest_ip = struct.unpack(            "!BBHHHBBHII", recPacket[:20])        # 5. Check that the ID matches between the request and reply        if icmpType == ICMP_ECHO_REPLY and icmpPacketID == ID:            # 6. Return total network delay            return delay, ipttl        elif icmpType == ICMP_UNREACHED:            return -3, 0        elif icmpType == ICMP_OVERTIME:            return -11, 0        else:            return -2, 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Idea的SpringBoot项目搭建</title>
      <link href="/2021/11/17/ji-yu-idea-de-springboot-xiang-mu-da-jian/"/>
      <url>/2021/11/17/ji-yu-idea-de-springboot-xiang-mu-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Spring-Boot-Helper插件"><a href="#安装Spring-Boot-Helper插件" class="headerlink" title="安装Spring Boot Helper插件"></a>安装Spring Boot Helper插件</h2><p>File &gt; Settings &gt; Plugins &gt;</p><p>安装好之后File &gt; new &gt; Spring Initializr &gt; 此时注意到选择初始化服务器的defalut那有一个start.spring.io<br>File &gt; Appearance $ Beahavior &gt; System Settings &gt;HTTP Proxy &gt; 选择 Auto-detect后点击左下角的check connection按钮，输入<a href="http://start.spring.io/">http://start.spring.io</a></p><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>版本选择 2.2.6.RELEASE<br>包的名字记得改</p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p>File &gt; Buil, Execution, Deployment &lt; Build Tools &gt; Maven 配置maven的setting.xml于repository， 在maven的安装路径下conf文件夹中找到settings.xml，再在maven根目录新建repository文件夹，并在 setting.xml 文件中添加（找到repository注释下一行，进行添加）</p><pre class=" language-XML"><code class="language-XML">    <localRepository>        D:\Environment\Maven\apache-maven-3.2.5\store        </localRepository></code></pre><p>此处地址为自己创建的repository的地址</p><p>再找到mirror<br>将原代码更换为</p><pre class=" language-XML"><code class="language-XML">    <mirror>        <id>alimaven</id>        <name>aliyun maven</name>        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>        <mirrorOf>central</mirrorOf>               </mirror> </code></pre><p>再重新生成maven项目，拉开idea右侧maven栏，点击左上角刷新按钮</p><h3 id="报错java-程序包org-springframework-boot不存在"><a href="#报错java-程序包org-springframework-boot不存在" class="headerlink" title="报错java: 程序包org.springframework.boot不存在"></a>报错java: 程序包org.springframework.boot不存在</h3><p>是依赖库仓库出现问题，cd到该项目目录下，mvn idea:idea 重新安装依赖即可</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA输入输出</title>
      <link href="/2021/11/17/java-shu-ru-shu-chu/"/>
      <url>/2021/11/17/java-shu-ru-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-I-x2F-O"><a href="#JAVA-I-x2F-O" class="headerlink" title="JAVA I/O"></a>JAVA I/O</h1><p>在Java程序中要读取外部IO设备中的内容，要求先将数据传输到内存中，这一步需要借助操作系统实现。<br>JDK中提供的IO操作框架，根据流的传输方向和读取单位分为字节流InputStream和outputSteam以及字符流Reader和Writer</p><p>字节流一次<strong>读取一个字节</strong>（1 byte）<br>字符流一次<strong>读取一个字符</strong>（1 char =  2 byte）</p><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><p>头文件</p><pre class=" language-Java"><code class="language-Java">import java.io.FileInputStream;import java.io.FileNotFoundException;</code></pre><h3 id="创建输入流"><a href="#创建输入流" class="headerlink" title="创建输入流"></a>创建输入流</h3><pre class=" language-Java"><code class="language-Java">try{    FileInputStream inputStream = new FileInputStream("test.txt"); }catch(FileNotFoundException e){    e.printStackTrace();}</code></pre><p>在使用完成后，要关闭流进行资源释放，在catch后加入finally</p><pre class=" language-Java"><code class="language-Java">        FileInputStream inputStream = null;        try{            inputStream = new FileInputStream("test.txt");        }catch (FileNotFoundException e){            e.printStackTrace();        }finally {            try{                if(inputStream !=null) inputStream.close();            }catch (IOException e){                e.printStackTrace();            }        }</code></pre><p><strong>但这样过于繁琐，尝试以下面方式进行简化</strong></p><pre class=" language-Java"><code class="language-Java">    try(FileInputStream inputStream  = new FileInputStream("test.txt")){                }catch (FileNotFoundException e){            e.printStackTrace();    }</code></pre><p>将inputStream的初始化放到的括号中且不报错，原因是InputStream这个抽象类使用了Closeable的接口<br>而Closeable接口继承了AutoCloseable，如果一个对象是在try-with-resource(在JDK7中引入，JDK9中改进)代码块中生命的，则AutoCloseable的对象的close()方法会自动执行<br>字节流，字符流等都可以直接使用</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>inputStream.read() 一次读取一个英文字母（读的是ASCII码，需要char转换）</p><p>一次性全部读完</p><pre class=" language-Java"><code class="language-Java">try( FileInputStream inputStream = new FileInputStream("test.txt")){            int tmp;            while((tmp = inputStream.read()) != -1){                System.out.println((char)tmp);            }        }catch (IOException e){            e.printStackTrace();        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口协议</title>
      <link href="/2021/11/11/hua-dong-chuang-kou-xie-yi/"/>
      <url>/2021/11/11/hua-dong-chuang-kou-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><ul><li><p>是<strong>TCP协议</strong>的一种，用于数据传输时的流量控制，避免拥塞的发送。  </p></li><li><p>滑动窗口协议允许发送方在在收到确认之前发送多个数据分组，因此<strong>发送方不必没收到一个分组就停下来等待确认</strong>，因此该协议可以加速数据的传输，提高网络吞吐量。</p></li><li><p>如果多个客户端向服务器发送到大量数据包，但服务器没有足够的接收这么多数据包的能力，那么会导致拥塞的发生。因此我们需要控制发送方的发送速度，控制它不要发送过快。</p></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><p>窗口：允许使用的序列号范围</p><ul><li>窗口尺寸： 若窗口尺寸为n，意味着最多有n个等待确认的消息</li></ul></li><li><p>滑动窗口： 随着协议的运行，窗口在序列号范围内向前移动  </p></li><li><p>滑动窗口协议： GBN，SR</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据传输 </tag>
            
            <tag> 流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode--树相关</title>
      <link href="/2021/10/17/leetcode-shu-xiang-guan/"/>
      <url>/2021/10/17/leetcode-shu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="树的特征"><a href="#树的特征" class="headerlink" title="树的特征"></a>树的特征</h2><p>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一颗树。图的生成树森林是它的所有连通子图的生成树的集合。</p><p>有多个子节点，层层递归（一般是二叉树）<br>二叉树的定义如下</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> val<span class="token punctuation">;</span>     TreeNode left<span class="token punctuation">;</span>     TreeNode right<span class="token punctuation">;</span>     <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="剑指Offer25-树的子结构"><a href="#剑指Offer25-树的子结构" class="headerlink" title="剑指Offer25. 树的子结构"></a>剑指Offer25. 树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br><img src="/img/posts/Leetcode/offer26.jpg"><br>前序遍历，从A树和B树相同的结点开始，B树的左子树 = A树的左子树；A树的右子树 = B树的右子树<br>结束条件==》B树符合A树左子树条件||A树 = null</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>TreeNode A<span class="token punctuation">,</span> TreeNode B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token operator">==</span>null<span class="token operator">||</span>B<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从该节点开始遍历||判断从A的左节点开始遍历，B是不是A的左子树的子结构|| 判断B是不是A的右子树的子结构</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode A<span class="token punctuation">,</span> TreeNode B<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>B <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示在B为null前A与B 的val一直相等</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>A <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> B <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>val <span class="token operator">!=</span> B<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span> B<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">travel</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span> B<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分辨遍历左右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Offer27-二叉树的镜像"><a href="#Offer27-二叉树的镜像" class="headerlink" title="Offer27.二叉树的镜像"></a>Offer27.二叉树的镜像</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">请完成一个函数，输入一个二叉树，该函数输出它的镜像</a><br><img src="/img/posts/Leetcode/offer27.jpg"></p><ul><li>思路： 从根的叶结点开始， 一个一个交换左右子树，一直到为null</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Offer28-对称的二叉树"><a href="#Offer28-对称的二叉树" class="headerlink" title="Offer28.对称的二叉树"></a>Offer28.对称的二叉树</h2><p><img src="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d412v/"><br>依旧是递归，不过考虑到判断对称，要求：<br>左子树的左子树等于右子树的右子树，右子树的左子树=左子树的右子树，依次递归</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        TreeNode left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        TreeNode right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>right<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>right<span class="token punctuation">.</span>val<span class="token operator">==</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode left<span class="token punctuation">,</span> TreeNode right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>null<span class="token operator">&amp;&amp;</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>right<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>left<span class="token punctuation">.</span>val<span class="token operator">!=</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>null<span class="token operator">||</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">travel</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">travel</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>left<span class="token punctuation">,</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p><img src="/img/posts/Leetcode/leetcode94.jpg" alt="Leetcode94"></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>中序遍历 左-&gt;中-右</p><pre class=" language-jAVA"><code class="language-jAVA">class Solution {    public List<Integer> inorderTraversal(TreeNode root) {        List<Integer> tree = new ArrayList<Integer>();        inOrder(root,tree);        return tree;            }    public void inOrder(TreeNode root,List<Integer> tree){        if(root==null){            return;        }        inOrder(root.left,tree);        tree.add(root.val);        inOrder(root.right,tree);    }}</code></pre><h2 id="Offer22-广度优先算法"><a href="#Offer22-广度优先算法" class="headerlink" title="Offer22. 广度优先算法"></a>Offer22. 广度优先算法</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9ackoe/">从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> Definition <span class="token keyword">for</span> a binary tree node<span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span> <span class="token operator">*</span>     <span class="token keyword">int</span> val<span class="token punctuation">;</span> <span class="token operator">*</span>     TreeNode left<span class="token punctuation">;</span> <span class="token operator">*</span>     TreeNode right<span class="token punctuation">;</span> <span class="token operator">*</span>     <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">*</span> <span class="token punctuation">}</span> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">bfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 广度优先要用queue</span>        <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用来确定int[] arr的大小</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先将root入队列</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode treeNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将根节点出列</span>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 两个if实现了广度有限中将同层次的叶节点加入队列</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="95-不同的二叉搜索树"><a href="#95-不同的二叉搜索树" class="headerlink" title="95.不同的二叉搜索树"></a>95.不同的二叉搜索树</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br>（不只返回数字）</p><h3 id="解法一-DFS-深度优先"><a href="#解法一-DFS-深度优先" class="headerlink" title="解法一:DFS 深度优先"></a>解法一:DFS 深度优先</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h3 id="解法二：DP-动态规划"><a href="#解法二：DP-动态规划" class="headerlink" title="解法二：DP 动态规划"></a>解法二：DP 动态规划</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int numTrees(int n) {        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;                for(int i = 2; i < n + 1; i++)            for(int j = 1; j < i + 1; j++)                 dp[i] += dp[j-1] * dp[i-j];                return dp[n];    }}</code></pre><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    //判断无向图是否有换，以及是否为单连通分量    //当只有n-1条边，且连通数为1时，符合条件    public boolean validTree(int n, int[][] edges) {        if(edges.length+1 != n) //只应该有n-1条边            return false;        int[] par = new int[n];        int par1 = 0,par2 = 0;        for(int i=0;i<n;i++)            par[i]=i; //并查集，每个点的父节点是自己        for(int i=0;i<edges.length;i++){            par1 = edges[i][0];            par2 = edges[i][1];            //不断向上寻找得到par1和par2的祖先节点            while(par1 != par[par1])                par1 = par[par1];             while(par2 != par[par2])                par2 = par[par2];            //par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--            if(par1 != par2){                par[par2] = par1;                n--;            }        }        return n == 1;            }}</code></pre><h2 id="515-在二叉树的每一行中找到最大的值。"><a href="#515-在二叉树的每一行中找到最大的值。" class="headerlink" title="515. 在二叉树的每一行中找到最大的值。"></a>515. 在二叉树的每一行中找到最大的值。</h2><h3 id="解法：BFS-广度优先"><a href="#解法：BFS-广度优先" class="headerlink" title="解法：BFS 广度优先"></a>解法：BFS 广度优先</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List<Integer> largestValues(TreeNode root) {        List<Integer> rlist = new ArrayList<>();        if(root==null) return rlist;                List<TreeNode> nodeList = new LinkedList<>();        nodeList.add(root);        while(!nodeList.isEmpty()){            int size = nodeList.size();            int max = nodeList.get(0).val;            for(int i = 0;i< size;i++){                TreeNode node = nodeList.remove(0);                max = Math.max(node.val,max);                if(node.left!=null) nodeList.add(node.left);                if(node.right!=null) nodeList.add(node.right);            }            rlist.add(max);        }        return rlist;            }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA常见容器</title>
      <link href="/2021/10/14/java-chang-jian-rong-qi/"/>
      <url>/2021/10/14/java-chang-jian-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterable被Collection所继承。它只有一个方法： Iterator<t> iterator() </t></p><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为<strong>“轻量级”</strong>对象，因为创建它的代价小。</p><p>Java中的Iterator功能比较简单，并且只能单向移动：<br>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br>　　(2) 使用next()获得序列中的下一个元素。<br>　　(3) 使用hasNext()检查序列中是否还有元素。<br>　　(4) 使用remove()将迭代器新返回的元素删除。</p><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>一般不会直接实现collection接口，而是实现它的子类</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><em><strong>有序的，可重复的</strong></em><br>List是有序的 collection子接口。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>用户插入的顺序或者指定的位置就是元素插入的位置。它与Set不同，List允许插入重复的值。</p><p>List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法(如下)来获取从列表中指定位置开始的列表迭代器。</p><p>ListIterator <e> listIterator(int index)<br>返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始</e></p><p>List 接口提供了两种搜索指定对象的方法。从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。</p><p>List 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><em><strong>无序的，不可重复的</strong></em></p><p>java的集合和数学的集合一样，集合的无序性，确定性，单一性。所以可以很好的理解，Set是无序、不可重复的。同时，如果有多个null，则不满足单一性了，Set只能有一个null。<br>Set判断两个对象相同不是使用”==”运算符，<strong>而是根据equals方法</strong>。——因为Set的这个制约，在使用Set集合的时候，应该注意两点：<br>为Set集合里的元素的实现类实现一个有效的equals(Object)方法；<br>对Set的构造函数，传入的Collection参数不能包含重复的元素。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><em><strong>有序的，可重复的</strong></em><br>用于模拟“队列”数据结构（FIFO）。新插入的元素放在队尾，队头存放着保存时间最长的元素。</p><p>Queue的子类、子接口<br>1.1） PriorityQueue—— 优先队列（类）<br>其实它并没有按照插入的顺序来存放元素，而是按照队列中某个属性的大小来排列的。故而叫优先队列。</p><p>1.2） Deque——双端队列（接口）<br>1.2.1）ArrayDeque（类）<br>基于数组的双端队列，类似于ArrayList有一个Object[] 数组。<br>1.2.2）LinkedList （类）</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map不是collection的子接口或者实现类，Map是一个接口。</p><p>Map用于保存具有“映射关系”的数据。每个Entry都持有<strong>键-值</strong>两个对象。其中，Value可能重复，但是Key不允许重复（和Set类似）。</p><p>Map可以有多个Value为null，但是只能有一个Key为null</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在hexo的matery主题下显示数学公式</title>
      <link href="/2021/09/29/zai-hexo-de-matery-zhu-ti-xia-xian-shi-shu-xue-gong-shi/"/>
      <url>/2021/09/29/zai-hexo-de-matery-zhu-ti-xia-xian-shi-shu-xue-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>Markdown中激活mathjax插件，并使用数学公式，如矩阵与各种数学符号</p><h2 id="激活mathjax插件"><a href="#激活mathjax插件" class="headerlink" title="激活mathjax插件"></a>激活mathjax插件</h2><p>主题config.yml文件里找到mathjax,改为true<br>由于mathjax的渲染时间较长，故勾选全局mathjax为true后还需要在每篇文章的最上方输入mathjax:true</p><p>此时就可以输入数学公式了，以矩阵为例</p><p>输入</p><pre class=" language-Latex"><code class="language-Latex">$$\begin{bmatrix}                     1&1&0\\                                     1&0&1\\        \end{bmatrix}$$</code></pre><p>以$$\begin开始,以\end{}$$结束<br>但由于matery主题的限制，矩阵不会换行，因此考虑使用markdown it Plus代替Marked渲染器</p><h2 id="利用Katex"><a href="#利用Katex" class="headerlink" title="利用Katex"></a>利用Katex</h2><pre class=" language-shell"><code class="language-shell">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save</code></pre><p>卸载marked，安装markdown-it-plus</p><pre class=" language-shell"><code class="language-shell">npm un hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save</code></pre><p>也可以考虑吧直接用升级版</p><p>再修改hexo的config.yml文件</p><pre class=" language-yml"><code class="language-yml">markdown_it_plus:  render:    html: true    xhtmlOut: false    breaks: true    linkify: true    typographer: true    quotes: '“”‘’'  plugins:  anchors:    level: 2    collisionSuffix: 'v'    permalink: true    permalinkClass: header-anchor    permalinkSide: 'left'    permalinkSymbol: ¶</code></pre><p>就完成了配置<br>可以用</p><pre class=" language-Latex"><code class="language-Latex">$$\begin{bmatrix}                     1&1&0\\                                     1&0&1\\        \end{bmatrix}$$</code></pre><p>再测试一下，此时的matrix会分行了</p><h2 id="Markdown数学公式的使用"><a href="#Markdown数学公式的使用" class="headerlink" title="Markdown数学公式的使用"></a>Markdown数学公式的使用</h2><h3 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{equation}公式\\公式\\\end{equation}$$</code></pre><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p><strong>^</strong>表示上标，**_<strong>表示下标，需要用</strong>{}** </p><pre class=" language-Latex"><code class="language-Latex">$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</code></pre><p>结果<br><img src="/img/posts/Markdown/index.jpg" alt="结果"></p><h3 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{matrix}0&1&1\\1&1&0\\1&0&1\\\end{matrix}$$</code></pre><p><img src="/img/posts/Markdown/matrix0.jpg" alt="矩阵表示"></p><p>在起始、结束标记用下列词替换 matrix</p><ul><li>pmatrix：小括号边框</li><li>bmatrix：中括号边框</li><li>Bmatrix：大括号边框</li><li>vmatrix：单竖线边框</li><li>Vmatrix：双竖线边框</li></ul><p><img src="/img/posts/Markdown/matrix1.jpg" alt="边框矩阵表示"></p><h3 id="方程组表示"><a href="#方程组表示" class="headerlink" title="方程组表示"></a>方程组表示</h3><pre class=" language-Latex"><code class="language-Latex">$$\begin{cases}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\\\end{cases}$$</code></pre><p><img src="/img/posts/Markdown/equation0.jpg" alt="方程组表示"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-栈相关</title>
      <link href="/2021/09/09/leetcode-zhan-xiang-guan/"/>
      <url>/2021/09/09/leetcode-zhan-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>栈在JAVA中，可以用LinkedList来表示</p><p>LinkedList<integer> A = new LinkedList<integer>(); </integer></integer></p><ul><li>栈中加入元素<br>  A.add(a);</li><li>栈中移除元素<br>  A.removeLast();</li></ul><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d3i87/">https://leetcode.cn/leetbook/read/illustration-of-algorithm/5d3i87/</a></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )</p><p><img src="/img/posts/Leetcode/offer09.jpg" alt="剑指offer09"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */</span><span class="token keyword">class</span> <span class="token class-name">CQueue</span> <span class="token punctuation">{</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> A<span class="token punctuation">;</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> B<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        B <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">appendTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        A<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>B<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> B<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            B<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> B<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-链表相关</title>
      <link href="/2021/08/28/leetcode-lian-biao-xiang-guan/"/>
      <url>/2021/08/28/leetcode-lian-biao-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9pdjbm/">剑指Offer24.反转链表</a></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>如：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h3 id="解法一，头插：用一个节点暂存"><a href="#解法一，头插：用一个节点暂存" class="headerlink" title="解法一，头插：用一个节点暂存"></a>解法一，头插：用一个节点暂存</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode reve <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode tmp <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp<span class="token punctuation">.</span>next <span class="token operator">=</span> reve<span class="token punctuation">;</span>            reve <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> reve<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListNode <span class="token function">recur</span><span class="token punctuation">(</span>ListNode cur<span class="token punctuation">,</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//递归终止条件，所以最后返回的是cur</span>        ListNode res <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="赋值带随机指针的链表"><a href="#赋值带随机指针的链表" class="headerlink" title="赋值带随机指针的链表"></a>赋值带随机指针的链表</h2><p><img src="/img/posts/Leetcode/leetcode138.jpg" alt="Leetcode138"></p><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/9plk45/">解法</a></p><h3 id="解法一：拼接-拆分"><a href="#解法一：拼接-拆分" class="headerlink" title="解法一：拼接+拆分"></a>解法一：拼接+拆分</h3><p>将原链表假设为1-&gt;2-&gt;3复制<br>1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null<br>这样cur-&gt;random-&gt;next = cur-&gt;next-&gt;random<br>比如如果1-&gt;random = 3,那么1-&gt;random = 3, 3-&gt;next = 3 ===&gt;1-&gt;random-&gt;next = 3, 且1-&gt;next = 1, 1-&gt;random = 3 ===&gt; 1-&gt;next-&gt;random = 3, 所以cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*// Definition for a Node.class Node {    int val;    Node next;    Node random;    public Node(int val) {        this.val = val;        this.next = null;        this.random = null;    }}*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Node <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        Node cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        Node p <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//1. 复制节点并拼接</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>             Node copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//复制该节点</span>            copy<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//连接copy节点的next</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> copy<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关联该节点与复制节点</span>            cur <span class="token operator">=</span> copy<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//移动指针</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2.构建random,使得cur->random->next = cur->next->random</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// java中对象传递是引用传递</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>random<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>random <span class="token operator">=</span> cur<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next<span class="token punctuation">;</span>              <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 3. 将random拆出来</span>        cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Node pre <span class="token operator">=</span> head<span class="token punctuation">,</span>res<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/**注意pre和cur节点的顺序， pre要在cur之前，             */</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>             cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                             <span class="token punctuation">}</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维护博客所遇到的问题汇总</title>
      <link href="/2021/08/18/wei-hu-bo-ke-suo-yu-dao-de-wen-ti-hui-zong/"/>
      <url>/2021/08/18/wei-hu-bo-ke-suo-yu-dao-de-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="链接到本地图片"><a href="#链接到本地图片" class="headerlink" title="链接到本地图片"></a>链接到本地图片</h2><p>在source下创建img文件夹，每次引用都是/img…</p><h2 id="上传图片加载不出来，但在本地预览可以显示"><a href="#上传图片加载不出来，但在本地预览可以显示" class="headerlink" title="上传图片加载不出来，但在本地预览可以显示"></a>上传图片加载不出来，但在本地预览可以显示</h2><p>图片格式最好选用jpg而不是png</p><h2 id="无法解析XML和HTML语言"><a href="#无法解析XML和HTML语言" class="headerlink" title="无法解析XML和HTML语言"></a>无法解析XML和HTML语言</h2><p>尚未完全解决，实在不行就不标明那一段是个代码段，直接放代码</p><h2 id="首页博客排序方式"><a href="#首页博客排序方式" class="headerlink" title="首页博客排序方式"></a>首页博客排序方式</h2><p>项目下（不是主题下）_config.yml中index_generate:order_by: (+/-)(title/date)<br>+表示正序排列<br>-表示倒序排列</p><h2 id="ssh相关"><a href="#ssh相关" class="headerlink" title="ssh相关"></a>ssh相关</h2><p>ssh密钥一般存在/user/.ssh/目录下<br>如果没有配置ssh密钥，可以通过</p><pre class=" language-cmd"><code class="language-cmd">cd /.ssh</code></pre><p>创建ssh key</p><pre class=" language-cmd"><code class="language-cmd">ssh-keygen -t rsa -C "邮件地址"</code></pre><p>复制console生成的密钥，把他粘贴到.ssh目录下的 id_rsa.pub</p><p>在github的ssh设置中，添加ssh key，粘贴刚刚复制的内容</p><p>通过</p><pre class=" language-cmd"><code class="language-cmd">ssh -T git@github.com</code></pre><p>检查是否配置成功，如果hexo g -d显示连接有问题，可以进bash查看一下ssh -T <a href="mailto:git@github.com">git@github.com</a></p><p>windows系统可以，连接ssh-agent</p><pre class=" language-bash"><code class="language-bash"><span class="token function">eval</span> <span class="token variable"><span class="token variable">$(</span>ssh-agent<span class="token variable">)</span></span></code></pre><p>之后在ssh-agent中添加自己的key</p><pre class=" language-bash"><code class="language-bash">ssh-add ~/.ssh/id_rsa</code></pre><h2 id="git报错-–-Connection-reset-by-server-ip-port-22"><a href="#git报错-–-Connection-reset-by-server-ip-port-22" class="headerlink" title="git报错 – Connection reset by [server_ip] port 22"></a>git报错 – Connection reset by [server_ip] port 22</h2><p>解决git报错 – Connection reset by [server_ip] port 22<br>第一种情况，自己防火墙设置了22端口跳转</p><pre><code>解决方法    打开windows防火墙，选择高级设置    新建入站规则，    选择端口    新建特定端口，22    保存就ok了</code></pre><h2 id="代码块中-被转义"><a href="#代码块中-被转义" class="headerlink" title="代码块中{}被转义"></a>代码块中{}被转义</h2><p> 在node_modules\hexo-prism-plugin\src\index.js中添加</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token string">'&amp;#39;'</span><span class="token punctuation">:</span> <span class="token string">'\''</span><span class="token punctuation">,</span>  <span class="token string">'&amp;amp;'</span><span class="token punctuation">:</span> <span class="token string">'&amp;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;gt;'</span><span class="token punctuation">:</span> <span class="token string">'>'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;lt;'</span><span class="token punctuation">:</span> <span class="token string">'&lt;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;quot;'</span><span class="token punctuation">:</span> <span class="token string">'"'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#123;'</span><span class="token punctuation">:</span> <span class="token string">'{'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#125;'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-图论</title>
      <link href="/2021/08/17/leetcode-tu-lun/"/>
      <url>/2021/08/17/leetcode-tu-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><p>定义：<strong>无向图是由一组顶点（vertex）和一组能够将两个顶点相连的边（edge）组成的</strong><br>在无向图中，允许出现1.自环，即一条连接一个顶点和其自身的边，2. 连接同一对顶点的两条边称为平行边</p><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261. 以图判树"></a>261. 以图判树</h2><p>给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。</p><p><img src="/img/posts/Leetcode/leetcode261.jpg" alt="Leetcode261图示"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//判断无向图是否有换，以及是否为单连通分量</span>        <span class="token comment" spellcheck="true">//当只有n-1条边，且连通数为1时，符合条件</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只应该有n-1条边</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> par <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> par1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>par2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                par<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//并查集，每个点的父节点是自己</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                par1 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                par2 <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*不断向上寻找得到par1和par2的祖先节点*/</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">)</span>                    par1 <span class="token operator">=</span> par<span class="token punctuation">[</span>par1<span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token keyword">while</span><span class="token punctuation">(</span>par2 <span class="token operator">!=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">)</span>                    par2 <span class="token operator">=</span> par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*par2和par1不属于一个并查集，将par2并入par1，此时并查集个数n--*/</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>par1 <span class="token operator">!=</span> par2<span class="token punctuation">)</span><span class="token punctuation">{</span>                    par<span class="token punctuation">[</span>par2<span class="token punctuation">]</span> <span class="token operator">=</span> par1<span class="token punctuation">;</span>                    n<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="323-无向图中连通分量的数目"><a href="#323-无向图中连通分量的数目" class="headerlink" title="323. 无向图中连通分量的数目"></a>323. 无向图中连通分量的数目</h2><p>你有一个包含&nbsp;n 个节点的图。给定一个整数 n 和一个数组&nbsp;edges&nbsp;，其中&nbsp;edges[i] = [ai, bi]&nbsp;表示图中&nbsp;ai&nbsp;和&nbsp;bi&nbsp;之间有一条边。</p><p><img src="/img/posts/Leetcode/leetcode323.jpg" alt="Leetcode323图示"></p><h3 id="c-vector容器进行DFS-深度优先"><a href="#c-vector容器进行DFS-深度优先" class="headerlink" title="c++ vector容器进行DFS 深度优先"></a>c++ vector容器进行DFS 深度优先</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    int countComponents(int n, vector<vector<int>>& edges) {        vector<int>a(n, 0);        vector<vector<int>>arr(n, a);        for (auto it : edges) {            arr[it[0]][it[1]] = 1;            arr[it[1]][it[0]] = 1;        }        int res = 0;        vector<int>mark(n, 0);        for (int i = 0; i < n; i++) {            if (mark[i] == 0) {                DFS(arr, mark, i);                res++;            }        }        return res;            }private:    void DFS(vector<vector<int>>&arr, vector<int>& mark,int b) {            mark[b] = 1;            for (int i = 0; i < arr.size(); i++) {                if (arr[i][b] == 1&&mark[i] == 0) {                    DFS(arr, mark,i);                }            }            mark[b] = 2;    }};</code></pre><h3 id="java-二维数组进行dfs"><a href="#java-二维数组进行dfs" class="headerlink" title="java 二维数组进行dfs"></a>java 二维数组进行dfs</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countComponents</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> mark<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> map<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有n个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p><img src="/img/posts/Leetcode/leetcode547.jpg" alt="Leetcode547"></p><h3 id="解法：DFS-深度优先"><a href="#解法：DFS-深度优先" class="headerlink" title="解法：DFS 深度优先"></a>解法：DFS 深度优先</h3><p>关键在于：无向图最小连通数：并查集</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> N <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>i<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> si<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>        mark<span class="token punctuation">[</span>si<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span>mark<span class="token punctuation">,</span>j<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求最大子集和</title>
      <link href="/2021/08/15/zui-da-zi-ji-he/"/>
      <url>/2021/08/15/zui-da-zi-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="求最大子集和"><a href="#求最大子集和" class="headerlink" title="求最大子集和"></a>求最大子集和</h2><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><h4 id="法一-暴力"><a href="#法一-暴力" class="headerlink" title="法一 暴力"></a>法一 暴力</h4><pre class=" language-c++"><code class="language-c++">class Solution {    public int numTrees(int n) {        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;                for(int i = 2; i < n + 1; i++)            for(int j = 1; j < i + 1; j++)                 dp[i] += dp[j-1] * dp[i-j];                return dp[n];    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习学习笔记1</title>
      <link href="/2021/08/05/shen-du-xue-xi-xue-xi-bi-ji-1/"/>
      <url>/2021/08/05/shen-du-xue-xi-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于深度学习"><a href="#关于深度学习" class="headerlink" title="关于深度学习"></a>关于深度学习</h2><p>深度学习是通过多层来获得更为抽象的特征表达，如果有一个n层(S1,S2,S3…Sn)的深度学习系统, 输入为I，输出是O，那么深度学习的过程可以抽象的表示为: I =&gt;S1=&gt;S2=&gt;S3=&gt;…=&gt;O，每一层的信息处理都会丢失部分信息，最后的O很难是初始的I，<strong>但是如果我们可以通过深度学习调节系统中的参数使得它的输出仍然是I那么我们就可以自动的获取输入I的一系列层次特征，即S1，S2…Sn</strong></p><p><img src="/img/posts/MachineLearning/Mindmap.jpg" alt="神经网络与深度学习结构(图片选自《神经网络与深度学习》一邱锡鹏"></p><p><a href="https://blog.csdn.net/qq_36816848/article/details/122286610?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166244950816782391845436%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166244950816782391845436&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-122286610-null-null.142%5Ev46%5Epc_rank_34_2&amp;utm_term=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&amp;spm=1018.2226.3001.4187">参考学习</a></p><h3 id="浅层学习"><a href="#浅层学习" class="headerlink" title="浅层学习"></a>浅层学习</h3><p>是只含有一层隐层节点/没有节点的浅层模型，如支持向量机、最大熵方法（逻辑回归）、多层感知机等</p><p><img src="/img/posts/MachineLearning/perceptron.jpg" alt="感知机perceptron"></p><p><img src="/img/posts/MachineLearning/simple_perceptron.jpg" alt="简单感知机"></p><p><img src="/img/posts/MachineLearning/multi_layel_perceptron.jpg" alt="多层感知机"></p><p>利用人工神经网络的反向传播算法（Back Propagation算法或者BP算法），让一个人工神经网络模型从大量训练样本中学习统计规律，从而对未知事件做预测。</p><ul><li>前向传播与反向传播：前向传播（foward propagation）作用于<strong>每一层的输入</strong>，通过逐层计算得到输出结果；反向传播（backward propagation）作用于网络的<strong>输出</strong>，通过计算<strong>梯度</strong>由<strong>深</strong>到<strong>浅</strong>更新网络参数。</li></ul><p>由于我们前向传播最终得到的结果，以分类为例，最终总是有误差的，可以通过<strong>梯度下降算法</strong>减少误差。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习的实质，是通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习更有用的特征，从而最终提升分类或预测的准确性。<strong>通过深度学习最终达到特征学习的目标</strong></p><p>在深度学习中，明确突出了特征学习的重要性，通过<strong>逐层特征变换</strong>，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。</p><h2 id="深度学习与神经网络"><a href="#深度学习与神经网络" class="headerlink" title="深度学习与神经网络"></a>深度学习与神经网络</h2><p><img src="/img/posts/MachineLearning/neutral_network.jpg" alt="神经网络的结构"></p><p><img src="/img/posts/MachineLearning/model_nw.jpg" alt="神经网络的主要模型"></p><p>深度学习采用了神经网络相似的分层结构，系统由包括输入层、隐层（多层）、输出层组成的多层网络，只有相邻层节点之间有连接，同一层以及跨层节点之间相互无连接，每一层可以看作是一个<strong>逻辑回归</strong>模型。</p><p>但DL与传统神经网络的区别在于，传统神经网络中，采用的是反向传播的方式进行，也就是采用迭代的算法来训练整个网络，随机设定初值，计算当前网络的输出，然后根据当前输出和label之间的差去改变前面各层的参数，直到收敛（整体是一个梯度下降法）。而DL整体上是一个layer-wise的训练机制。这样做的原因是因为，如果采用b反向传播的机制，对于一个深层网络（7层以上），残差传播到最前面的层已经变得太小，便会出现梯度扩散(gradient diffusion)。因此传统的BP算法不能用在深度神经网络。</p><ul><li>BP算法用于深度学习会出现的问题：</li></ul><ol><li>梯度越来越稀疏，偏差原来越小，可能出现过拟合</li><li>由于随机初始值，最终收敛到局部最小</li><li>只能通过有标签的数据集进行训练，不能学习无标签的数据集，也就是监督学习</li></ol><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/8775518">参考博客</a></p><p>如果对所有层同时训练，时间复杂度会太高；如果每次训练一层，偏差就会逐层传递。这会面临跟上面监督学习中相反的问题，会严重欠拟合（因为深度网络的神经元和参数太多了）。</p><p>简单来说分为两步：</p><p>1）首先逐层构建单层神经元，这样每次都是训练一个单层网络。</p><p>2）当所有层训练完后，使用wake-sleep算法进行调优。</p><p>Wake-Sleep算法分为醒（wake）和睡（sleep）两个部分。</p><p>1）wake阶段：认知过程，通过外界的特征和向上的权重（认知权重）产生每一层的抽象表示（结点状态），并且使用梯度下降修改层间的下行权重（生成权重）。也就是“如果现实跟我想象的不一样，改变我的权重使得我想象的东西就是这样的”。</p><p>2）sleep阶段：生成过程，通过顶层表示（醒时学得的概念）和向下权重，生成底层的状态，同时修改层间向上的权重。也就是“如果梦中的景象不是我脑中的相应概念，改变我的认知权重使得这种景象在我看来就是这个概念”。</p><h4 id="使用自下而上的非监督学习"><a href="#使用自下而上的非监督学习" class="headerlink" title="使用自下而上的非监督学习"></a>使用自下而上的非监督学习</h4><p>采用无标定数据（有标定数据也可）分层训练各层参数（可以看作无监督训练过程–也是特征学习的过程）</p><ol><li>首先用无标定数据训练第一层，训练时先学习第一层的参数，可以将这一步看作一个使得输出如输出差异化的最小神经网络的隐层</li><li>一次学习没在学习到低n层时，将低n层的输出作为第n+1层的输入来训练第n+1层，以此得到每一层的参数</li></ol><h4 id="采用自顶而下的监督学习"><a href="#采用自顶而下的监督学习" class="headerlink" title="采用自顶而下的监督学习"></a>采用自顶而下的监督学习</h4><p>通过有标签的数据去训练，将误差自顶而下传输，堆网络进行微调</p><p>基于第一步各层参数进一步微调整个模型的参数，由于DL的第一步不是随机初始化，而是通过学习输入数据的结构得到的，因而这个初值更接近全局最优，从而能够取得更好的效果；所以DL效果好很大程度上归功于第一步自下而上非监督学习中的特征学习过程。</p><h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p>超参数是在<strong>开始学习过程之前设置值的参数</strong>，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。具体来讲比如算法中的学习率、梯度下降法迭代的数量、隐藏层数目、隐藏层单元数目、激活函数都需要根据实际情况来设置，这些参数实际上控制了最后的参数和的值，所以它们被称作超参数。</p><p>因此，寻求超参数的最优值是十分重要的，常见的设置超参数的方法有</p><ol><li>随机搜索：让计算机随机挑选以阻止</li><li>贝叶斯优化：使用贝叶斯优化超参数，但贝叶斯算法本身就有很多困难。</li><li>MITIE方法：先进性局部优化，利于寻找局部最优解。</li></ol><p><strong>超参数搜索的一般过程是</strong></p><ol><li>将数据集划分成训练集、验证集及测试集。</li><li>在训练集上根据模型的性能指标对模型参数进行优化。</li><li>在验证集上根据模型的性能指标对模型的超参数进行搜索</li><li>步骤 2 和步骤 3 交替迭代，最终确定模型的参数和超参数，在测试集中验证评价模型的优劣</li></ol><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>激活函数将非线性特性引入到网络中，在神经网络的神经元中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数。激活函数是为了增加神经网络模型的<strong>非线性</strong>。<strong>没有激活函数的每层都相当于矩阵相乘。就算你叠加了若干层之后，无非还是个矩阵相乘罢了。</strong>激活函数还可以把当前特征空间通过一定的线性映射转换到另一个空间，让数据能够更好的被分类。</p><ul><li>激活函数是个非线性函数：<ol><li>假若网络中全部是线性部件，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数</li><li>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</li></ol></li></ul><p>常见的激活函数有：Logistic函数，Tanh函数，ReLU函数，SoftPlus函数，可见参考<a href="https://www.cnblogs.com/wj-1314/p/12015278.html">【推荐】深度学习笔记——常用的激活（激励）函数</a><br><img src="/img/posts/MachineLearning/activate_fun.jpg" alt="激活函数"></p><h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p>Sigmoid也就是Logistic函数，表达式如下：  </p><p>$${S(x)} = \frac{1}{1+e^{(-x)}}$$  </p><p><img src="/img/posts/MachineLearning/Sigmoid.jpg" alt="Sigmoid函数即其导数图像"><br>绘图对应代码：</p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()# np.arrange(起点，终点，步长)x = np.arange(-10, 10, 0.025) # plot(x,y)plt.plot(x,1/(1+np.exp(-x)))plt.title("y = 1/(1+exp(-x))")# savefig存储要在show之前，不然输出的图片 会是空白plt.savefig('img/output_relu\'(x).png')plt.show() plt.plot(x,np.exp(-x)/(1+np.exp(-x))**2)plt.title("y = exp(-x)/(1+exp(-x))^2")plt.show()</code></pre><ul><li>Sigmoid函数连续可导，值域为(0,1)</li><li>相比较于阶跃函数，可以直接利用梯度下降算法优化网络参数</li><li>作为激活函数，将inputs映射到(0,1)，在早期的神经网络中使用地非常多，因为它很好地解释了神经元受到刺激后是否被激活和向后传递的场景（0：几乎没有被激活；1：完全被激活）。因此可以通过Simoid函数将<strong>输出转化为概率输出</strong>，常用于分类问题的<strong>事件概率</strong></li></ul><p>$$ {S’(x)} = {S(x)}{(1-S(x))} = \frac{e^{-x}}{(1+e^{-x})}$$</p><ul><li>在input x = 0时，导数醉倒为0.25，当输入为正负无穷时，导数趋于0，会发生梯度弥散  </li><li>Sigmoid函数光滑，易于求导，但是时指数级计算，计算量大，容易出现梯度弥散或者梯度饱和</li><li>当神经网络的层数很多时，如果每一层的激活函数都采用Sigmoid函数的话，就会产生梯度弥散和梯度爆炸的问题，其中梯度爆炸发生的概率非常小，而梯度消失发生的概率比较大。</li></ul><p>当一个激活函数S(x)满足<br>右饱和：$ \lim_{n\to +\infty} {S(x)} = 0 $<br>左饱和：$ \lim_{n\to -\infty} {S(x)} = 0 $<br>当S(x)同时满足左饱和与右饱和时，称之为饱和</p><h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>tanh是双曲函数中的一个，tanh() 为双曲正切，关于原点中心对称。在数学中，双曲正切 tanh 是由双曲正弦和双曲余弦这两者基本双曲函数推导而来。  </p><p>正切函数时非常常见的激活函数，<strong>与Sigmoid函数相比，它的输出均值是0</strong>，使得其<strong>收敛速度要比Sigmoid快</strong>，减少迭代次数。相对于Sigmoid的好处是它的输出的均值为0，克服了第二点缺点。<strong>但是当饱和的时候还是会杀死梯度。</strong></p><p>$$ {tanh(x)} = \frac {1-e^{-2x}}{1+e^{-2x}}$$</p><p>$$ {tanh’(x)} = {1-(tanh(x)^2)} =\frac {4e^{-2x}}{(1+e^{-2x})^2}$$</p><p><img src="/img/posts/MachineLearning/tanh.jpg" alt="tanh函数即其导数图像"><br>绘图代码如下</p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()x = np.arange(-10, 10, 0.025)plt.plot(x,(1-np.exp(-2*x))/(1+np.exp(-2*x)))plt.title("y = (1-exp(-2x))/(1+exp(-2x))")plt.show() plt.plot(x,4*np.exp(-2*x)/(1+np.exp(-2*x))**2)plt.title("y = 4exp(-2x)/(1+exp(-2x))^2")plt.show()</code></pre><ul><li>tanh函数的值域(-1,1)</li><li>在神经网络的应用中，tanh通常要优于Sigmoid的，因为tanh的输出在 -1~1之间，均值为0，更方便下一层网络的学习。</li><li>但是如果做二分类，输出层可以使用 Sigmoid，因为它可以算出属于某一类的概率。</li><li>tanh函数也存在着梯度弥散或梯度饱和和幂运算的缺点</li></ul><p>从tanh函数和sigmoid函数表达式中可以看出，<strong>tanh(x)的梯度消失问题比Simgoid(x)要轻，梯度如果过早消失会导致收敛速度较慢</strong></p><ul><li>以零为中心的影响，如果当前参数（w0, w1）的最佳优化方向是 （+d0, -d1），则根据反向传播计算公式，我们希望x0和x1符号相反，但是如果上一级神经元采用 Sigmoid 函数作为激活函数，Sigmoid不以零为中心，输出值恒为正，那么我们无法进行更快的参数更新，而是走Z字形逼近最优解。</li></ul><h3 id="ReLu函数"><a href="#ReLu函数" class="headerlink" title="ReLu函数"></a>ReLu函数</h3><p>针对Sigmoid函数和tanh的缺点，提出ReLU函数。</p><p>线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数。<strong>解决了梯度消失现象</strong>，,收敛速度远远大于 Sigmoid函数和 tanh函数,计算速度更快。计算方便，求导方便，计算速度非常快，只需要判断输入是否大于0。  </p><ul><li><strong>无饱和区，收敛快，计算简单</strong>，有时候会比较脆弱，如果变量的更新太快，还没有找到最佳值，就进入小于零的分段就会使得梯度变为零，无法更新直接死掉了。</li></ul><p>$$ {ReLu(x) = max(x,0)}$$</p><center>当x&gt;=0时，ReLu(x) = x </center><center>当x&lt;0时， ReLu(x) = 9 </center><center>ReLu'(x) = 1, 当x&gt;=0时</center><center>ReLu'(x) = 0, 当x&lt;0时</center>    <p><img src="/img/posts/MachineLearning/ReLu.jpg" alt="ReLu函数即其导数图像"></p><pre class=" language-Python"><code class="language-Python">from matplotlib import pyplot as pltimport numpy as npfig = plt.figure()x = np.arange(-10, 10, 0.025)# clip(x,最小，最大)plt.plot(x,np.clip(x,0,10e30))plt.title("y = relu(x)=max(x,0)")plt.show() from matplotlib import pyplot as pltplt.plot(x,x>0,"o")plt.title("y = relu'(x)")plt.show()</code></pre><p><strong>ReLU函数在零点不可导</strong><br>在反向传播中，对于ReLU间断点的求导按照做到书来计算，即默认情况下默认导数为零，negative_gradient = 0</p><p>可由caffe源码可知<br>~/caffe/src/caffe/layers/relu_layer.cpp倒数第十行代码：</p><pre class=" language-Python"><code class="language-Python">bottom_diff[i] = top_diff[i] * ((bottom_data[i] > 0)+ negative_slope * (bottom_data[i] <= 0));</code></pre><h4 id="ReLU的优缺点"><a href="#ReLU的优缺点" class="headerlink" title="ReLU的优缺点"></a>ReLU的优缺点</h4><p>ReLU函数就是一个取最大值函数，因为它的导数等于1或者就是0<br><strong>因为ReLU是线性的，而sigmoid和tanh是非线性的</strong>。相对于sigmoid和tanh激励函数，对ReLU求梯度非常简单，计算也很简单，可以非常大程度地提升随机梯度下降的收敛速度。</p><ul><li><p>优点： </p><ol><li>解决了梯度消失</li><li>计算方便，秩序判断输入是否大于0</li><li>收敛速度远远大于Sigmoid函数和tanh函数，可以加速网络训练</li></ol></li><li><p>缺点： 随着训练的进行，可能出现神经元死亡的情况，当有一个很大的梯度流经ReLu后，权重的更新结果可能是在此之后的任何数据点都无法激活改神经元</p><ol><li>由于负数部分恒为零，，、当x为负时导数等于零，会导致一些神经元无法激活</li><li>输出不是zero-centered</li><li>learning rate 太高，导致在训练过程中参数更新太大</li></ol></li></ul><h4 id="Leaky-ReLu函数"><a href="#Leaky-ReLu函数" class="headerlink" title="Leaky ReLu函数"></a>Leaky ReLu函数</h4><p>Leaky ReLU解决了ReLU会杀死一部分神经元的情况。Leaky ReLU 是给所有负值赋予一个非零斜率。Leaky ReLU 激活函数是在声学模型（2013）中首次提出。</p><p><img src="/img/posts/MachineLearning/LeakyReLu.jpg"></p><p><img src="/img/posts/MachineLearning/Leaky_ReLu.jpg" alt="Leaky_ReLu函数即其导数图像"></p><p>　人们为了解决 Dead ReLU Problem(ReLU的死神经问题), 提出了将 ReLU 的前半段设为 ax 而非0，通常 a = 0.01，另外一种直观的想法是基于参数的方法，即 ParmetricReLU ： f(x)=max(ax, x)，其中 a 可由方向传播算法学出来。理论上来说，Leaky ReLU 有ReLU的所有优点，外加不会有 Dead ReLU 问题，但是在实际操作当中，并没有完全证明 Leaky ReLU 总是好于 ReLU。</p><p><strong>Leaky  ReLU 主要是为了避免梯度消失，当神经元处于非激活状态时，允许一个非0的梯度存在</strong>，这样不会出现梯度消失，收敛速度快。他的优缺点和ReLU类似。</p><h3 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h3><p><a href="https://blog.csdn.net/lz_peter/article/details/84574716?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166289193816800184112865%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166289193816800184112865&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84574716-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Eadd_ask&amp;utm_term=softmax&amp;spm=1018.2226.3001.4187">Softmax理解</a></p><p>　　softmax 函数，又称为归一化指数函数。它是二分类函数 Sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。</p><p>他把<strong>一些输入映射为0-1之间的实数，并且归一化保证和为1，因此多分类的概率之和也刚好为1。</strong></p><p><img src="/img/posts/MachineLearning/Softmax01.jpg" alt="Softmax解释"></p><p>假设有一个数组V， $V_i$​表示V中的第i个元素，那么这个元素的softmax值为:</p><p>$$ S_i = \frac {e^i}{\sum_je^j} $$</p><p>该元素的softmax值，就是该元素的指数与所有元素指数和的比值。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在机器学习任务中，大部分监督学习算法都会有一个目标函数 (Objective Function),算法对该目标函数进行优化，称为优化算法的过程。 例如在分类或者回归任务中，<strong>使用损失函数( Loss Function )作为其目标函数对算法模型进行优化</strong>。</p><p>在BP神经网络中，使用均方误差作为损失函数，而在实际中，常用交叉熵作为损失函数。</p><ul><li><p>均方误差作为损失函数收敛速度慢，可能会陷入局部最优解；<strong>交叉熵</strong>作为损失函数的<strong>收敛速度</strong>比均方误差<strong>快</strong>，且较为容易找到函数最优解.</p></li><li><p>均方差损失函数：<br>  <img src="/img/posts/MachineLearning/avg_sqar.jpg"></p></li><li><p>Logistic 损失函数<br>  <img src="/img/posts/MachineLearning/logistic_loss.jpg"></p></li><li><p>负对数似然损失函数<br>  <img src="/img/posts/MachineLearning/neg_log_loss.jpg"></p></li><li><p><a href="https://blog.csdn.net/tsyccnh/article/details/79163834?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166289228816782412517434%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166289228816782412517434&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79163834-null-null.142%5Ev47%5Econtrol_1,201%5Ev3%5Eadd_ask&amp;utm_term=%E4%BA%A4%E5%8F%89%E7%86%B5&amp;spm=1018.2226.3001.4187">交叉熵损失函数</a>:Logistic损失函数和负对数似然损失函数只能处理二分类问题，对于两个分类扩展到M个分类，使用交叉熵损失函数(Cross Entropy Loss)，熵用来表示所有信息量的期望[信息量：当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小，信息量和事件发生的概率]，其定义如下：</p><h2 id=""><a href="#" class="headerlink" title="  "></a>  <img src="/img/posts/MachineLearning/cross_entropy_loss.jpg"></h2></li><li><p>Hige:典型分类器是SVM算法因为 Hinge 损失可以用来解决间隔最大化问题。当分类模型需要硬分类结果的，例如分类结果是 0 或 1 、 -1或 1 的二分类数据， Hinge 损失是最方便的选择 。Hinge 损失函数定义如下：<br>  <img src="/img/posts/MachineLearning/hinge_loss.jpg"></p></li></ul><h3 id="神经网络中常用的损失函数"><a href="#神经网络中常用的损失函数" class="headerlink" title="神经网络中常用的损失函数"></a>神经网络中常用的损失函数</h3><p><a href="https://blog.csdn.net/weixin_44222014/article/details/103271192">常用损失函数参考介绍</a></p><ol><li><p>ReLU + MSE(均方差)<br> 均方误差损失函数无法处理梯度消失问题，而使用 Leak ReLU 激活函数能够减少计算时梯度消失的问题，因此在神经网络中如果需要使用均方误差损失函数，一般采用 Leak ReLU 等可以减少梯度消失的激活函数。另外，由于均方误差具有普遍性，一般作为衡量损失值的标准，因此使用均方误差作为损失函数表现既不会太好也不至于太差。</p></li><li><p>Sigmoid + Logistic<br> Sigmoid 函数会引起梯度消失问题：根据链式求导法，Sigmoid 函数求导后由多个［0, 1］范围的数进行连乘，如其导数形式为 ，当其中一个数很小时，连成后会无限趋近于零直至最后消失。而类 Logistic 损失函数求导时，加上对数后连乘操作转化为求和操作，在一定程度上避免了梯度消失，所以我们经常可以看到 Sigmoid 激活函数＋交叉摘损失函数 的组合。</p></li><li><p>Softmax + Logisitc<br> 在数学上，Softmax 激活函数会返回输出类的互斥概率分 布，也就是能把离散的输出转换为一个同分布互斥的概率，如(0.2, 0.8)。另外，Logisitc 损失函数是基于概率的最大似然估计函数而来的，因此输出概率化能够更加方便优化算法进行求导和计算，所以我们经常可以看到输出层使xu用Softmax激活函数＋交叉熵损失函数 的组合。</p></li></ol><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>深度学习网络训练过程可以分成两大部分：前向计算过程与反向传播过程。前向计算过程，是指通过我们预先设定好的卷积层、池化层等等，<strong>按照规定的网络结构一层层前向计算，得到预测的结果</strong>。反向传播过程，是为了将设定的网络中的<strong>众多参数</strong>一步步调整，使得<strong>预测结果能更加贴近真实值</strong>。在反向传播中参数更新显得尤为重要。</p><p>参数应该是<strong>朝着目标损失函数下降最快的方向</strong>更新，更确切的说，要朝着<strong>梯度方向</strong>更新</p><ul><li><p>随机梯度下降法：每次迭代（更新参数）只使用单个训练样本<br>  优点：一次迭代只需对一个样本进行计算，因此运行速度很快，还可用于在线学习<br>  缺点：（1）由于单个样本的随机性，实际过程中，目标损失函数值会剧烈波动，一方面，SGD 的波动使它能够跳到新的可能更好的局部最小值。另一方面，使得训练永远不会收敛，而是会<strong>一直在最小值附近波动</strong>。（2）一次迭代只计算一张图片，没有发挥GPU并行运算的优势，使得<strong>整体计算的效率不高</strong>。</p></li><li><p>批量梯度下降法：每次迭代更新中使用所有的训练样本<br>  优缺点分析：批量梯度下降算法能保证收敛到凸误差表面的全局最小值和非凸表面的局部最小值。但每迭代一次，需要用到训练集中的所有数据，如果数据量很大，那么迭代速度就会非常慢。</p></li><li><p>小批量梯度下降法：折中了 BGD 和 SGD 的方法，每次迭代使用 batch_size 个训练样本进行计算<br>  优缺点分析：因为每次迭代使用多个样本，所以 MBGD 比 SGD 收敛更稳定，也能避免 BGD 在数据集过大时迭代速度慢的问题。因此，MBGD是深度学习网络训练中经常使用的梯度下降方法。</p></li></ul><h3 id="动量梯度下降"><a href="#动量梯度下降" class="headerlink" title="动量梯度下降"></a>动量梯度下降</h3><p>动量梯度下降使得当前的参数更新方向不仅与当前的梯度有关，也受历史的加权平均梯度影响。对于梯度指向相同方向的维度，动量会积累并增加，而对于梯度改变方向的维度，动量会减少更新。这也就使得收敛速度加快，同时又不至于摆动幅度太大。</p><p>本质上，当使用动量时，如同我们将球推下山坡。球在滚下坡时积累动量，在途中变得越来越快。同样的事情发生在参数更新上：对于梯度指向相同方向的维度，动量会积累并增加，而对于梯度改变方向的维度，动量会减少更新。<strong>结果，我们获得了更快的收敛和减少的振荡</strong>。</p><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><p>Adam 是另一种参数自适应学习率的方法，相当于 RMSprop + Momentum，利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率</p><h2 id="激活函数、损失函数、优化函数的区别"><a href="#激活函数、损失函数、优化函数的区别" class="headerlink" title="激活函数、损失函数、优化函数的区别"></a>激活函数、损失函数、优化函数的区别</h2><p>1.激活函数：将神经网络上一层的输入，经过神经网络层的<strong>非线性变换转换</strong>后，通过激活函数，<strong>得到输出</strong>。常见的激活函数包括：sigmoid, tanh, relu等。</p><p><a href="https://blog.csdn.net/u013250416/article/details/80991831">激活函数</a></p><p>2.损失函数：度量神经网络的<strong>输出的预测值与实际值之间的差距</strong>的一种方式。常见的损失函数包括：最小二乘损失函数、交叉熵损失函数、回归中使用的smooth L1损失函数等。</p><p>3.优化函数：也就是如何把<strong>损失值</strong>从神经网络的最外层<strong>传递到最前面</strong>。如最基础的梯度下降算法，随机梯度下降算法，批量梯度下降算法，带动量的梯度下降算法，Adagrad，Adadelta，Adam等。</p><p><a href="https://blog.csdn.net/u013250416/article/details/81090059">优化函数</a></p><p>CNN由<strong>卷积层</strong>、<strong>池化层</strong>、<strong>全连接层</strong>三部分组成。</p><h2 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h2><p><a href="https://www.zhihu.com/question/22298352/answer/91131073">卷积</a></p><p>卷积网络执行的是监督训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。</p><ul><li><p>CNN的特点：</p><ol><li>能够有效的将大数据量的图片降维成小数据量。</li><li>能够有效的保留图片特征，符合图片处理的原则。</li></ol></li><li><p>CNN的核心：</p><ol><li>局部连接：通过卷积操作实现局部连接，这个局部区域的大小就是滤波器filter，避免了全连接中参数过多造成无法计算的情况。<br>  一般认为图像的空间联系是局部的像素联系比较密切，而距离较远的像素相关性较弱，因此，<strong>每个神经元没必要对全局图像进行感知，只要对局部进行感知</strong>，然后在<strong>更高层</strong>将<strong>局部的信息综合起来</strong>得到全局信息。</li></ol><ul><li>具体实现： 网络部分连通，每个神经元只与上一层的部分神经元相连，只感知局部，而不是整幅图像。</li></ul><ol start="2"><li>权值(参数)共享：通过权值共享来缩减实际参数的数量，为实现多层网络提供了可能。<br>  在局部连接中，每个神经元的参数都是一样的，即：<strong>同一个卷积核在图像中都是共享的。</strong>(对于图像上这部分学到的特征也可以用到另一部分上。所以对图像上的所有位置，都能使用同样的学习特征。)<br>  但卷积核共享会导致提取特征不充分，因此要<strong>通过增加多个卷积核来弥补</strong>，学习多种特征</li></ol></li></ul><p>CNN在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>以图像处理为例， 一般用一个正方形卷积核，遍历图片上的每一个像素点。<strong>图片与卷积核重合区域内</strong>相对应的<strong>每一个像素值</strong>，乘<strong>卷积核内相对应点</strong>的<strong>权重</strong>，然后<strong>求和</strong>， 再加上偏置后，最后得到输出图片中的一个像素值。<br>图片分<strong>灰度图</strong>和<strong>彩色图</strong>，卷积核可以是<strong>单个</strong>也可以是<strong>多个</strong>，因此卷积操作分以下三种情况：</p><ol><li><p>单通道输入，单卷积核</p><p> 单通道输入即灰度图，但卷积核即卷积核个数为1。<br> <img src="/img/posts/MachineLearning/simple_convo.jpg"></p><p> 上面是 5x5x1 的灰度图片，1表示单通道，5x5 表示分辨率，共有 行5列个灰度值。若用一个 3x3x1 的卷积核对  此5x5x1的灰度图片进行卷积，偏置项b=1，则求卷积的计算是：(-1)x1+0x0+1x2+(-1)x5+0x4+1x2+(-1)x3+0x4+1x5+1=1（注意不要忘记加偏置 1）。</p></li><li><p>多通道输入，单卷积核</p><p> 输入为彩色图片，输入的图片包含了红、绿、蓝三层数据，<strong>卷积核的深度（通道数）应该等于输入图片的通道数</strong>，所以使用 3x3x3的卷积核，最后一个 3 表示匹配输入图像 的 3 个通道，这样这个卷积核有三通道，<strong>每个通道都会随机生成 9 个待优化的参数</strong>，一共有<strong>27 个待优化参数  w</strong>和<strong>一个偏置 b</strong>。<br>  <img src="/img/posts/MachineLearning/simple_convo.jpg"></p><p> 这里还是单个卷积核的情况，但是一个卷积核可以有多个通道。默认情况下，卷积核的通道数等于输入图片的通道数。</p></li><li><p>多通道输入，多卷积核</p><p> 这是神经网络中最常见的方式，此处以3通道输入，两个卷积核为例。<br> <img src="/img/posts/MachineLearning/multi_convo.jpg"></p><ol><li>和多通道输入，单卷积核一样,先取出一个卷积核与3通道的输入进行卷积,得到一个1通道的输出output1。同样再取出第二个卷积核进行同样的操作,得到第二个输出output2。</li><li>将相同size的output1与output2进行堆叠，就得到2通道的输出output。<br> 图中输入X:[1,h,w,3]指的是：输入1张高h宽w的3通道图片。<br> 卷积核W:[k,k,3,2]指的是：卷积核尺寸为3*3，通道数为3，个数为2。</li></ol></li></ol><ul><li><strong>卷积核的个数和卷积核的通道数</strong>是不同的概念。每层卷积核的个数在设计网络时会给出，但是卷积核的通道数不一定会给出。<strong>默认情况下，卷积核的通道数=输入的通道数</strong>，因为这是进行卷积操作的必要条件。</li><li>卷积操作后，<strong>输出的通道数=卷积核的个数</strong></li><li>偏置数=卷积核数</li></ul><p>在卷积层中，可以通过调节步长参数 s 实现特征图的高宽成倍缩小，从而降低网络的参数量。</p><p>卷积层参数/卷积计算量<br>卷积参数 = 卷积核长度x卷积核宽度x输入通道数x输出通道数+输出通道数（偏置）<br>卷积计算量 = 输出数据大小x卷积核的尺度x输入通道数</p><p>例：输入：224x224x3，输出：224x244x64，卷积核：3x3</p><p>参数量 = 3x3x3x64+64<br>计算量 = 224x224x64x3x3x3</p><h4 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充 Padding"></a>填充 Padding</h4><p>为了使卷积操作后能得到满意的输出图片尺寸，经常会使用padding对输入进行填充操作。默认在图片周围填充0。</p><h3 id="池化层（Pooling-layel"><a href="#池化层（Pooling-layel" class="headerlink" title="池化层（Pooling-layel)"></a>池化层（Pooling-layel)</h3><p>功能：主要作用是把数据降维，可以有效的避免过拟合<br>池化作用如下</p><ol><li>使卷积神经网络<strong>抽取特征</strong>是<strong>保证特征局部不变性。</strong></li><li>池化操作能<strong>降低维度</strong>，<strong>减少参数数量</strong>。</li><li>池化操作优化比较简单。</li></ol><p><img src="/img/posts/MachineLearning/pooling.jpg"></p><p><img src="/img/posts/MachineLearning/pooling2.jpg"></p><p>池化层同样基于<strong>局部相关性</strong>的思想，通过从<strong>局部相关</strong>的一组元素中进行采样或信息聚合，从而得到新的元素值。通常我们用到两种池化进行下采样：<br>（1）最大池化(Max Pooling)，从局部相关元素集中选取最大的一个元素值。<br>（2）平均池化(Average Pooling)，从局部相关元素集中计算平均值并返回。</p><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>功能：根据不同任务输出我们想要的结果</p><p>每个神经元与前后相邻层的每一个神经元都有连接关系,输入特征，输出预测的结果。<br>全连接层的参数量 = $\sum {(前层x后层+后层)}$</p><p>由于一般全连接层参数较多，实际应用中一般不会将原始图片直接喂入全连接网络。尤其现实生活中高分辨率的彩色图像，像素点更多，且为红绿蓝三通道信息。待优化的参数过多， 容易导致模型过拟合。<br>在实际应用中，会先对原始图像<strong>进行卷积特征提取</strong>，把提取到的<strong>特征</strong>喂给全连接网络，再让全连接网络计算出分类评估值。</p><h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>卷积神经网络中最常用的是ReLU。<br><a href="https://blog.csdn.net/wjinjie/article/details/104729911">激活函数的选择</a></p><h3 id="卷积神经网络的训练步骤"><a href="#卷积神经网络的训练步骤" class="headerlink" title="卷积神经网络的训练步骤"></a>卷积神经网络的训练步骤</h3><p><img src="/img/posts/MachineLearning/convo_procedure.jpg"></p><ol><li><p>用随机数初始化<strong>所有的卷积核参数/权重</strong></p></li><li><p>将训练集图片作为输入，进行前向步骤，包括<strong>卷积</strong>、<strong>ReLU激活</strong>、<strong>池化</strong>、<strong>全连接层的前向传播</strong>，并计算各个类别对应的输出概率</p></li><li><p>计算出书层的总误差</p></li><li><p>用误差<strong>反向传播</strong>算法计算<strong>误差相对于所有权重的梯度</strong>，利用梯度下降<strong>更新所有的卷积核参数/权重的值</strong></p></li></ol><p>卷积核个数、卷积核尺寸、网络架构这些参数，是在 之前就已经固定的，且不会在训练过程中改变——只有<strong>卷积核矩阵</strong>和<strong>神经元权重</strong>会更新。</p><h4 id="经典网络介绍"><a href="#经典网络介绍" class="headerlink" title="经典网络介绍"></a>经典网络介绍</h4><p><a href="https://blog.csdn.net/jiaoyangwm/article/details/80011656">卷积神经网络介绍</a></p><ul><li><p>残差网络(Residual Network,ResNet)：通过非线性的卷积层增加直连边，也就是残差连接的方式来提高信息传播小笼包</p></li><li><p>AlexNet</p></li></ul><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p><a href="https://my.oschina.net/u/876354/blog/1621839">循环神经网络</a>通过使用带自反馈的神经元，能够处理任意长度的序列，比前馈神经网络更符合生物神经网络结构。<br>RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。</p><h2 id="目标检测算法-Yolo"><a href="#目标检测算法-Yolo" class="headerlink" title="目标检测算法-Yolo"></a>目标检测算法-Yolo</h2><p>Yolo是one-stage，一步回归到位，与two-stage相比，核心优势在于速度非常快，适合做实时检测任务，但可能相比two-stage(MaskRcnn)的检测精度效果会相对较差</p><p>考虑指标；</p><ul><li>map：map越高，效果越好，，不要单看精度、召回率。把所有阈值都考虑进来，以recall为横轴，precison为纵轴，作一个曲线图，map值就是所有类别的平均值</li><li>IoU：/frac {预测值与真实值的重叠区域(交集)}{预测值与真实值的并集}，IoU越高越好</li><li>精度 = /frac {TP}{TP+FP}</li><li>召回率 = /frac {TP}{TP+FN}</li></ul><p>在检测任务中的精度与招呼率代表：</p><ul><li><p>TP = true positive(1被正确的判断为1) FN = false Negative（1被错误的判断为0）</p></li><li><p>FP = false positive(0被错误的判断为1) FN = false negative（0被正确的判断为0）</p></li><li><p>置信度(confidence)：通俗而言就是检测一个物体它是一个人的可能性有多大，需要基于置信度阈值来计算</p></li></ul><p>Yolo的map比fast-Rcnn低，但速度比rcnn快</p><h3 id="Yolo-V1"><a href="#Yolo-V1" class="headerlink" title="Yolo-V1"></a>Yolo-V1</h3><p>输入： SxS的网格</p><p>预测得出得出bounding box（x,y,w,h） + confidence ==&gt; 四个偏移量加上一个置信度</p><ul><li>置信度较高才说明是一个物体，此时再去作筛选</li></ul><h3 id="Yolo-v3"><a href="#Yolo-v3" class="headerlink" title="Yolo-v3"></a>Yolo-v3</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习3-多元梯度下降</title>
      <link href="/2021/07/30/ji-qi-xue-xi-3-duo-yuan-ti-du-xia-jiang/"/>
      <url>/2021/07/30/ji-qi-xue-xi-3-duo-yuan-ti-du-xia-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>多元线性回归也就是用多个特征变量来进行预测  </p><div align="center"><font size="4">$h_\theta$($\theta$) = $\theta_0$+$\theta_1$$x_1$+$\theta_2$$x_2$+$\theta_3$$x_3$+$\theta_4$$x_4$...+$\theta_n$$x_n$</font></div>    <center>定义$x_0$ = 1</center>  <p>所以<br>    x =<br>        $$\begin{bmatrix}<br>        x_0 x_1 x_2 … x_n<br>        \end{bmatrix}$$</p><p>$\theta$ = $$\begin{bmatrix}\theta_0 \ \theta_1  \ \theta_2 \ … \theta_n\end{bmatrix}$$</p><p>所以得出$h_\theta(x) = \theta^Tx$</p><h2 id="用梯度下降处理多元线性回归"><a href="#用梯度下降处理多元线性回归" class="headerlink" title="用梯度下降处理多元线性回归"></a>用梯度下降处理多元线性回归</h2><p>在梯度下降中的假设<br>$$h_\theta(x) = \theta^Tx$$</p><p>代价函数</p><p>$$J(\theta_0,\theta_1…\theta_n) = \frac{1}{2m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))^2$$</p><p>梯度下降</p><center>重复多次</center>    <p>$$\theta := \theta_j - \alpha \frac{\partial {J(\theta)}}{\partial \theta_j}$$</p><p>$\alpha$是学习率</p><p>最终梯度下降</p><center>重复</center>$$ \theta_j := \theta_j - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_j^{(i)}$$<p>即<br>$$ \theta_0 := \theta_0 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_0^{(i)}$$<br>$$ \theta_1 := \theta_1 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_1^{(i)}$$<br>$$ \theta_2 := \theta_2 - \alpha \frac{1}{m} \displaystyle \sum_{i=1}^m (h_\theta(x^{(i)}-y^{(i)}))x_2^{(i)}$$</p><h2 id="特征缩放-Feature-scaling"><a href="#特征缩放-Feature-scaling" class="headerlink" title="特征缩放(Feature scaling)"></a>特征缩放(Feature scaling)</h2><blockquote><p>不同特征的取值在一个相近的范围，这样梯度下降容易更好地收敛</p></blockquote><p>特征地范围不要过小也不要过大</p><h3 id="均值归一化-Mean-normalization"><a href="#均值归一化-Mean-normalization" class="headerlink" title="均值归一化(Mean normalization)"></a>均值归一化(Mean normalization)</h3><blockquote><p>将$x_i$用$x_i-\mu_i$代替是的特征均值为0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-哈希表</title>
      <link href="/2021/07/30/leetcode-ha-xi-biao/"/>
      <url>/2021/07/30/leetcode-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="构造哈希表"><a href="#构造哈希表" class="headerlink" title="构造哈希表"></a>构造哈希表</h2><p>参考<a href="https://leetcode.cn/problems/design-hashset/">Leetcode705-设计哈希结合</a></p><p>要解决的问题</p><ul><li>映射： 将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</li><li>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理</li><li>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</li></ul><p>考虑到哈希表后期需要扩容，一般不会考虑直接用数组，而是采用链表</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习2-矩阵方程</title>
      <link href="/2021/07/23/ji-qi-xue-xi-2-ju-zhen-fang-cheng/"/>
      <url>/2021/07/23/ji-qi-xue-xi-2-ju-zhen-fang-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵的基本概念"><a href="#矩阵的基本概念" class="headerlink" title="矩阵的基本概念"></a>矩阵的基本概念</h2><ul><li>dimension ：行x列 </li><li>矩阵表示<br>  2x3的矩阵表示:<br>  $$\begin{bmatrix}<br>  1&amp;1&amp;0 \<br>  1&amp;0&amp;1 \<br>  \end{bmatrix}$$<br><br>  3x2的矩阵表示:<br>  $$\begin{bmatrix}<br>  0&amp;1 \<br>  1&amp;0 \<br>  1&amp;1 \<br>  \end{bmatrix}$$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch配置</title>
      <link href="/2021/07/21/torch-pei-zhi/"/>
      <url>/2021/07/21/torch-pei-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cuda:11.3.0（官网安装）<a href="https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local">https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local</a><br>Nvida CUDA 11.4.141<br>显卡： NVDIA Getforce RTX 3050 Ti</p></blockquote><p>troch安装网址：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><h2 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h2><p>直接在C:\user\.condarc中修改</p><pre class=" language-shell"><code class="language-shell">channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - defaultsssl_verify: falseshow_channel_urls: truereport_errors: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习1--机器学习是干什么</title>
      <link href="/2021/07/20/ji-qi-xue-xi-1-ji-qi-xue-xi-shi-gan-shi-me/"/>
      <url>/2021/07/20/ji-qi-xue-xi-1-ji-qi-xue-xi-shi-gan-shi-me/</url>
      
        <content type="html"><![CDATA[<p>监督学习与非监督学习，假设函数与代价函数，梯度下降</p><h2 id="监督学习与非监督学习"><a href="#监督学习与非监督学习" class="headerlink" title="监督学习与非监督学习"></a>监督学习与非监督学习</h2><blockquote><p><strong>有无预期输出</strong>是监督学习与非监督学习的最大区别</p></blockquote><ul><li>监督学习：学习一个模型使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</li></ul><p>即：利用训练数据集学习一个模型，再用模型对测试样本集进行预测。</p><p><strong>分类问题（离散）</strong>与<strong>回归问题（连续）</strong>等都是监督学习。</p><ul><li>非监督学习：直接对数据进行建模。没有给定事先标记过的训练范例，所用的数据没有属性或标签这一概念。事先不知道输入数据对应的输出结果是什么。</li></ul><p>自动对输入的资料进行分类或分群，以寻找数据的模型和规律。</p><p><strong>聚类算法</strong>是一种非监督学习，针对数据集，自动找出数据中的结构，从而把数据分成不同的簇。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>此处以最简单的线性回归（如房价预测）为例，线性回归的学习是为了预测未来房价</p><p>机器学习是在已知部分x与y的情况下，得出一个房价相关的线性函数y = ax + b</p><p>所以代价函数是与参数a,b相关的函数,使得代价函数最小化，是线性回归中的学习目标</p><p>常用的代价函数有<br>    <img src="/img/posts/MachineLearning/cost_function.jpg" alt="平方和代价函数"></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="梯度下降的过程"><a href="#梯度下降的过程" class="headerlink" title="梯度下降的过程"></a>梯度下降的过程</h3><ol><li>选定几个参数a1,a2,a3…</li><li>选择初始值</li><li>从初值开始按照给定的步幅进行梯度下降，寻找局部极小值</li></ol><p><img src="/img/posts/MachineLearning/slope0.jpg" alt="梯度下降可以用等高线图具象化"></p><p><img src="/img/posts/MachineLearning/slope1.jpg" alt="选择初始点"></p><p><img src="/img/posts/MachineLearning/slope3.jpg" alt="从a点一步一步往下梯度下降"></p><p><img src="/img/posts/MachineLearning/slope2.jpg" alt="从b点一步一步往下梯度下降"></p><blockquote><p>从不同的点进行梯度下降可能得到<strong>不同</strong>的局部极小值</p></blockquote><h3 id="梯度下降的数理解释"><a href="#梯度下降的数理解释" class="headerlink" title="梯度下降的数理解释"></a>梯度下降的数理解释</h3><p><img src="/img/posts/MachineLearning/slope_definition.jpg" alt="梯度下降的数理解释"></p><p>a是学习率<br>下一步的值 = 这一步的值 - 学习率*代价函数分别对参数a1,a2,a3…的偏导</p><p>对于梯度下降公式中偏导的简化</p><p><img src="/img/posts/MachineLearning/slope_deri0.jpg" alt="符合求偏导"></p><p>梯度下降是一种<strong>同步更新</strong>算法，要求参数a1,a2,a3同步更新，所以<br><img src="/img/posts/MachineLearning/slope_detail0.jpg" alt="要按照左侧的顺序来"></p><h3 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h3><p><img src="/img/posts/MachineLearning/slope_linear.jpg" alt="梯度下降再线性回归中的模型"></p><p>将代数函数用等高线图（右侧）表示</p><p><img src="/img/posts/MachineLearning/slope4.jpg" alt="由于该代数函数是一个凹函数，所以局部极小就是全局最小，因此要得到左侧最拟合的目标函数，需要右侧趋近于等高线图最中间的圆圈"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度下降 </tag>
            
            <tag> 代价函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>识别mnist手写数字数据集</title>
      <link href="/2021/07/11/shi-bie-mnist-shou-xie-shu-zi-shu-ju-ji/"/>
      <url>/2021/07/11/shi-bie-mnist-shou-xie-shu-zi-shu-ju-ji/</url>
      
        <content type="html"><![CDATA[<p>MNIST包含70,000张手写数字图像: 60,000张用于培训，10,000张于测试。图像是灰度的，28x28像素的。<br>识别mnist手写数字及可以视作图像识别的入门学习任务<br>需要准备pytorch环境</p><pre class=" language-Python"><code class="language-Python">import torchimport torchvisionfrom torch.utils.data import DataLoader</code></pre><h2 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h2><pre class=" language-Python"><code class="language-Python">n_epochs = 3 # 整个训练集训练的次数batch_size_train = 64  # 训练集的批次大小batch_size_test = 1000  # 测试机batchsizelearning_rate = 0.01momentum = 0.5log_interval = 10# 对于可重复实验设置随机种子，进行重复实验，设置随机种子random_seed = 1torch.manual_seed(random_seed)</code></pre><p>learning_rate和momentum是我们稍后将使用的优化器的超参数。  </p><h2 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h2><p>直接利用torchvision加载minist数据集，我们将使用batch_size=64进行训练，并使用size=1000对这个数据集进行测试。下面的Normalize()转换使用的值0.1307和0.3081是MNIST数据集的全局平均值和标准偏差，此处我们将它们作为给定值。</p><pre class=" language-Python"><code class="language-Python"> # 下载训练集和测试集, './minist_data'是目录下相对路径 # 记得要设置download为true，不然可能下载到一般突然中断 # train=True是训练集，batch_size=batch_size_traintrain_loader = dataLoader(    torchvision.datasets.MNIST('./mnist_data',train=True, download=True,                          transform= torchvision.transforms.Compose([                              torchvision.transforms.ToTensor(),                              torchvision.transforms.Normalize((0.1307,),(0.3081,))                          ])),    batch_size=batch_size_train, shuffle=True) # train=False是测试集，batch_size=batch_size_testtest_loader = dataLoader(    torchvision.datasets.MNIST('./mnist_data',train=False, download=True,                          transform= torchvision.transforms.Compose([                              torchvision.transforms.ToTensor(),                              torchvision.transforms.Normalize((0.1307,),(0.3081,))                          ])),    batch_size=batch_size_test, shuffle=True)</code></pre><p>下载完成后，在目录./mnist_data/MNIST/raw目录下可以看到这些<br><img src="/img/posts/Programming/mnist0.jpg"></p><p>利用train_loader来看训练数据的组成</p><pre class=" language-Python"><code class="language-Python">examples = enumerate(train_loader)batch_idx, (example_data, example_targets) = nex(examples)print(example_targets)  # example_targets是图片实际对应的数字标签print(example_data.shape)  # 一批训练数据是一个数据张量</code></pre><p>输出结果<br><img src="/img/posts/Programming/mnist1.jpg"></p><p>这意味着我们有64个例子的28x28像素的灰度(即没有rgb通道)。</p><p>尝试用mathplotllib绘制部分</p><pre class=" language-Python"><code class="language-Python">import matplotlib.pyplot as pltfig = plt.figure()for i in range(12):    plt.subplot(3,4,i+1)  # subplot(m,n,i) 说明是m*n的网格表示，i表示每个plot的编号， 这样可以把几张图放在一张图片中表示出来    plt.tight_layout()    plt.imshow(example_data[i][0], cmap='gray', interpolation='none')    plt.title("Ground Truth:{}".format(example_targets[i]))    plt.xticks([])    plt.yticks([])plt.show()</code></pre><p><img src="/img/posts/Programming/mnist2.jpg" alt="输出结果"></p><h2 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
